import puppeteer from 'puppeteer-extra';
import StealthPlugin from 'puppeteer-extra-plugin-stealth';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import express from 'express';

puppeteer.use(StealthPlugin());

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = 3000;
const outputDir = path.join(__dirname, 'screenshots');

await fs.ensureDir(outputDir);
console.log('🗂 Screenshot directory ensured:', outputDir);

app.use(express.static(path.join(__dirname, 'public')));

app.use('/screenshots', express.static(outputDir, {
    setHeaders: (res, filePath) => {
        console.log(`📸 Serving screenshot: ${filePath}`);
    }
}));

app.get('/api/screenshots', async (req, res) => {
    try {
        const files = await fs.readdir(outputDir);
        const imageFiles = files.filter(file => file.endsWith('.png'));
        res.json({ screenshots: imageFiles });
    } catch (error) {
        console.error('❌ Error fetching screenshots:', error);
        res.status(500).json({ error: 'Failed to retrieve screenshots' });
    }
});


const captureMockup = async () => {
    const url = 'https://www.linkedin.com';
    console.log(`🌐 Navigating to: ${url}`);

    const browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox']
    });

    const page = await browser.newPage();
    
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36');
    await page.setViewport({ width: 1440, height: 900 });

    await page.goto(url, { waitUntil: 'networkidle2' });

    // Wait for cookie popup and try to click "Accept"
    try {
        await page.waitForSelector('button', { timeout: 5000 });
        const accepted = await page.evaluate(() => {
            const buttons = Array.from(document.querySelectorAll('button'));
            const acceptButton = buttons.find(btn => 
                /accept|consent/i.test(btn.innerText)
            );
            if (acceptButton) {
                acceptButton.click();
                console.log(`✅ Clicked cookie button: ${acceptButton.innerText}`);
                return true;
            }
            return false;
        });

        if (!accepted) console.log("⚠️ No consent button found.");
    } catch (error) {
        console.log("⚠️ No cookie popups detected.");
    }

    // Wait for cookies to be processed
    await new Promise(resolve => setTimeout(resolve, 4000));

    const totalHeight = await page.evaluate(() => document.body.scrollHeight);
    const viewportHeight = await page.viewport().height;
    let currentPosition = 0;
    let index = 0;

    while (currentPosition < totalHeight) {
        const screenshotPath = path.join(outputDir, `section_${index}.png`);
        await page.screenshot({ path: screenshotPath, fullPage: false });

        console.log(`✅ Screenshot captured: ${screenshotPath}`);

        currentPosition += viewportHeight;
        await page.evaluate((scrollAmount) => window.scrollBy(0, scrollAmount), viewportHeight);

        await new Promise(resolve => setTimeout(resolve, 500));

        index++;
    }

    await browser.close();
    console.log('📸 Screenshot capture completed.');
};

app.listen(PORT, async () => {
    console.log(`🚀 Server running at http://localhost:${PORT}`);
    await captureMockup();
});









2


import puppeteer from 'puppeteer-extra';
import StealthPlugin from 'puppeteer-extra-plugin-stealth';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import express from 'express';
import cors from 'cors';

puppeteer.use(StealthPlugin());

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = 3000;
const outputDir = path.join(__dirname, 'screenshots');

await fs.ensureDir(outputDir);
console.log('🗂 Screenshot directory ensured:', outputDir);

// Middleware
app.use(cors()); // Allow requests from the frontend
app.use(express.json()); // Parse JSON request body
app.use(express.urlencoded({ extended: true })); // Parse form data
app.use(express.static(path.join(__dirname, 'public')));
app.use('/screenshots', express.static(outputDir));


// Endpoint to fetch available screenshots
app.get('/api/screenshots', async (req, res) => {
    try {
        const files = await fs.readdir(outputDir);
        const imageFiles = files.filter(file => file.endsWith('.png'));
        res.json({ screenshots: imageFiles });
    } catch (error) {
        console.error('❌ Error fetching screenshots:', error);
        res.status(500).json({ error: 'Failed to retrieve screenshots' });
    }
});

// Endpoint to capture screenshot from a URL
app.post('/api/capture', async (req, res) => {
    const { url } = req.body;
    if (!url) {
        return res.status(400).json({ error: 'URL is required' });
    }

    console.log(`🗑️ Clearing old screenshots...`);
    try {
        const files = await fs.readdir(outputDir);
        for (const file of files) {
            if (file.endsWith('.png')) {
                await fs.unlink(path.join(outputDir, file));
            }
        }
        console.log(`✅ Cleared old screenshots.`);
    } catch (error) {
        console.error('❌ Error clearing old screenshots:', error);
    }

    console.log(`🌐 Capturing new screenshots for: ${url}`);

    try {
        await captureMockup(url);
        res.json({ success: true, message: `Screenshots captured for ${url}` });
    } catch (error) {
        console.error('❌ Screenshot capture failed:', error);
        res.status(500).json({ error: 'Failed to capture screenshot' });
    }
});


const captureMockup = async (url) => {
    console.log(`🌐 Navigating to: ${url}`);

    const browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox']
    });

    const page = await browser.newPage();
    
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36');
    await page.setViewport({ width: 1440, height: 900 });

    await page.goto(url, { waitUntil: 'networkidle2' });

    try {
        await page.waitForSelector('button', { timeout: 5000 });
        const accepted = await page.evaluate(() => {
            const buttons = Array.from(document.querySelectorAll('button'));
            const acceptButton = buttons.find(btn => 
                /accept|consent/i.test(btn.innerText)
            );
            if (acceptButton) {
                acceptButton.click();
                console.log(`✅ Clicked cookie button: ${acceptButton.innerText}`);
                return true;
            }
            return false;
        });

        if (!accepted) console.log("⚠️ No consent button found.");
    } catch (error) {
        console.log("⚠️ No cookie popups detected.");
    }

    // Wait for cookies to be processed
    await new Promise(resolve => setTimeout(resolve, 4000));
    const totalHeight = await page.evaluate(() => document.body.scrollHeight);
    const viewportHeight = await page.viewport().height;
    let currentPosition = 0;
    let index = 0;

    while (currentPosition < totalHeight) {
        const screenshotPath = path.join(outputDir, `section_${index}.png`);
        
        
        await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
        // Wait 5 seconds for animations/loaders
        await page.screenshot({ path: screenshotPath, fullPage: false });
        
        console.log(`✅ Screenshot captured: ${screenshotPath}`);

        currentPosition += viewportHeight;
        await page.evaluate((scrollAmount) => window.scrollBy(0, scrollAmount), viewportHeight);
        await new Promise(resolve => setTimeout(resolve, 500));

        index++;
    }

    await browser.close();
    console.log('📸 Screenshot capture completed.');
};

app.listen(PORT, () => {
    console.log(`🚀 Server running at http://localhost:${PORT}`);
});




3

<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="index.css" />

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page screenshorter</title>

    <!-- Import map to resolve module specifiers -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
            "OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js"
        }
    }
    </script>
</head>
<body>

    <div>
    <button id="shuffleBtn">Shuffle</button>
    <button id="prevPage">Previous Page</button>
    <button id="nextPage">Next Page</button>
</div>

<form id="screenshotForm">
    <label for="url">Enter Website URL:</label>
    <input type="url" id="url" name="url" required>
    <button type="submit">Capture Webpages</button>
</form>
<div>
    <label for="radiusSlider">Adjust Radius:</label>
    <input type="range" id="radiusSlider" min="2" max="10" step="0.1" value="4">
    <span id="radiusValue">4.0</span>
</div>

<div>
    <label for="zoomSlider">Adjust Zoom:</label>
    <input type="range" id="zoomSlider" min="2" max="10" step="0.1" value="3">
    <span id="zoomValue">3.0</span>
</div>

    <script type="module">
const fetchScreenshots = async () => {
    try {
        const response = await fetch('http://localhost:3000/api/screenshots');
        const data = await response.json();
        console.log('Updated Screenshots:', data.screenshots);
    } catch (error) {
        console.error('Error fetching screenshots:', error);
    }
};

// Poll every 5 seconds
setInterval(fetchScreenshots, 5000);

const zoomSlider = document.getElementById('zoomSlider');
const zoomValue = document.getElementById('zoomValue');

zoomSlider.addEventListener('input', () => {
    const zoomLevel = parseFloat(zoomSlider.value);
    zoomValue.textContent = zoomLevel.toFixed(1);
    
    camera.position.z = zoomLevel; // Update camera zoom dynamically
    camera.updateProjectionMatrix(); // Apply changes

    console.log(`🔍 Zoom level updated: ${zoomLevel}`);
});



const radiusSlider = document.getElementById('radiusSlider');
const radiusValue = document.getElementById('radiusValue');

let radius = parseFloat(radiusSlider.value); // Initial radius

radiusSlider.addEventListener('input', () => {
    radius = parseFloat(radiusSlider.value);
    radiusValue.textContent = radius.toFixed(1);
    updateImagePositions(); // Update image positions dynamically
});

// Function to reposition images based on the new radius
const updateImagePositions = () => {
    const images = scene.children.filter(obj => obj instanceof THREE.Mesh);
    const angleIncrement = (2 * Math.PI) / images.length;

    images.forEach((mesh, index) => {
        const angle = index * angleIncrement;
        mesh.position.x = radius * Math.cos(angle);
        mesh.position.z = radius * Math.sin(angle);
        mesh.lookAt(0, 0, 0); // Ensure images face the center
    });

    console.log(`🔄 Updated radius: ${radius}`);
};


        document.getElementById('screenshotForm').addEventListener('submit', async (event) => {
            event.preventDefault();
            const url = document.getElementById('url').value;
            if (!url) {
                alert('Please enter a valid URL.');
                return;
            }

            try {
                const response = await fetch('http://localhost:3000/api/capture', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });
                const result = await response.json();
                alert(result.message);
                loadImages(); // Refresh the screenshot list
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to capture screenshot.');
            }
        });

     import * as THREE from 'three';
import { OrbitControls } from 'OrbitControls';

console.log('🚀 Three.js script loaded');

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 3;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio); // Ensure sharp rendering
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.maxDistance = 5;
controls.minDistance = 2;
console.log('🎮 OrbitControls initialized');

const textureLoader = new THREE.TextureLoader();

// Helper function to load texture asynchronously
const loadTexture = (filename) => {
    return new Promise((resolve, reject) => {
        const texturePath = `http://localhost:3000/screenshots/${filename}`;
        console.log(`🖼 Loading texture: ${texturePath}`);

        textureLoader.load(texturePath,
            (tex) => {
                console.log(`✅ Successfully loaded: ${filename}`);
                tex.minFilter = THREE.LinearFilter;  // Better quality scaling
                tex.magFilter = THREE.LinearFilter;
                tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                resolve(tex);
            },
            undefined,
            (err) => {
                console.error(`❌ Failed to load texture: ${filename}`, err);
                reject(err);
            }
        );
    });
};
(function() {
  let images = [];  // Array to keep track of all loaded images
  let removedImages = [];  // Array to track removed images

  // Function to load images into the scene
  const loadImages = async () => {
      try {
          const response = await fetch('http://localhost:3000/api/screenshots');
          const data = await response.json();

          if (!data.screenshots || data.screenshots.length === 0) {
              console.warn('⚠ No screenshots found');
              return;
          }

          data.screenshots.sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));

          const radius = 3.5; // Radius of the circular arrangement
          const angleIncrement = (2 * Math.PI) / data.screenshots.length; // Equal spacing for images

          let index = 0;
          for (const filename of data.screenshots) {
              try {
                  const texture = await loadTexture(filename);
                  const aspectRatio = texture.image.width / texture.image.height;
                  const planeHeight = window.innerHeight / 300;
                  const planeWidth = planeHeight * aspectRatio;

                  const angle = index * angleIncrement;
                  const x = radius * Math.cos(angle);
                  const z = radius * Math.sin(angle);

                  const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                  const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                  const mesh = new THREE.Mesh(geometry, material);
                  mesh.position.set(x, 0, z); // Place image in the circular arrangement
                  mesh.lookAt(0, 0, 0); // Make sure images face the center of the circle

                  // Create "Remove" button
                  const removeBtn = document.createElement('button');
                  removeBtn.textContent = 'Remove';
                  removeBtn.addEventListener('click', () => {
                      scene.remove(mesh);  // Remove image from the scene
                      removeBtn.style.display = 'none';  // Hide the "Remove" button

                      // Store the removed image data
                      removedImages.push({ mesh, filename });
                      console.log(`🗑️ Removed image: ${filename}`);

                      // Remove from the images array
                      images = images.filter(img => img.filename !== filename);

                      // Update positions of the remaining images
                      updateImagePositions();
                  });

                  // Append remove button to the body or somewhere near the image
                  document.body.appendChild(removeBtn);

                  scene.add(mesh);
                  images.push({ mesh, filename });  // Add image to the array
                  console.log(`🛠 Layer added: ${filename} at position (${x}, 0, ${z})`);
                  index++;
              } catch (error) {
                  console.warn(`⚠ Skipping texture: ${filename}`);
              }
          }
      } catch (error) {
          console.error('❌ Error fetching images:', error);
      }
  };

  // Function to update image positions based on the current array of images
  const updateImagePositions = () => {
      const remainingImages = scene.children.filter(obj => obj instanceof THREE.Mesh);
      const angleIncrement = (2 * Math.PI) / remainingImages.length;

      remainingImages.forEach((mesh, index) => {
          const angle = index * angleIncrement;
          mesh.position.x = 3.5 * Math.cos(angle); // Use fixed radius (can be dynamic as well)
          mesh.position.z = 3.5 * Math.sin(angle);
          mesh.lookAt(0, 0, 0); // Ensure images face the center
      });

      console.log(`🔄 Updated positions of images after removal`);
  };

  // Call this method to re-render the images after removing one
  loadImages();
})();


const animate = () => {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
};

console.log('🎬 Animation started');
animate();

// Handle window resizing
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    console.log('🔄 Window resized');
});

// Rotation controls (optional)
document.getElementById('shuffleBtn').addEventListener('click', () => {
    scene.rotation.y += Math.PI / 8; // Rotate the scene for a shuffle effect
});

document.getElementById('prevPage').addEventListener('click', () => {
    scene.rotation.y -= Math.PI / 8; // Rotate the scene left
});

document.getElementById('nextPage').addEventListener('click', () => {
    scene.rotation.y += Math.PI / 8; // Rotate the scene right
});

    </script>
    
    
</body>
</html>








<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="index.css" />

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page screenshorter</title>

    <!-- Import map to resolve module specifiers -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
            "OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js"
        }
    }
    </script>
</head>
<body>
<div style=" background-color: rgb(255, 255, 255);">
    <div>
    <button id="shuffleBtn">Shuffle</button>
    <button id="prevPage">Previous Page</button>
    <button id="nextPage">Next Page</button>
</div>

<form id="screenshotForm">
    <label for="url">Enter Website URL:</label>
    <input type="url" id="url" name="url" required>
    <button type="submit">Capture Webpages</button>
</form>
<button id="toggleRotateBtn">Toggle Rotation</button>

<div>
    <label for="radiusSlider">Adjust Radius:</label>
    <input type="range" id="radiusSlider" min="2" max="10" step="0.1" value="4">
    <span id="radiusValue">4.0</span>
</div>

<div>
    <label for="zoomSlider">Adjust Zoom:</label>
    <input type="range" id="zoomSlider" min="2" max="10" step="0.1" value="3">
    <span id="zoomValue">3.0</span>
</div>
<button id="downloadBtn">Download Rendered Image</button>
</div>

    <script type="module">

document.getElementById('downloadBtn').addEventListener('click', () => {
    // Temporarily set the renderer to 1920x1080 for higher quality capture
    const originalSize = { width: renderer.domElement.width, height: renderer.domElement.height };
    
    renderer.setSize(1920, 1080, false);
    renderer.setPixelRatio(window.devicePixelRatio); // Ensure sharp rendering
    renderer.render(scene, camera); // Ensure latest render
    
    const imgData = renderer.domElement.toDataURL('image/png'); // Convert to PNG format

    const link = document.createElement('a');
    link.href = imgData;
    link.download = 'rendered_image.png';
    link.click(); // Trigger download

    console.log('📸 Screenshot captured in Full HD and ready for download');

    // Restore original renderer size
    renderer.setSize(originalSize.width, originalSize.height, false);
});






const zoomSlider = document.getElementById('zoomSlider');
const zoomValue = document.getElementById('zoomValue');

zoomSlider.addEventListener('input', () => {
    const zoomLevel = parseFloat(zoomSlider.value);
    zoomValue.textContent = zoomLevel.toFixed(1);
    
    camera.position.z = zoomLevel; // Update camera zoom dynamically
    camera.updateProjectionMatrix(); // Apply changes

    console.log(`🔍 Zoom level updated: ${zoomLevel}`);
});



const radiusSlider = document.getElementById('radiusSlider');
const radiusValue = document.getElementById('radiusValue');

let radius = parseFloat(radiusSlider.value); // Initial radius

radiusSlider.addEventListener('input', () => {
    radius = parseFloat(radiusSlider.value);
    radiusValue.textContent = radius.toFixed(1);
    updateImagePositions(); // Update image positions dynamically
});

// Function to reposition images based on the new radius
const updateImagePositions = () => {
    const images = scene.children.filter(obj => obj instanceof THREE.Mesh);
    const angleIncrement = (2 * Math.PI) / images.length;

    images.forEach((mesh, index) => {
        const angle = index * angleIncrement;
        mesh.position.x = radius * Math.cos(angle);
        mesh.position.z = radius * Math.sin(angle);
        mesh.lookAt(0, 0, 0); // Ensure images face the center
    });

    console.log(`🔄 Updated radius: ${radius}`);
};


        document.getElementById('screenshotForm').addEventListener('submit', async (event) => {
            event.preventDefault();
            const url = document.getElementById('url').value;
            if (!url) {
                alert('Please enter a valid URL.');
                return;
            }

            try {
                const response = await fetch('http://localhost:3000/api/capture', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });
                const result = await response.json();
                alert(result.message);
                loadImages(); // Refresh the screenshot list
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to capture screenshot.');
            }
        });

     import * as THREE from 'three';
import { OrbitControls } from 'OrbitControls';

console.log('🚀 Three.js script loaded');

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 3;


const renderer = new THREE.WebGLRenderer({ 
    alpha: true,  // Keep transparency
    antialias: true,
    preserveDrawingBuffer: true // Ensures transparency when downloading
});

// Do not set a background color in WebGL (keeps transparency)
renderer.setClearColor(0x000000, 0);

// Ensure sharp rendering
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Apply black background using CSS
document.body.style.backgroundColor = "black";

renderer.setPixelRatio(window.devicePixelRatio); // High-quality rendering
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix(); // Prevent stretching
});


const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.maxDistance = 5;
controls.minDistance = 2;
console.log('🎮 OrbitControls initialized');

const textureLoader = new THREE.TextureLoader();

// Helper function to load texture asynchronously
const loadTexture = (filename) => {
    return new Promise((resolve, reject) => {
        const texturePath = `http://localhost:3000/screenshots/${filename}`;
        console.log(`🖼 Loading texture: ${texturePath}`);

        textureLoader.load(texturePath,
            (tex) => {
                console.log(`✅ Successfully loaded: ${filename}`);
                tex.minFilter = THREE.LinearFilter;  // Better quality scaling
                tex.magFilter = THREE.LinearFilter;
                tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                resolve(tex);
            },
            undefined,
            (err) => {
                console.error(`❌ Failed to load texture: ${filename}`, err);
                reject(err);
            }
        );
    });
};


(function() {
  let images = [];  
  let removedImages = [];  

  const loadImages = async () => {
      try {
          const response = await fetch('http://localhost:3000/api/screenshots');
          const data = await response.json();

          if (!data.screenshots || data.screenshots.length === 0) {
              console.warn('⚠ No screenshots found');
              return;
          }

          data.screenshots.sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));

          const radius = 3.5; 
          const angleIncrement = (2 * Math.PI) / data.screenshots.length; 

          let index = 0;
          for (const filename of data.screenshots) {
              try {
                  const texture = await loadTexture(filename);
                  const aspectRatio = texture.image.width / texture.image.height;
                  const planeHeight = window.innerHeight / 300;
                  const planeWidth = planeHeight * aspectRatio;

                  const angle = index * angleIncrement;
                  const x = radius * Math.cos(angle);
                  const z = radius * Math.sin(angle);

                  const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                  const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                  const mesh = new THREE.Mesh(geometry, material);
                  mesh.position.set(x, 0, z); 
                  mesh.lookAt(0, 0, 0); 

                  const removeBtn = document.createElement('button');
                  removeBtn.textContent = 'Remove';
                  removeBtn.addEventListener('click', () => {
                      scene.remove(mesh);  
                      removeBtn.style.display = 'none'; 

                      removedImages.push({ mesh, filename });
                      console.log(`🗑️ Removed image: ${filename}`);

                      
                      images = images.filter(img => img.filename !== filename);

                      // Update positions of the remaining images
                      updateImagePositions();
                  });

                  // Append remove button to the body or somewhere near the image
                  document.body.appendChild(removeBtn);

                  scene.add(mesh);
                  images.push({ mesh, filename });  // Add image to the array
                  console.log(`🛠 Layer added: ${filename} at position (${x}, 0, ${z})`);
                  index++;
              } catch (error) {
                  console.warn(`⚠ Skipping texture: ${filename}`);
              }
          }
      } catch (error) {
          console.error('❌ Error fetching images:', error);
      }
  };

  const updateImagePositions = () => {
      const remainingImages = scene.children.filter(obj => obj instanceof THREE.Mesh);
      const angleIncrement = (2 * Math.PI) / remainingImages.length;

      remainingImages.forEach((mesh, index) => {
          const angle = index * angleIncrement;
          mesh.position.x = 3.5 * Math.cos(angle); 
          mesh.position.z = 3.5 * Math.sin(angle);
          mesh.lookAt(0, 0, 0); 
      });

      console.log(`🔄 Updated positions of images after removal`);
  };

  loadImages();
})();


let autoRotate = false; // Initially set to manual rotation

// Function to toggle auto-rotation
document.getElementById('toggleRotateBtn').addEventListener('click', () => {
    autoRotate = !autoRotate;
    console.log(autoRotate ? '🔄 Auto-rotate enabled' : '🛑 Auto-rotate disabled');
});

// Update the animate function
const animate = () => {
    requestAnimationFrame(animate);

    if (autoRotate) {
        scene.rotation.y += 0.002; // Rotate when auto mode is on
    }

    controls.update();
    renderer.render(scene, camera);
};

console.log('🎬 Animation started');
animate();



console.log('🎬 Animation started');
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    console.log('🔄 Window resized');
});

document.getElementById('shuffleBtn').addEventListener('click', () => {
    scene.rotation.y += Math.PI / 8;
});

document.getElementById('prevPage').addEventListener('click', () => {
    scene.rotation.y -= Math.PI / 8; 
});

document.getElementById('nextPage').addEventListener('click', () => {
    scene.rotation.y += Math.PI / 8; 
});

    </script>
    
    
</body>
</html>








HTML 3D WITH 4D


<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="index.css" />

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page screenshorter</title>

    <!-- Import map to resolve module specifiers -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
            "OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js"
        }
    }
    </script>
</head>
<body>
<div style=" background-color: rgb(255, 255, 255);">
    <div>
    <button id="shuffleBtn">Shuffle</button>
    <button id="prevPage">Previous Page</button>
    <button id="nextPage">Next Page</button>
</div>

<form id="screenshotForm">
    <label for="url">Enter Website URL:</label>
    <input type="url" id="url" name="url" required>
    <button type="submit">Capture Webpages</button>
</form>
<button id="toggleRotateBtn">Toggle Rotation</button>

<div>
    <label for="radiusSlider">Adjust Radius:</label>
    <input type="range" id="radiusSlider" min="2" max="10" step="0.1" value="4">
    <span id="radiusValue">4.0</span>
</div>

<div>
    <label for="zoomSlider">Adjust Zoom:</label>
    <input type="range" id="zoomSlider" min="2" max="10" step="0.1" value="3">
    <span id="zoomValue">3.0</span>
</div>
<button id="downloadBtn">Download Rendered Image</button>
</div>

    <script type="module">

document.getElementById('downloadBtn').addEventListener('click', () => {
    // Temporarily set the renderer to 1920x1080 for higher quality capture
    const originalSize = { width: renderer.domElement.width, height: renderer.domElement.height };
    
    renderer.setSize(1920, 1080, false);
    renderer.setPixelRatio(window.devicePixelRatio); // Ensure sharp rendering
    renderer.render(scene, camera); // Ensure latest render
    
    const imgData = renderer.domElement.toDataURL('image/png'); // Convert to PNG format

    const link = document.createElement('a');
    link.href = imgData;
    link.download = 'rendered_image.png';
    link.click(); // Trigger download

    console.log('📸 Screenshot captured in Full HD and ready for download');

    // Restore original renderer size
    renderer.setSize(originalSize.width, originalSize.height, false);
});






const zoomSlider = document.getElementById('zoomSlider');
const zoomValue = document.getElementById('zoomValue');

zoomSlider.addEventListener('input', () => {
    const zoomLevel = parseFloat(zoomSlider.value);
    zoomValue.textContent = zoomLevel.toFixed(1);
    
    camera.position.z = zoomLevel; // Update camera zoom dynamically
    camera.updateProjectionMatrix(); // Apply changes

    console.log(`🔍 Zoom level updated: ${zoomLevel}`);
});



const radiusSlider = document.getElementById('radiusSlider');
const radiusValue = document.getElementById('radiusValue');

let radius = parseFloat(radiusSlider.value); // Initial radius

radiusSlider.addEventListener('input', () => {
    radius = parseFloat(radiusSlider.value);
    radiusValue.textContent = radius.toFixed(1);
    updateImagePositions(); // Update image positions dynamically
});

// Function to reposition images based on the new radius
const updateImagePositions = () => {
    const images = scene.children.filter(obj => obj instanceof THREE.Mesh);
    const angleIncrement = (2 * Math.PI) / images.length;

    images.forEach((mesh, index) => {
        const angle = index * angleIncrement;
        mesh.position.x = radius * Math.cos(angle);
        mesh.position.z = radius * Math.sin(angle);
        mesh.lookAt(0, 0, 0); // Ensure images face the center
    });

    console.log(`🔄 Updated radius: ${radius}`);
};


        document.getElementById('screenshotForm').addEventListener('submit', async (event) => {
            event.preventDefault();
            const url = document.getElementById('url').value;
            if (!url) {
                alert('Please enter a valid URL.');
                return;
            }

            try {
                const response = await fetch('http://localhost:3000/api/capture', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });
                const result = await response.json();
                alert(result.message);
                loadImages(); // Refresh the screenshot list
            } catch (error) {
                console.error('Error:', error);
                alert('Failed to capture screenshot.');
            }
        });

     import * as THREE from 'three';
import { OrbitControls } from 'OrbitControls';

console.log('🚀 Three.js script loaded');

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 3;


const renderer = new THREE.WebGLRenderer({ 
    alpha: true,  // Keep transparency
    antialias: true,
    preserveDrawingBuffer: true // Ensures transparency when downloading
});

// Do not set a background color in WebGL (keeps transparency)
renderer.setClearColor(0x000000, 0);

// Ensure sharp rendering
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Apply black background using CSS
document.body.style.backgroundColor = "black";

renderer.setPixelRatio(window.devicePixelRatio); // High-quality rendering
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix(); // Prevent stretching
});


const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.maxDistance = 5;
controls.minDistance = 2;
console.log('🎮 OrbitControls initialized');

const textureLoader = new THREE.TextureLoader();

// Helper function to load texture asynchronously
const loadTexture = (filename) => {
    return new Promise((resolve, reject) => {
        const texturePath = `http://localhost:3000/screenshots/${filename}`;
        console.log(`🖼 Loading texture: ${texturePath}`);

        textureLoader.load(texturePath,
            (tex) => {
                console.log(`✅ Successfully loaded: ${filename}`);
                tex.minFilter = THREE.LinearFilter;  // Better quality scaling
                tex.magFilter = THREE.LinearFilter;
                tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                resolve(tex);
            },
            undefined,
            (err) => {
                console.error(`❌ Failed to load texture: ${filename}`, err);
                reject(err);
            }
        );
    });
};

const placeScreenshotsInCircle = async (screenshots) => {
    if (screenshots.length === 0) {
        console.warn("⚠ No screenshots to display.");
        return;
    }

    const radius = 3.5; // Distance from center
    const angleIncrement = (2 * Math.PI) / screenshots.length; 

    let index = 0;
    for (const filename of screenshots) {
        try {
            const texture = await loadTexture(filename);
            const aspectRatio = texture.image.width / texture.image.height;
            const planeHeight = window.innerHeight / 300;
            const planeWidth = planeHeight * aspectRatio;

            const angle = index * angleIncrement;
            const x = radius * Math.cos(angle);
            const z = radius * Math.sin(angle);

            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, 0, z); 
            mesh.lookAt(0, 0, 0); 

            scene.add(mesh);
            index++;
        } catch (error) {
            console.warn(`⚠ Skipping texture: ${filename}`);
        }
    }
};


(function() {
  let images = [];  
  let removedImages = [];  

  const loadImages = async () => {
    try {
        const response = await fetch('http://localhost:3000/api/screenshots');
        const data = await response.json();

        if (!data.screenshots || data.screenshots.length === 0) {
            console.warn('⚠ No screenshots found');
            return;
        }

        data.screenshots.sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));

        // 🛠 Place screenshots in a circle (original method)
        placeScreenshotsInCircle(data.screenshots);

        // 🚀 Apply screenshots to tesseract
        createTexturedTesseract(data.screenshots);

    } catch (error) {
        console.error('❌ Error fetching images:', error);
    }
};


  const updateImagePositions = () => {
      const remainingImages = scene.children.filter(obj => obj instanceof THREE.Mesh);
      const angleIncrement = (2 * Math.PI) / remainingImages.length;

      remainingImages.forEach((mesh, index) => {
          const angle = index * angleIncrement;
          mesh.position.x = 3.5 * Math.cos(angle); 
          mesh.position.z = 3.5 * Math.sin(angle);
          mesh.lookAt(0, 0, 0); 
      });

      console.log(`🔄 Updated positions of images after removal`);
  };

  loadImages();
})();


let points4D = [
    [-1, -1, -1, -1], [1, -1, -1, -1], [1, 1, -1, -1], [-1, 1, -1, -1], 
    [-1, -1,  1, -1], [1, -1,  1, -1], [1, 1,  1, -1], [-1, 1,  1, -1], 
    [-1, -1, -1,  1], [1, -1, -1,  1], [1, 1, -1,  1], [-1, 1, -1,  1], 
    [-1, -1,  1,  1], [1, -1,  1,  1], [1, 1,  1,  1], [-1, 1,  1,  1]  
];

const rotate4D = (point, angle) => {
    let [x, y, z, w] = point;
    let cosA = Math.cos(angle);
    let sinA = Math.sin(angle);

    let newX = cosA * x - sinA * w;
    let newW = sinA * x + cosA * w;

    return [newX, y, z, newW];
};

const project4Dto3D = (point) => {
    let [x, y, z, w] = point;
    let d = 2;  

    let scale = d / (d - w);
    return [x * scale, y * scale, z * scale];
};

const geometry = new THREE.BufferGeometry();
const material = new THREE.LineBasicMaterial({ color: 0xffffff });
const tesseract = new THREE.LineSegments(geometry, material);
scene.add(tesseract);

let autoRotate = false; // Initially set to manual rotation

// Function to toggle auto-rotation
document.getElementById('toggleRotateBtn').addEventListener('click', () => {
    autoRotate = !autoRotate;
    console.log(autoRotate ? '🔄 Auto-rotate enabled' : '🛑 Auto-rotate disabled');
});


const createTexturedTesseract = async (screenshots) => {
    if (screenshots.length < 6) {
        console.warn("⚠ Not enough screenshots to texture a 3D cube");
        return;
    }

    const materials = await Promise.all(
        screenshots.slice(0, 6).map(async (filename) => {
            try {
                const texture = await loadTexture(filename);
                return new THREE.MeshBasicMaterial({ map: texture, transparent: true });
            } catch (error) {
                console.warn(`⚠ Skipping texture: ${filename}`);
                return new THREE.MeshBasicMaterial({ color: 0x222222 }); // Default gray
            }
        })
    );

    const cubeGeometry = new THREE.BoxGeometry(1, 1, 1); // 3D Cube from 4D projection
    const cubeMesh = new THREE.Mesh(cubeGeometry, materials);

    scene.add(cubeMesh);
};

// Update the animate function
let isRotating = true; // Rotation flag (initially enabled)

const animate = () => {
    requestAnimationFrame(animate);

    // Toggle rotation based on the flag
    scene.children.forEach(obj => {
        if (obj instanceof THREE.Mesh && obj.geometry instanceof THREE.BoxGeometry) {
            if (isRotating) {
                obj.rotation.y += 0.01; // Rotate the cube with screenshots
                obj.rotation.x += 0.01;
            }
        }
    });

    controls.update();
    renderer.render(scene, camera);
};

// Set up the button to toggle rotation
document.getElementById('toggleRotateBtn').addEventListener('click', () => {
    isRotating = !isRotating; // Toggle the rotation state
    console.log(isRotating ? "Rotation enabled" : "Rotation disabled");
});

animate();


console.log('🎬 Animation started');
animate();



console.log('🎬 Animation started');
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    console.log('🔄 Window resized');
});

document.getElementById('shuffleBtn').addEventListener('click', () => {
    scene.rotation.y += Math.PI / 8;
});

document.getElementById('prevPage').addEventListener('click', () => {
    scene.rotation.y -= Math.PI / 8; 
});

document.getElementById('nextPage').addEventListener('click', () => {
    scene.rotation.y += Math.PI / 8; 
});

    </script>
    
    
</body>
</html>














import * as THREE from "three";
import { OrbitControls } from "OrbitControls";
import { RGBELoader } from "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/RGBELoader.js";

class ThreeJSApp {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 0, 3);

        this.renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true,
            preserveDrawingBuffer: true
        });
        this.renderer.setClearColor(0x000000, 0.2);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);
        document.body.style.backgroundColor = "#0f0f1a";

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enableZoom = true;
        this.controls.minDistance = 0.1;
        this.controls.maxDistance = 10;
        this.controls.enablePan = false;
        this.controls.autoRotate = false;
        this.controls.autoRotateSpeed = 1.0;

        this.images = [];
        this.radius = 5;
        this.sessionId = localStorage.getItem('sessionId');
        this.textureLoader = new THREE.TextureLoader();
        this.rgbeLoader = new RGBELoader(); // For HDR files

        // Audio setup
        this.audioListener = new THREE.AudioListener();
        this.camera.add(this.audioListener);
        this.backgroundAudio = new THREE.Audio(this.audioListener);
        this.clickSound = new THREE.Audio(this.audioListener);
        this.shuffleSound = new THREE.Audio(this.audioListener);

        this.recording = {
            mediaRecorder: null,
            chunks: [],
            isRecording: false,
            blob: null,
            url: null
        };
        this.isRemoveActive = false;
        this.is360View = false;
        this.controlsVisible = true;

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.selectedMesh = null;
        this.focusedMesh = null;

        this.addLighting();
        this.addBackgroundEnvironment();
        this.setupAudio();
    }

    addLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0x00d4ff, 1, 10);
        pointLight.position.set(0, 0, 0);
        this.scene.add(pointLight);
    }

    addBackgroundEnvironment() {
        // Default HDR environment map
        this.loadHDRMap('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/kloppenheim_06_1k.hdr'); // Example HDR from Poly Haven
    }

    loadHDRMap(url) {
        this.rgbeLoader.load(
            url,
            (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                this.scene.background = texture;
                // Optionally use as environment for lighting
                this.scene.environment = texture;
                console.log("🌌 HDR environment map loaded from:", url);
            },
            undefined,
            (err) => console.error("❌ Error loading HDR environment map:", err)
        );
    }

    setupAudio() {
        // Placeholder audio setup (replace paths with your files)
        this.textureLoader.manager.onLoad = () => {
            this.backgroundAudio.setBuffer(this.loadAudio('path/to/ambient-background.mp3'));
            this.backgroundAudio.setLoop(true);
            this.backgroundAudio.setVolume(0.3);
            this.backgroundAudio.play();
            console.log("🎶 Background audio started");
        };
        this.clickSound.setBuffer(this.loadAudio('path/to/click-sound.mp3'));
        this.clickSound.setVolume(0.5);
        this.shuffleSound.setBuffer(this.loadAudio('path/to/shuffle-sound.mp3'));
        this.shuffleSound.setVolume(0.5);
    }

    loadAudio(url) {
        const audioLoader = new THREE.AudioLoader();
        let buffer;
        audioLoader.load(url, (audioBuffer) => {
            buffer = audioBuffer;
        });
        return buffer;
    }

    init() {
        console.log("🚀 Three.js script loaded");
        this.setupEventListeners();
        if (this.sessionId) {
            this.loadImages(this.sessionId);
        }
        this.animate();
        window.addEventListener("resize", () => this.handleResize());
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        if (this.controls.autoRotate) {
            this.controls.update();
        } else if (!this.is360View && this.autoRotate) {
            this.scene.rotation.y += 0.005;
        }
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }

    setupEventListeners() {
        document.getElementById("downloadBtn").addEventListener("click", () => this.handleDownload());
        document.getElementById("zoomSlider").addEventListener("input", () => this.handleZoom());
        document.getElementById("radiusSlider").addEventListener("input", () => this.handleRadius());
        document.getElementById("screenshotForm").addEventListener("submit", (e) => this.handleScreenshotSubmit(e));
        document.getElementById("uploadForm").addEventListener("submit", (e) => this.handleUploadSubmit(e));
        document.getElementById("startRecordingBtn").addEventListener("click", () => this.startRecording());
        document.getElementById("stopRecordingBtn").addEventListener("click", () => this.stopRecording());
        document.getElementById("toggleRotateBtn").addEventListener("click", () => this.toggleRotate());
        document.getElementById("shuffleBtn").addEventListener("click", () => this.shuffleImages());
        document.getElementById("prevPage").addEventListener("click", () => this.rotateScene(-Math.PI / 8));
        document.getElementById("nextPage").addEventListener("click", () => this.rotateScene(Math.PI / 8));
        document.getElementById("toggleViewBtn").addEventListener("click", () => this.toggleViewMode());
        document.getElementById("toggleControlsBtn").addEventListener("click", () => this.toggleControls());

        this.renderer.domElement.addEventListener("click", (event) => this.onCanvasClick(event));
        this.renderer.domElement.addEventListener("dblclick", (event) => this.onDoubleClick(event));
        this.renderer.domElement.addEventListener("mousemove", (event) => this.onMouseMove(event));
        this.renderer.domElement.addEventListener("touchstart", (event) => this.onTouchStart(event));
        this.renderer.domElement.addEventListener("touchmove", (event) => this.onTouchMove(event));

        document.getElementById("toggleRemoveBtn").addEventListener("click", () => this.toggleRemove());
        document.getElementById("removeBtn").addEventListener("click", () => this.removeSelectedImage());
        document.getElementById("removeAllBtn").addEventListener("click", () => this.removeAllImages());

        document.getElementById("images").addEventListener("change", (event) => this.showImagePreviews(event));
        document.getElementById("envMapInput").addEventListener("change", (event) => this.handleEnvMapUpload(event));
    }

    handleEnvMapUpload(event) {
        const file = event.target.files[0];
        if (file) {
            const fileExt = file.name.split('.').pop().toLowerCase();
            if (fileExt === 'hdr') {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const arrayBuffer = e.target.result;
                    this.rgbeLoader.parse(arrayBuffer, (texture) => {
                        texture.mapping = THREE.EquirectangularReflectionMapping;
                        this.scene.background = texture;
                        this.scene.environment = texture; // Optional: use for lighting
                        console.log("🌌 User uploaded HDR environment map:", file.name);
                    });
                };
                reader.readAsArrayBuffer(file); // HDR files need ArrayBuffer
            } else if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    this.loadHDRMap(e.target.result); // Fallback to standard texture for non-HDR images
                };
                reader.readAsDataURL(file);
            } else {
                this.showMessage("toggleViewStatus", "Invalid file type. Please upload an HDR or image file.", "error");
            }
        }
    }

    toggleControls() {
        this.controlsVisible = !this.controlsVisible;
        const controlPanels = document.querySelectorAll(".control-panel");
        const toggleButton = document.getElementById("toggleControlsBtn");

        controlPanels.forEach(panel => {
            panel.classList.toggle("hidden-panel", !this.controlsVisible);
        });

        toggleButton.textContent = this.controlsVisible ? "Hide Controls" : "Show Controls";
        toggleButton.querySelector("i").className = this.controlsVisible ? "fas fa-eye" : "fas fa-eye-slash";
        console.log(this.controlsVisible ? "🖥️ Controls visible" : "🖥️ Controls hidden");
    }

    onMouseMove(event) {
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    onTouchStart(event) {
        const touch = event.touches[0];
        this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        this.onCanvasClick(event);
    }

    onTouchMove(event) {
        event.preventDefault();
        const touch = event.touches[0];
        this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        this.scene.rotation.y += (touch.clientX - this.lastTouchX) * 0.005;
        this.lastTouchX = touch.clientX;
    }

    onDoubleClick(event) {
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.scene.children, true);

        if (intersects.length > 0) {
            const intersectedObject = intersects[0].object;
            if (intersectedObject.userData.filename) {
                if (this.focusedMesh === intersectedObject) {
                    this.focusedMesh.scale.set(1, 1, 1);
                    this.focusedMesh.material.uniforms.opacity.value = 1;
                    this.focusedMesh = null;
                    this.images.forEach(img => {
                        img.mesh.material.uniforms.opacity.value = 1;
                    });
                    this.showMessage("toggleViewStatus", "View reset", "success");
                } else {
                    if (this.focusedMesh) {
                        this.focusedMesh.scale.set(1, 1, 1);
                        this.focusedMesh.material.uniforms.opacity.value = 1;
                    }

                    this.focusedMesh = intersectedObject;
                    this.focusedMesh.scale.set(2, 2, 2);
                    this.focusedMesh.material.uniforms.opacity.value = 1;

                    this.images.forEach(img => {
                        if (img.mesh !== this.focusedMesh) {
                            img.mesh.material.uniforms.opacity.value = 0.3;
                        }
                    });
                    this.showMessage("toggleViewStatus", "Image focused", "success");
                }
            }
        } else if (this.focusedMesh) {
            this.focusedMesh.scale.set(1, 1, 1);
            this.focusedMesh.material.uniforms.opacity.value = 1;
            this.focusedMesh = null;
            this.images.forEach(img => {
                img.mesh.material.uniforms.opacity.value = 1;
            });
            this.showMessage("toggleViewStatus", "View reset", "success");
        }
    }

    onCanvasClick(event) {
        if (!this.isRemoveActive) return;

        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.scene.children, true);

        if (intersects.length > 0) {
            const intersectedObject = intersects[0].object;
            if (intersectedObject.userData.onClick) {
                this.selectedMesh = intersectedObject;
                this.showRemoveButton(intersectedObject);
                if (!this.clickSound.isPlaying) {
                    this.clickSound.play();
                }
            }
        }
    }

    toggleRemove() {
        this.showStatus("toggleRemoveStatus", true);
        this.isRemoveActive = !this.isRemoveActive;
        const removeControls = document.getElementById("removeControls");
        setTimeout(() => {
            removeControls.classList.toggle("hidden", !this.isRemoveActive);
            this.showMessage("toggleRemoveStatus", this.isRemoveActive ? "Remove mode enabled" : "Remove mode disabled", "success");
            this.showStatus("toggleRemoveStatus", false);
        }, 500);
    }

    hideAllRemoveButtons() {
        const removeButtons = document.querySelectorAll("button[style*='Remove']");
        removeButtons.forEach(btn => btn.remove());
        this.images.forEach(img => {
            img.mesh.userData.buttonCreated = false;
        });
    }

    removeSelectedImage() {
        if (this.selectedMesh) {
            this.showStatus("removeSelectedStatus", true);
            this.removeImage(this.selectedMesh);
            this.hideAllRemoveButtons();
            this.selectedMesh = null;
            this.showMessage("removeSelectedStatus", "Image removed", "success");
            this.showStatus("removeSelectedStatus", false);
        } else {
            this.showMessage("removeSelectedStatus", "No image selected for removal", "error");
        }
    }

    removeAllImages() {
        this.showStatus("removeAllStatus", true);
        while (this.scene.children.length > 2) {
            const child = this.scene.children[2];
            this.scene.remove(child);
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        }
        this.images = [];
        console.log("🗑️ All images removed");
        this.showMessage("removeAllStatus", "All images removed", "success");
        this.showStatus("removeAllStatus", false);
    }

    toggleViewMode() {
        this.showStatus("toggleViewStatus", true);
        this.is360View = !this.is360View;
        console.log(this.is360View ? "🔄 Switched to 360-degree view" : "🔄 Switched to 3D view");

        if (this.is360View) {
            this.camera.position.set(0, 0, 0);
            this.controls.maxDistance = 10;
            this.controls.minDistance = 0.1;
            this.controls.enablePan = false;
        } else {
            this.camera.position.set(0, 0, 3);
            this.controls.maxDistance = 5;
            this.controls.minDistance = 2;
            this.controls.enablePan = false;
        }
        this.camera.updateProjectionMatrix();
        this.updateImagePositions();
        this.showMessage("toggleViewStatus", this.is360View ? "Switched to 360 view" : "Switched to 3D view", "success");
        this.showStatus("toggleViewStatus", false);
    }

    async loadImages(sessionId) {
        this.clearScene();
        
        try {
            this.showStatus("toggleViewStatus", true);
            const response = await fetch(`http://localhost:3000/api/screenshots/${sessionId}/`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            if (!data.screenshots?.length) {
                this.showMessage("toggleViewStatus", "No screenshots found", "error");
                return;
            }

            data.screenshots.sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
            this.imagesToLoad = data.screenshots;
            this.updateImagePositions();
            this.showMessage("toggleViewStatus", "Images loaded successfully", "success");
        } catch (error) {
            console.error("❌ Error fetching images:", error);
            this.showMessage("toggleViewStatus", `Failed to load images: ${error.message}`, "error");
        } finally {
            this.showStatus("toggleViewStatus", false);
        }
    }

    clearScene() {
        while (this.scene.children.length > 2) {
            const child = this.scene.children[2];
            this.scene.remove(child);
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        }
        this.images = [];
        console.log("🗑️ Scene cleared");
    }

    async addImage(filename, theta, phiOrIndex) {
        try {
            const texture = await this.loadTexture(filename);
            const aspectRatio = texture.image.width / texture.image.height;
            const planeHeight = this.is360View ? 1.5 : window.innerHeight / 300;
            const planeWidth = planeHeight * aspectRatio;

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    map: { value: texture },
                    opacity: { value: 1.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D map;
                    uniform float opacity;
                    varying vec2 vUv;
                    void main() {
                        vec4 tex = texture2D(map, vUv);
                        if (!gl_FrontFacing) {
                            tex = texture2D(map, vec2(1.0 - vUv.x, vUv.y));
                        }
                        gl_FragColor = vec4(tex.rgb, tex.a * opacity);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });

            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const mesh = new THREE.Mesh(geometry, material);

            if (this.is360View) {
                const x = this.radius * Math.sin(phiOrIndex) * Math.cos(theta);
                const y = this.radius * Math.cos(phiOrIndex);
                const z = this.radius * Math.sin(phiOrIndex) * Math.sin(theta);
                mesh.position.set(x, y, z);
            } else {
                const angle = theta;
                const x = this.radius * Math.cos(angle);
                const z = this.radius * Math.sin(angle);
                mesh.position.set(x, 0, z);
            }
            mesh.lookAt(0, 0, 0);
            mesh.userData = { filename, buttonCreated: false };
            mesh.userData.onClick = () => this.showRemoveButton(mesh);

            this.scene.add(mesh);
            this.images.push({ mesh, filename });

            console.log(`🛠 Layer added: ${filename} at position (${mesh.position.x}, ${mesh.position.y}, ${mesh.position.z})`);
        } catch (error) {
            console.warn(`⚠ Skipping texture: ${filename}`, error);
        }
    }

    loadTexture(filename) {
        return new Promise((resolve, reject) => {
            this.textureLoader.load(
                filename,
                (texture) => {
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
                    resolve(texture);
                },
                undefined,
                (err) => reject(err)
            );
        });
    }

    updateImagePositions() {
        this.clearScene();

        if (!this.imagesToLoad || this.imagesToLoad.length === 0) return;

        const totalImages = this.imagesToLoad.length;
        const goldenRatio = (Math.sqrt(5) + 1) / 2;

        if (this.is360View) {
            for (let index = 0; index < totalImages; index++) {
                const y = 1 - (index / (totalImages - 1)) * 2;
                const radiusAtY = Math.sqrt(1 - y * y);
                const theta = goldenRatio * index * Math.PI * 2;
                const phi = Math.acos(y);
                this.addImage(this.imagesToLoad[index], theta, phi);
            }
        } else {
            const angleIncrement = (2 * Math.PI) / totalImages;
            for (let index = 0; index < totalImages; index++) {
                const angle = index * angleIncrement;
                this.addImage(this.imagesToLoad[index], angle, angleIncrement);
            }
        }
    }

    shuffleImages() {
        if (this.images.length === 0) {
            this.showMessage("shuffleStatus", "No images to shuffle", "error");
            return;
        }

        this.showStatus("shuffleStatus", true);
        this.images = this.images.sort(() => Math.random() - 0.5);
        this.imagesToLoad = this.images.map(img => img.mesh.userData.filename);
        this.updateImagePositions();
        if (!this.shuffleSound.isPlaying) {
            this.shuffleSound.play();
        }
        this.showMessage("shuffleStatus", "Images shuffled successfully", "success");
        this.showStatus("shuffleStatus", false);
    }

    removeImage(mesh) {
        this.scene.remove(mesh);
        this.images = this.images.filter(img => img.mesh !== mesh);
        this.imagesToLoad = this.images.map(img => img.mesh.userData.filename);
        console.log(`🗑️ Removed image: ${mesh.userData.filename}`);
        this.updateImagePositions();
    }

    showRemoveButton(mesh) {
        if (!this.isRemoveActive || mesh.userData.buttonCreated) return;

        const removeBtn = document.createElement("button");
        removeBtn.textContent = "Remove";
        removeBtn.style.cssText = `
            position: absolute;
            z-index: 1000;
            padding: 8px 12px;
            background: rgba(220, 53, 69, 0.8);
            color: #fff;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.8rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s ease;
        `;
        document.body.appendChild(removeBtn);

        const updateButtonPosition = () => {
            const screenPos = new THREE.Vector3();
            mesh.getWorldPosition(screenPos);
            screenPos.project(this.camera);

            const xPos = (screenPos.x + 1) / 2 * window.innerWidth;
            const yPos = (1 - screenPos.y) / 2 * window.innerHeight;

            removeBtn.style.left = `${xPos}px`;
            removeBtn.style.top = `${yPos - 30}px`;
            removeBtn.style.display = "block";
        };

        updateButtonPosition();

        const updateLoop = () => {
            if (this.isRemoveActive) {
                updateButtonPosition();
            } else {
                removeBtn.remove();
                mesh.userData.buttonCreated = false;
                return;
            }
            requestAnimationFrame(updateLoop);
        };
        updateLoop();

        removeBtn.addEventListener("click", () => {
            this.removeImage(mesh);
            removeBtn.remove();
            mesh.userData.buttonCreated = false;
        });

        removeBtn.addEventListener("mouseover", () => {
            removeBtn.style.opacity = "0.8";
            removeBtn.style.transform = "scale(1.05)";
        });
        removeBtn.addEventListener("mouseout", () => {
            removeBtn.style.opacity = "1";
            removeBtn.style.transform = "scale(1)";
        });

        mesh.userData.buttonCreated = true;
    }

    handleDownload() {
        this.showStatus("downloadStatus", true);
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        const highResWidth = Math.max(screenWidth * 2, 1920);
        const highResHeight = Math.max(screenHeight * 2, 1080);

        const originalSize = { width: this.renderer.domElement.width, height: this.renderer.domElement.height };
        this.renderer.setSize(highResWidth, highResHeight, false);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.render(this.scene, this.camera);

        const imgData = this.renderer.domElement.toDataURL("image/png", 1.0);

        this.renderer.setSize(originalSize.width, originalSize.height, false);
        this.renderer.render(this.scene, this.camera);

        this.downloadFile(imgData, "rendered_high_res_image.png");
        this.showMessage("downloadStatus", "Image downloaded successfully", "success");
        this.showStatus("downloadStatus", false);
    }

    handleZoom() {
        const zoomSlider = document.getElementById("zoomSlider");
        const zoomValue = document.getElementById("zoomValue");
        const zoomLevel = parseFloat(zoomSlider.value);
        zoomValue.textContent = zoomLevel.toFixed(1);
        this.controls.maxDistance = zoomLevel;
        this.controls.update();
        if (!this.is360View) {
            this.camera.position.z = zoomLevel;
            this.camera.updateProjectionMatrix();
        }
        console.log(`🔍 Zoom level updated: ${zoomLevel}`);
    }

    handleRadius() {
        const radiusSlider = document.getElementById("radiusSlider");
        const radiusValue = document.getElementById("radiusValue");
        this.radius = parseFloat(radiusSlider.value);
        radiusValue.textContent = this.radius.toFixed(1);
        this.updateImagePositions();
    }

    async handleScreenshotSubmit(event) {
        event.preventDefault();
        const url = document.getElementById("url").value;
        if (!url) {
            this.showMessage("screenshotStatus", "Please enter a valid URL", "error");
            return;
        }

        this.showStatus("screenshotStatus", true);

        try {
            const response = await fetch("http://localhost:3000/api/capture", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url })
            });
            
            const result = await response.json();
            if (result.sessionId) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.showMessage("screenshotStatus", `Screenshots captured for ${url}`, "success");
                this.loadImages(this.sessionId);
            } else {
                this.showMessage("screenshotStatus", "Failed to capture screenshot", "error");
            }
        } catch (error) {
            console.error("Error:", error);
            this.showMessage("screenshotStatus", `Failed to capture screenshot: ${error.message}`, "error");
        } finally {
            this.showStatus("screenshotStatus", false);
        }
    }

    async handleUploadSubmit(event) {
        event.preventDefault();
        const sessionId = this.sessionId || null;
        const fileInput = document.getElementById("images");
        if (!fileInput.files?.length) {
            this.showMessage("uploadStatus", "Please select at least one image to upload", "error");
            return;
        }

        this.showStatus("uploadStatus", true);

        const formData = new FormData();
        for (const file of fileInput.files) {
            formData.append("images", file);
        }

        try {
            const response = await fetch(`http://localhost:3000/api/upload${sessionId ? `/${sessionId}` : ''}`, {
                method: "POST",
                body: formData
            });
            
            const result = await response.json();
            if (result.success) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.showMessage("uploadStatus", `Uploaded ${result.filePaths.length} images successfully`, "success");
                this.loadImages(this.sessionId);
            } else {
                this.showMessage("uploadStatus", `Upload failed: ${result.error || "Unknown error"}`, "error");
            }
        } catch (error) {
            console.error("Error uploading files:", error);
            this.showMessage("uploadStatus", `Failed to upload images: ${error.message}`, "error");
        } finally {
            this.showStatus("uploadStatus", false);
        }
    }

    showImagePreviews(event) {
        const files = event.target.files;
        const previewContainer = document.getElementById("previewContainer");
        previewContainer.innerHTML = "";

        for (const file of files) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = document.createElement("img");
                img.src = e.target.result;
                img.classList.add("preview-thumbnail");
                img.addEventListener("click", () => {
                    console.log(`Clicked preview for ${file.name}`);
                });
                previewContainer.appendChild(img);
            };
            reader.readAsDataURL(file);
        }
    }

    startRecording() {
        if (this.recording.isRecording) {
            this.showMessage("startRecordingStatus", "Recording already in progress", "error");
            return;
        }
    
        this.showStatus("startRecordingStatus", true);
        this.recording.chunks = [];
        this.renderer.setSize(1920, 1080);
        const stream = this.renderer.domElement.captureStream(30);
    
        try {
            this.recording.mediaRecorder = new MediaRecorder(stream, { mimeType: "video/mp4" });
            this.setupRecorder("mp4", "360-video.mp4");
        } catch (e) {
            console.error("MP4 recording failed, switching to WebM.", e);
            this.recording.mediaRecorder = new MediaRecorder(stream, { mimeType: "video/webm" });
            this.setupRecorder("webm", "360-video.webm");
        }
    
        const indicator = document.getElementById("recordingIndicator");
        indicator.classList.remove("hidden");
        indicator.textContent = "Recording... (2 minutes remaining)";
    
        let timeLeft = 120;
        this.recordingTimer = setInterval(() => {
            timeLeft--;
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            indicator.textContent = `Recording... (${minutes}:${seconds < 10 ? '0' : ''}${seconds} remaining)`;
            if (timeLeft <= 0) {
                clearInterval(this.recordingTimer);
                this.stopRecording();
            }
        }, 1000);
        this.showMessage("startRecordingStatus", "Recording started", "success");
        this.showStatus("startRecordingStatus", false);
    }
    
    setupRecorder(type, filename) {
        this.recording.mediaRecorder.ondataavailable = (event) => {
            this.recording.chunks.push(event.data);
        };

        this.recording.mediaRecorder.onstop = () => {
            this.recording.blob = new Blob(this.recording.chunks, { type: `video/${type}` });
            this.recording.url = URL.createObjectURL(this.recording.blob);
            this.downloadFile(this.recording.url, filename);
        };

        this.recording.mediaRecorder.start();
        setTimeout(() => this.stopRecording(), 120000);
        this.recording.isRecording = true;
        console.log(`Recording started in ${type} format...`);
    }

    stopRecording() {
        if (!this.recording.isRecording) {
            this.showMessage("stopRecordingStatus", "No recording in progress", "error");
            return;
        }
    
        this.showStatus("stopRecordingStatus", true);
        this.recording.mediaRecorder.stop();
        this.recording.isRecording = false;
    
        const indicator = document.getElementById("recordingIndicator");
        indicator.classList.add("hidden");
        if (this.recordingTimer) {
            clearInterval(this.recordingTimer);
            this.recordingTimer = null;
        }
    
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.showMessage("stopRecordingStatus", "Recording stopped", "success");
        this.showStatus("stopRecordingStatus", false);
        console.log("Recording stopped...");
    }

    toggleRotate() {
        this.showStatus("toggleRotateStatus", true);
        this.controls.autoRotate = !this.controls.autoRotate;
        this.showMessage("toggleRotateStatus", this.controls.autoRotate ? "Auto-rotate enabled" : "Auto-rotate disabled", "success");
        this.showStatus("toggleRotateStatus", false);
        console.log(this.controls.autoRotate ? "🔄 Auto-rotate enabled" : "🛑 Auto-rotate disabled");
    }

    rotateScene(angle) {
        this.showStatus("prevPageStatus", true);
        this.scene.rotation.y += angle;
        this.showMessage("prevPageStatus", "Rotated left", "success");
        this.showStatus("prevPageStatus", false);

        this.showStatus("nextPageStatus", true);
        this.scene.rotation.y += angle;
        this.showMessage("nextPageStatus", "Rotated right", "success");
        this.showStatus("nextPageStatus", false);
    }

    handleResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        console.log("🔄 Window resized");
    }

    downloadFile(data, filename) {
        const link = document.createElement("a");
        link.href = data;
        link.download = filename;
        link.click();
    }

    showStatus(statusId, show) {
        const statusElement = document.getElementById(statusId);
        if (statusElement) {
            statusElement.classList.toggle("hidden", !show);
            if (show) {
                statusElement.classList.remove("success", "error");
                statusElement.classList.add("loading");
                statusElement.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            } else {
                statusElement.classList.remove("loading");
            }
        }
    }

    showMessage(statusId, message, type) {
        const statusElement = document.getElementById(statusId);
        if (statusElement) {
            statusElement.classList.remove("hidden", "loading");
            statusElement.classList.add(type === "success" ? "success" : "error");
            statusElement.innerHTML = type === "success" ? '<i class="fas fa-check"></i>' : '<i class="fas fa-exclamation-triangle"></i>';
            statusElement.setAttribute("data-tooltip", message);
            
            setTimeout(() => {
                statusElement.classList.add("hidden");
                statusElement.removeAttribute("data-tooltip");
                statusElement.classList.remove("success", "error");
            }, 3000);
        }
    }
}

const app = new ThreeJSApp();
app.init();







LATEST COMMITS


import * as THREE from "three";
import { OrbitControls } from "OrbitControls";

class ThreeJSApp {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 0, 3);

        this.renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true,
            preserveDrawingBuffer: true
        });
        this.renderer.setClearColor(0x000000, 0.2);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);
        document.body.style.backgroundColor = "#0f0f1a";

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enableZoom = true;
        this.controls.minDistance = 0.1;
        this.controls.maxDistance = 10;
        this.controls.enablePan = false;
        this.controls.autoRotate = false;
        this.controls.autoRotateSpeed = 1.0;

        this.images = [];
        this.radius = 2;
        this.sessionId = localStorage.getItem('sessionId');
        this.textureLoader = new THREE.TextureLoader();

        this.audioListener = new THREE.AudioListener();
        this.camera.add(this.audioListener);
        this.backgroundAudio = new THREE.Audio(this.audioListener);
        this.clickSound = new THREE.Audio(this.audioListener);
        this.shuffleSound = new THREE.Audio(this.audioListener);

        this.recording = {
            mediaRecorder: null,
            chunks: [],
            isRecording: false,
            blob: null,
            url: null
        };
        this.isRemoveActive = false;
        this.is360View = false;
        this.controlsVisible = true;

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.selectedMesh = null;
        this.focusedMesh = null;

        this.addLighting();
        this.addBackgroundEnvironment();
        this.addScreenshotSphere();
        this.setupAudio();
    }

    addLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0x00d4ff, 1, 10);
        pointLight.position.set(0, 0, 0);
        this.scene.add(pointLight);
    }

    addBackgroundEnvironment() {
        this.loadEnvironmentMap('https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg');
    }

    loadEnvironmentMap(url) {
        this.textureLoader.load(
            url,
            (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                this.scene.background = texture;
                console.log("🌌 Background environment map loaded from:", url);
            },
            undefined,
            (err) => console.error("❌ Error loading environment map:", err)
        );
    }

    addScreenshotSphere() {
        const geometry = new THREE.SphereGeometry(this.radius, 32, 32);
        const material = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, side: THREE.DoubleSide });
        this.screenshotSphere = new THREE.Mesh(geometry, material);
        this.screenshotSphere.position.set(0, 0, 0);
        this.scene.add(this.screenshotSphere);
    }

    setupAudio() {
        this.textureLoader.manager.onLoad = () => {
            this.backgroundAudio.setBuffer(this.loadAudio('path/to/ambient-background.mp3'));
            this.backgroundAudio.setLoop(true);
            this.backgroundAudio.setVolume(0.3);
            this.backgroundAudio.play();
            console.log("🎶 Background audio started");
        };

        this.clickSound.setBuffer(this.loadAudio('path/to/click-sound.mp3'));
        this.clickSound.setVolume(0.5);

        this.shuffleSound.setBuffer(this.loadAudio('path/to/shuffle-sound.mp3'));
        this.shuffleSound.setVolume(0.5);
    }

    loadAudio(url) {
        const audioLoader = new THREE.AudioLoader();
        let buffer;
        audioLoader.load(url, (audioBuffer) => {
            buffer = audioBuffer;
        });
        return buffer;
    }

    init() {
        console.log("🚀 Three.js script loaded with screenshot sphere");
        this.setupEventListeners();
        if (this.sessionId) {
            this.loadImages(this.sessionId);
        }
        this.animate();
        window.addEventListener("resize", () => this.handleResize());
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        if (this.controls.autoRotate) {
            this.controls.update();
            this.screenshotSphere.rotation.y += 0.001;
        } else if (!this.is360View && this.autoRotate) {
            this.scene.rotation.y += 0.005;
        }
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }

    setupEventListeners() {
        document.getElementById("downloadBtn").addEventListener("click", () => this.handleDownload());
        document.getElementById("zoomSlider").addEventListener("input", () => this.handleZoom());
        document.getElementById("radiusSlider").addEventListener("input", () => this.handleRadius());
        document.getElementById("screenshotForm").addEventListener("submit", (e) => this.handleScreenshotSubmit(e));
        document.getElementById("uploadForm").addEventListener("submit", (e) => this.handleUploadSubmit(e));
        document.getElementById("startRecordingBtn").addEventListener("click", () => this.startRecording());
        document.getElementById("stopRecordingBtn").addEventListener("click", () => this.stopRecording());
        document.getElementById("toggleRotateBtn").addEventListener("click", () => this.toggleRotate());
        document.getElementById("shuffleBtn").addEventListener("click", () => this.shuffleImages());
        document.getElementById("prevPage").addEventListener("click", () => this.rotateScene(-Math.PI / 8));
        document.getElementById("nextPage").addEventListener("click", () => this.rotateScene(Math.PI / 8));
        document.getElementById("toggleViewBtn").addEventListener("click", () => this.toggleViewMode());
        document.getElementById("toggleControlsBtn").addEventListener("click", () => this.toggleControls());

        this.renderer.domElement.addEventListener("click", (event) => this.onCanvasClick(event));
        this.renderer.domElement.addEventListener("dblclick", (event) => this.onDoubleClick(event));
        this.renderer.domElement.addEventListener("mousemove", (event) => this.onMouseMove(event));
        this.renderer.domElement.addEventListener("touchstart", (event) => this.onTouchStart(event));
        this.renderer.domElement.addEventListener("touchmove", (event) => this.onTouchMove(event));

        document.getElementById("toggleRemoveBtn").addEventListener("click", () => this.toggleRemove());
        document.getElementById("removeBtn").addEventListener("click", () => this.removeSelectedImage());
        document.getElementById("removeAllBtn").addEventListener("click", () => this.removeAllImages());

        document.getElementById("images").addEventListener("change", (event) => this.showImagePreviews(event));
        document.getElementById("envMapInput").addEventListener("change", (event) => this.handleEnvMapUpload(event));
    }

    handleEnvMapUpload(event) {
        const file = event.target.files[0];
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const url = e.target.result;
                this.loadEnvironmentMap(url);
                this.screenshotSphere.material.map = this.textureLoader.load(url);
                this.screenshotSphere.material.needsUpdate = true;
                console.log("🌍 User uploaded new map texture to sphere");
            };
            reader.readAsDataURL(file);
        } else {
            console.error("❌ Please upload a valid image file for the map");
            this.showMessage("toggleViewStatus", "Invalid file type. Please upload an image.", "error");
        }
    }

    toggleControls() {
        this.controlsVisible = !this.controlsVisible;
        const controlPanels = document.querySelectorAll(".control-panel");
        const toggleButton = document.getElementById("toggleControlsBtn");

        controlPanels.forEach(panel => {
            panel.classList.toggle("hidden-panel", !this.controlsVisible);
        });

        toggleButton.textContent = this.controlsVisible ? "Hide Controls" : "Show Controls";
        toggleButton.querySelector("i").className = this.controlsVisible ? "fas fa-eye" : "fas fa-eye-slash";
        console.log(this.controlsVisible ? "🖥️ Controls visible" : "🖥️ Controls hidden");
    }

    onMouseMove(event) {
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    onTouchStart(event) {
        const touch = event.touches[0];
        this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        this.onCanvasClick(event);
    }

    onTouchMove(event) {
        event.preventDefault();
        const touch = event.touches[0];
        this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        this.scene.rotation.y += (touch.clientX - this.lastTouchX) * 0.005;
        this.lastTouchX = touch.clientX;
    }

    onDoubleClick(event) {
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects([this.screenshotSphere], true);

        if (intersects.length > 0) {
            console.log("Double-clicked on sphere at:", intersects[0].point);
        }
    }

    onCanvasClick(event) {
        if (!this.isRemoveActive) return;

        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects([this.screenshotSphere], true);

        if (intersects.length > 0) {
            this.selectedMesh = this.screenshotSphere;
            this.showRemoveButton(this.screenshotSphere);
            if (!this.clickSound.isPlaying) {
                this.clickSound.play();
            }
        }
    }

    toggleRemove() {
        this.showStatus("toggleRemoveStatus", true);
        this.isRemoveActive = !this.isRemoveActive;
        const removeControls = document.getElementById("removeControls");
        setTimeout(() => {
            removeControls.classList.toggle("hidden", !this.isRemoveActive);
            this.showMessage("toggleRemoveStatus", this.isRemoveActive ? "Remove mode enabled" : "Remove mode disabled", "success");
            this.showStatus("toggleRemoveStatus", false);
        }, 500);
    }

    hideAllRemoveButtons() {
        const removeButtons = document.querySelectorAll("button[style*='Remove']");
        removeButtons.forEach(btn => btn.remove());
        this.screenshotSphere.userData.buttonCreated = false;
    }

    removeSelectedImage() {
        if (this.selectedMesh) {
            this.showStatus("removeSelectedStatus", true);
            this.removeAllImages(); // Simplified to clear sphere texture
            this.hideAllRemoveButtons();
            this.selectedMesh = null;
            this.showMessage("removeSelectedStatus", "Sphere texture removed", "success");
            this.showStatus("removeSelectedStatus", false);
        } else {
            this.showMessage("removeSelectedStatus", "No sphere selected for removal", "error");
        }
    }

    removeAllImages() {
        this.showStatus("removeAllStatus", true);
        this.screenshotSphere.material.map = null;
        this.screenshotSphere.material.color.set(0xaaaaaa);
        this.screenshotSphere.material.needsUpdate = true;
        this.images = [];
        this.imagesToLoad = [];
        console.log("🗑️ All images removed from sphere");
        this.showMessage("removeAllStatus", "All images removed", "success");
        this.showStatus("removeAllStatus", false);
    }

    toggleViewMode() {
        this.showStatus("toggleViewStatus", true);
        this.is360View = !this.is360View;
        console.log(this.is360View ? "🔄 Switched to 360-degree view" : "🔄 Switched to 3D view");

        if (this.is360View) {
            this.camera.position.set(0, 0, 0);
            this.controls.maxDistance = this.radius * 2;
            this.controls.minDistance = 0.1;
            this.controls.enablePan = false;
            this.screenshotSphere.material.side = THREE.BackSide;
        } else {
            this.camera.position.set(0, 0, 3);
            this.controls.maxDistance = 5;
            this.controls.minDistance = 2;
            this.controls.enablePan = false;
            this.screenshotSphere.material.side = THREE.FrontSide;
        }
        this.camera.updateProjectionMatrix();
        this.showMessage("toggleViewStatus", this.is360View ? "Switched to 360 view" : "Switched to 3D view", "success");
        this.showStatus("toggleViewStatus", false);
    }

    async loadImages(sessionId) {
        this.clearScene();

        try {
            this.showStatus("toggleViewStatus", true);
            const response = await fetch(`http://localhost:3000/api/screenshots/${sessionId}/`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            if (!data.screenshots?.length) {
                this.showMessage("toggleViewStatus", "No screenshots found", "error");
                return;
            }

            data.screenshots.sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
            this.imagesToLoad = data.screenshots;
            await this.updateScreenshotSphereTexture();
            this.showMessage("toggleViewStatus", "Screenshots loaded onto sphere successfully", "success");
        } catch (error) {
            console.error("❌ Error fetching images:", error);
            this.showMessage("toggleViewStatus", `Failed to load images: ${error.message}`, "error");
        } finally {
            this.showStatus("toggleViewStatus", false);
        }
    }

    clearScene() {
        this.images = [];
        console.log("🗑️ Scene cleared (except screenshot sphere)");
    }

    async updateScreenshotSphereTexture() {
        if (!this.imagesToLoad || this.imagesToLoad.length === 0) return;

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const textureWidth = 2048;
        const textureHeight = 1024;
        canvas.width = textureWidth;
        canvas.height = textureHeight;

        const textures = await Promise.all(
            this.imagesToLoad.map(filename =>
                new Promise((resolve) => {
                    this.textureLoader.load(filename, resolve, undefined, (err) => {
                        console.warn(`⚠ Skipping texture: ${filename}`, err);
                        resolve(null);
                    });
                })
            )
        ).then(results => results.filter(tex => tex !== null));

        if (textures.length === 0) {
            console.error("No valid textures loaded");
            return;
        }

        const cols = Math.ceil(Math.sqrt(textures.length));
        const rows = Math.ceil(textures.length / cols);
        const tileWidth = textureWidth / cols;
        const tileHeight = textureHeight / rows;

        textures.forEach((texture, index) => {
            const img = texture.image;
            const col = index % cols;
            const row = Math.floor(index / cols);
            ctx.drawImage(img, col * tileWidth, row * tileHeight, tileWidth, tileHeight);
        });

        const sphereTexture = new THREE.Texture(canvas);
        sphereTexture.needsUpdate = true;
        this.screenshotSphere.material.map = sphereTexture;
        this.screenshotSphere.material.needsUpdate = true;

        console.log(`🌍 Applied ${textures.length} screenshots to sphere`);
    }

    shuffleImages() {
        if (!this.imagesToLoad || this.imagesToLoad.length === 0) {
            this.showMessage("shuffleStatus", "No images to shuffle", "error");
            return;
        }

        this.showStatus("shuffleStatus", true);
        this.imagesToLoad = this.imagesToLoad.sort(() => Math.random() - 0.5);
        this.updateScreenshotSphereTexture();
        if (!this.shuffleSound.isPlaying) {
            this.shuffleSound.play();
        }
        this.showMessage("shuffleStatus", "Images shuffled successfully", "success");
        this.showStatus("shuffleStatus", false);
    }

    showRemoveButton(mesh) {
        if (!this.isRemoveActive || mesh.userData.buttonCreated) return;

        const removeBtn = document.createElement("button");
        removeBtn.textContent = "Remove";
        removeBtn.style.cssText = `
            position: absolute;
            z-index: 1000;
            padding: 8px 12px;
            background: rgba(220, 53, 69, 0.8);
            color: #fff;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.8rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s ease;
        `;
        document.body.appendChild(removeBtn);

        const updateButtonPosition = () => {
            const screenPos = new THREE.Vector3(0, 0, 0); // Center of sphere
            screenPos.project(this.camera);
            const xPos = (screenPos.x + 1) / 2 * window.innerWidth;
            const yPos = (1 - screenPos.y) / 2 * window.innerHeight;
            removeBtn.style.left = `${xPos}px`;
            removeBtn.style.top = `${yPos - 30}px`;
            removeBtn.style.display = "block";
        };

        updateButtonPosition();

        const updateLoop = () => {
            if (this.isRemoveActive) {
                updateButtonPosition();
            } else {
                removeBtn.remove();
                mesh.userData.buttonCreated = false;
                return;
            }
            requestAnimationFrame(updateLoop);
        };
        updateLoop();

        removeBtn.addEventListener("click", () => {
            this.removeAllImages();
            removeBtn.remove();
            mesh.userData.buttonCreated = false;
        });

        removeBtn.addEventListener("mouseover", () => {
            removeBtn.style.opacity = "0.8";
            removeBtn.style.transform = "scale(1.05)";
        });
        removeBtn.addEventListener("mouseout", () => {
            removeBtn.style.opacity = "1";
            removeBtn.style.transform = "scale(1)";
        });

        mesh.userData.buttonCreated = true;
    }

    handleDownload() {
        this.showStatus("downloadStatus", true);
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        const highResWidth = Math.max(screenWidth * 2, 1920);
        const highResHeight = Math.max(screenHeight * 2, 1080);

        const originalSize = { width: this.renderer.domElement.width, height: this.renderer.domElement.height };
        this.renderer.setSize(highResWidth, highResHeight, false);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.render(this.scene, this.camera);

        const imgData = this.renderer.domElement.toDataURL("image/png", 1.0);

        this.renderer.setSize(originalSize.width, originalSize.height, false);
        this.renderer.render(this.scene, this.camera);

        this.downloadFile(imgData, "rendered_high_res_image.png");
        this.showMessage("downloadStatus", "Image downloaded successfully", "success");
        this.showStatus("downloadStatus", false);
    }

    handleZoom() {
        const zoomSlider = document.getElementById("zoomSlider");
        const zoomValue = document.getElementById("zoomValue");
        const zoomLevel = parseFloat(zoomSlider.value);
        zoomValue.textContent = zoomLevel.toFixed(1);
        this.controls.maxDistance = zoomLevel;
        this.controls.update();
        if (!this.is360View) {
            this.camera.position.z = zoomLevel;
            this.camera.updateProjectionMatrix();
        }
        console.log(`🔍 Zoom level updated: ${zoomLevel}`);
    }

    handleRadius() {
        const radiusSlider = document.getElementById("radiusSlider");
        const radiusValue = document.getElementById("radiusValue");
        this.radius = parseFloat(radiusSlider.value);
        radiusValue.textContent = this.radius.toFixed(1);
        this.screenshotSphere.geometry.dispose();
        this.screenshotSphere.geometry = new THREE.SphereGeometry(this.radius, 32, 32);
    }

    async handleScreenshotSubmit(event) {
        event.preventDefault();
        const url = document.getElementById("url").value;
        if (!url) {
            this.showMessage("screenshotStatus", "Please enter a valid URL", "error");
            return;
        }

        this.showStatus("screenshotStatus", true);

        try {
            const response = await fetch("http://localhost:3000/api/capture", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url })
            });

            const result = await response.json();
            if (result.sessionId) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.showMessage("screenshotStatus", `Screenshots captured for ${url}`, "success");
                this.loadImages(this.sessionId);
            } else {
                this.showMessage("screenshotStatus", "Failed to capture screenshot", "error");
            }
        } catch (error) {
            console.error("Error:", error);
            this.showMessage("screenshotStatus", `Failed to capture screenshot: ${error.message}`, "error");
        } finally {
            this.showStatus("screenshotStatus", false);
        }
    }

    async handleUploadSubmit(event) {
        event.preventDefault();
        const sessionId = this.sessionId || null;
        const fileInput = document.getElementById("images");
        if (!fileInput.files?.length) {
            this.showMessage("uploadStatus", "Please select at least one image to upload", "error");
            return;
        }

        this.showStatus("uploadStatus", true);

        const formData = new FormData();
        for (const file of fileInput.files) {
            formData.append("images", file);
        }

        try {
            const response = await fetch(`http://localhost:3000/api/upload${sessionId ? `/${sessionId}` : ''}`, {
                method: "POST",
                body: formData
            });

            const result = await response.json();
            if (result.success) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.showMessage("uploadStatus", `Uploaded ${result.filePaths.length} images successfully`, "success");
                this.loadImages(this.sessionId);
            } else {
                this.showMessage("uploadStatus", `Upload failed: ${result.error || "Unknown error"}`, "error");
            }
        } catch (error) {
            console.error("Error uploading files:", error);
            this.showMessage("uploadStatus", `Failed to upload images: ${error.message}`, "error");
        } finally {
            this.showStatus("uploadStatus", false);
        }
    }

    showImagePreviews(event) {
        const files = event.target.files;
        const previewContainer = document.getElementById("previewContainer");
        previewContainer.innerHTML = "";

        for (const file of files) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = document.createElement("img");
                img.src = e.target.result;
                img.classList.add("preview-thumbnail");
                img.addEventListener("click", () => {
                    console.log(`Clicked preview for ${file.name}`);
                });
                previewContainer.appendChild(img);
            };
            reader.readAsDataURL(file);
        }
    }

    startRecording() {
        if (this.recording.isRecording) {
            this.showMessage("startRecordingStatus", "Recording already in progress", "error");
            return;
        }

        this.showStatus("startRecordingStatus", true);
        this.recording.chunks = [];
        this.renderer.setSize(1920, 1080);
        const stream = this.renderer.domElement.captureStream(30);

        try {
            this.recording.mediaRecorder = new MediaRecorder(stream, { mimeType: "video/mp4" });
            this.setupRecorder("mp4", "360-video.mp4");
        } catch (e) {
            console.error("MP4 recording failed, switching to WebM.", e);
            this.recording.mediaRecorder = new MediaRecorder(stream, { mimeType: "video/webm" });
            this.setupRecorder("webm", "360-video.webm");
        }

        const indicator = document.getElementById("recordingIndicator");
        indicator.classList.remove("hidden");
        indicator.textContent = "Recording... (2 minutes remaining)";

        let timeLeft = 120;
        this.recordingTimer = setInterval(() => {
            timeLeft--;
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            indicator.textContent = `Recording... (${minutes}:${seconds < 10 ? '0' : ''}${seconds} remaining)`;
            if (timeLeft <= 0) {
                clearInterval(this.recordingTimer);
                this.stopRecording();
            }
        }, 1000);
        this.showMessage("startRecordingStatus", "Recording started", "success");
        this.showStatus("startRecordingStatus", false);
    }

    setupRecorder(type, filename) {
        this.recording.mediaRecorder.ondataavailable = (event) => {
            this.recording.chunks.push(event.data);
        };

        this.recording.mediaRecorder.onstop = () => {
            this.recording.blob = new Blob(this.recording.chunks, { type: `video/${type}` });
            this.recording.url = URL.createObjectURL(this.recording.blob);
            this.downloadFile(this.recording.url, filename);
        };

        this.recording.mediaRecorder.start();
        setTimeout(() => this.stopRecording(), 120000);
        this.recording.isRecording = true;
        console.log(`Recording started in ${type} format...`);
    }

    stopRecording() {
        if (!this.recording.isRecording) {
            this.showMessage("stopRecordingStatus", "No recording in progress", "error");
            return;
        }

        this.showStatus("stopRecordingStatus", true);
        this.recording.mediaRecorder.stop();
        this.recording.isRecording = false;

        const indicator = document.getElementById("recordingIndicator");
        indicator.classList.add("hidden");
        if (this.recordingTimer) {
            clearInterval(this.recordingTimer);
            this.recordingTimer = null;
        }

        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.showMessage("stopRecordingStatus", "Recording stopped", "success");
        this.showStatus("stopRecordingStatus", false);
        console.log("Recording stopped...");
    }

    toggleRotate() {
        this.showStatus("toggleRotateStatus", true);
        this.controls.autoRotate = !this.controls.autoRotate;
        this.showMessage("toggleRotateStatus", this.controls.autoRotate ? "Auto-rotate enabled" : "Auto-rotate disabled", "success");
        this.showStatus("toggleRotateStatus", false);
        console.log(this.controls.autoRotate ? "🔄 Auto-rotate enabled" : "🛑 Auto-rotate disabled");
    }

    rotateScene(angle) {
        this.showStatus("prevPageStatus", true);
        this.scene.rotation.y += angle;
        this.showMessage("prevPageStatus", "Rotated left", "success");
        this.showStatus("prevPageStatus", false);

        this.showStatus("nextPageStatus", true);
        this.scene.rotation.y += angle;
        this.showMessage("nextPageStatus", "Rotated right", "success");
        this.showStatus("nextPageStatus", false);
    }

    handleResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        console.log("🔄 Window resized");
    }

    downloadFile(data, filename) {
        const link = document.createElement("a");
        link.href = data;
        link.download = filename;
        link.click();
    }

    showStatus(statusId, show) {
        const statusElement = document.getElementById(statusId);
        if (statusElement) {
            statusElement.classList.toggle("hidden", !show);
            if (show) {
                statusElement.classList.remove("success", "error");
                statusElement.classList.add("loading");
                statusElement.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            } else {
                statusElement.classList.remove("loading");
            }
        }
    }

    showMessage(statusId, message, type) {
        const statusElement = document.getElementById(statusId);
        if (statusElement) {
            statusElement.classList.remove("hidden", "loading");
            statusElement.classList.add(type === "success" ? "success" : "error");
            statusElement.innerHTML = type === "success" ? '<i class="fas fa-check"></i>' : '<i class="fas fa-exclamation-triangle"></i>';
            statusElement.setAttribute("data-tooltip", message);

            setTimeout(() => {
                statusElement.classList.add("hidden");
                statusElement.removeAttribute("data-tooltip");
                statusElement.classList.remove("success", "error");
            }, 3000);
        }
    }
}

const app = new ThreeJSApp();
app.init();



SPHERICAL map
import * as THREE from "three";
import { OrbitControls } from "OrbitControls";

class ThreeJSApp {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 0, 3);

        this.renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true,
            preserveDrawingBuffer: true
        });
        this.renderer.setClearColor(0x000000, 0.2);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);
        document.body.style.backgroundColor = "#0f0f1a";

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enableZoom = true;
        this.controls.minDistance = 0.1;
        this.controls.maxDistance = 10;
        this.controls.enablePan = false;
        this.controls.autoRotate = false;
        this.controls.autoRotateSpeed = 1.0;

        this.images = [];
        this.radius = 2;
        this.sessionId = localStorage.getItem('sessionId');
        this.textureLoader = new THREE.TextureLoader();

        this.audioListener = new THREE.AudioListener();
        this.camera.add(this.audioListener);
        this.backgroundAudio = new THREE.Audio(this.audioListener);
        this.clickSound = new THREE.Audio(this.audioListener);
        this.shuffleSound = new THREE.Audio(this.audioListener);

        this.recording = {
            mediaRecorder: null,
            chunks: [],
            isRecording: false,
            blob: null,
            url: null
        };
        this.isRemoveActive = false;
        this.is360View = false;
        this.controlsVisible = true;

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.selectedMesh = null;
        this.focusedMesh = null;

        this.addLighting();
        this.addBackgroundEnvironment();
        this.addScreenshotSphere();
        this.setupAudio();
    }

    addLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0x00d4ff, 1, 10);
        pointLight.position.set(0, 0, 0);
        this.scene.add(pointLight);
    }

    addBackgroundEnvironment() {
        this.loadEnvironmentMap('https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg');
    }

    loadEnvironmentMap(url) {
        this.textureLoader.load(
            url,
            (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                this.scene.background = texture;
                console.log("🌌 Background environment map loaded from:", url);
            },
            undefined,
            (err) => console.error("❌ Error loading environment map:", err)
        );
    }

    addScreenshotSphere() {
        const geometry = new THREE.SphereGeometry(this.radius, 32, 32);
        const material = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, side: THREE.DoubleSide });
        this.screenshotSphere = new THREE.Mesh(geometry, material);
        this.screenshotSphere.position.set(0, 0, 0);
        this.scene.add(this.screenshotSphere);
    }

    setupAudio() {
        this.textureLoader.manager.onLoad = () => {
            this.backgroundAudio.setBuffer(this.loadAudio('path/to/ambient-background.mp3'));
            this.backgroundAudio.setLoop(true);
            this.backgroundAudio.setVolume(0.3);
            this.backgroundAudio.play();
            console.log("🎶 Background audio started");
        };

        this.clickSound.setBuffer(this.loadAudio('path/to/click-sound.mp3'));
        this.clickSound.setVolume(0.5);

        this.shuffleSound.setBuffer(this.loadAudio('path/to/shuffle-sound.mp3'));
        this.shuffleSound.setVolume(0.5);
    }

    loadAudio(url) {
        const audioLoader = new THREE.AudioLoader();
        let buffer;
        audioLoader.load(url, (audioBuffer) => {
            buffer = audioBuffer;
        });
        return buffer;
    }

    init() {
        console.log("🚀 Three.js script loaded with screenshot sphere");
        this.setupEventListeners();
        if (this.sessionId) {
            this.loadImages(this.sessionId);
        }
        this.animate();
        window.addEventListener("resize", () => this.handleResize());
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        if (this.controls.autoRotate) {
            this.controls.update();
            this.screenshotSphere.rotation.y += 0.001;
        } else if (!this.is360View && this.autoRotate) {
            this.scene.rotation.y += 0.005;
        }
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }

    setupEventListeners() {
        document.getElementById("downloadBtn").addEventListener("click", () => this.handleDownload());
        document.getElementById("zoomSlider").addEventListener("input", () => this.handleZoom());
        document.getElementById("radiusSlider").addEventListener("input", () => this.handleRadius());
        document.getElementById("screenshotForm").addEventListener("submit", (e) => this.handleScreenshotSubmit(e));
        document.getElementById("uploadForm").addEventListener("submit", (e) => this.handleUploadSubmit(e));
        document.getElementById("startRecordingBtn").addEventListener("click", () => this.startRecording());
        document.getElementById("stopRecordingBtn").addEventListener("click", () => this.stopRecording());
        document.getElementById("toggleRotateBtn").addEventListener("click", () => this.toggleRotate());
        document.getElementById("shuffleBtn").addEventListener("click", () => this.shuffleImages());
        document.getElementById("prevPage").addEventListener("click", () => this.rotateScene(-Math.PI / 8));
        document.getElementById("nextPage").addEventListener("click", () => this.rotateScene(Math.PI / 8));
        document.getElementById("toggleViewBtn").addEventListener("click", () => this.toggleViewMode());
        document.getElementById("toggleControlsBtn").addEventListener("click", () => this.toggleControls());

        this.renderer.domElement.addEventListener("click", (event) => this.onCanvasClick(event));
        this.renderer.domElement.addEventListener("dblclick", (event) => this.onDoubleClick(event));
        this.renderer.domElement.addEventListener("mousemove", (event) => this.onMouseMove(event));
        this.renderer.domElement.addEventListener("touchstart", (event) => this.onTouchStart(event));
        this.renderer.domElement.addEventListener("touchmove", (event) => this.onTouchMove(event));

        document.getElementById("toggleRemoveBtn").addEventListener("click", () => this.toggleRemove());
        document.getElementById("removeBtn").addEventListener("click", () => this.removeSelectedImage());
        document.getElementById("removeAllBtn").addEventListener("click", () => this.removeAllImages());

        document.getElementById("images").addEventListener("change", (event) => this.showImagePreviews(event));
        document.getElementById("envMapInput").addEventListener("change", (event) => this.handleEnvMapUpload(event));
    }

    handleEnvMapUpload(event) {
        const file = event.target.files[0];
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const url = e.target.result;
                this.loadEnvironmentMap(url);
                this.screenshotSphere.material.map = this.textureLoader.load(url);
                this.screenshotSphere.material.needsUpdate = true;
                console.log("🌍 User uploaded new map texture to sphere");
            };
            reader.readAsDataURL(file);
        } else {
            console.error("❌ Please upload a valid image file for the map");
            this.showMessage("toggleViewStatus", "Invalid file type. Please upload an image.", "error");
        }
    }

    toggleControls() {
        this.controlsVisible = !this.controlsVisible;
        const controlPanels = document.querySelectorAll(".control-panel");
        const toggleButton = document.getElementById("toggleControlsBtn");

        controlPanels.forEach(panel => {
            panel.classList.toggle("hidden-panel", !this.controlsVisible);
        });

        toggleButton.textContent = this.controlsVisible ? "Hide Controls" : "Show Controls";
        toggleButton.querySelector("i").className = this.controlsVisible ? "fas fa-eye" : "fas fa-eye-slash";
        console.log(this.controlsVisible ? "🖥️ Controls visible" : "🖥️ Controls hidden");
    }

    onMouseMove(event) {
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    onTouchStart(event) {
        const touch = event.touches[0];
        this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        this.onCanvasClick(event);
    }

    onTouchMove(event) {
        event.preventDefault();
        const touch = event.touches[0];
        this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        this.scene.rotation.y += (touch.clientX - this.lastTouchX) * 0.005;
        this.lastTouchX = touch.clientX;
    }

    onDoubleClick(event) {
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects([this.screenshotSphere], true);

        if (intersects.length > 0) {
            console.log("Double-clicked on sphere at:", intersects[0].point);
        }
    }

    onCanvasClick(event) {
        if (!this.isRemoveActive) return;

        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects([this.screenshotSphere], true);

        if (intersects.length > 0) {
            this.selectedMesh = this.screenshotSphere;
            this.showRemoveButton(this.screenshotSphere);
            if (!this.clickSound.isPlaying) {
                this.clickSound.play();
            }
        }
    }

    toggleRemove() {
        this.showStatus("toggleRemoveStatus", true);
        this.isRemoveActive = !this.isRemoveActive;
        const removeControls = document.getElementById("removeControls");
        setTimeout(() => {
            removeControls.classList.toggle("hidden", !this.isRemoveActive);
            this.showMessage("toggleRemoveStatus", this.isRemoveActive ? "Remove mode enabled" : "Remove mode disabled", "success");
            this.showStatus("toggleRemoveStatus", false);
        }, 500);
    }

    hideAllRemoveButtons() {
        const removeButtons = document.querySelectorAll("button[style*='Remove']");
        removeButtons.forEach(btn => btn.remove());
        this.screenshotSphere.userData.buttonCreated = false;
    }

    removeSelectedImage() {
        if (this.selectedMesh) {
            this.showStatus("removeSelectedStatus", true);
            this.removeAllImages(); // Simplified to clear sphere texture
            this.hideAllRemoveButtons();
            this.selectedMesh = null;
            this.showMessage("removeSelectedStatus", "Sphere texture removed", "success");
            this.showStatus("removeSelectedStatus", false);
        } else {
            this.showMessage("removeSelectedStatus", "No sphere selected for removal", "error");
        }
    }

    removeAllImages() {
        this.showStatus("removeAllStatus", true);
        this.screenshotSphere.material.map = null;
        this.screenshotSphere.material.color.set(0xaaaaaa);
        this.screenshotSphere.material.needsUpdate = true;
        this.images = [];
        this.imagesToLoad = [];
        console.log("🗑️ All images removed from sphere");
        this.showMessage("removeAllStatus", "All images removed", "success");
        this.showStatus("removeAllStatus", false);
    }

    toggleViewMode() {
        this.showStatus("toggleViewStatus", true);
        this.is360View = !this.is360View;
        console.log(this.is360View ? "🔄 Switched to 360-degree view" : "🔄 Switched to 3D view");

        if (this.is360View) {
            this.camera.position.set(0, 0, 0);
            this.controls.maxDistance = this.radius * 2;
            this.controls.minDistance = 0.1;
            this.controls.enablePan = false;
            this.screenshotSphere.material.side = THREE.BackSide;
        } else {
            this.camera.position.set(0, 0, 3);
            this.controls.maxDistance = 5;
            this.controls.minDistance = 2;
            this.controls.enablePan = false;
            this.screenshotSphere.material.side = THREE.FrontSide;
        }
        this.camera.updateProjectionMatrix();
        this.showMessage("toggleViewStatus", this.is360View ? "Switched to 360 view" : "Switched to 3D view", "success");
        this.showStatus("toggleViewStatus", false);
    }

    async loadImages(sessionId) {
        this.clearScene();

        try {
            this.showStatus("toggleViewStatus", true);
            const response = await fetch(`http://localhost:3000/api/screenshots/${sessionId}/`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            if (!data.screenshots?.length) {
                this.showMessage("toggleViewStatus", "No screenshots found", "error");
                return;
            }

            data.screenshots.sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
            this.imagesToLoad = data.screenshots;
            await this.updateScreenshotSphereTexture();
            this.showMessage("toggleViewStatus", "Screenshots loaded onto sphere successfully", "success");
        } catch (error) {
            console.error("❌ Error fetching images:", error);
            this.showMessage("toggleViewStatus", `Failed to load images: ${error.message}`, "error");
        } finally {
            this.showStatus("toggleViewStatus", false);
        }
    }

    clearScene() {
        this.images = [];
        console.log("🗑️ Scene cleared (except screenshot sphere)");
    }

    async updateScreenshotSphereTexture() {
        if (!this.imagesToLoad || this.imagesToLoad.length === 0) return;

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const textureWidth = 2048;
        const textureHeight = 1024;
        canvas.width = textureWidth;
        canvas.height = textureHeight;

        const textures = await Promise.all(
            this.imagesToLoad.map(filename =>
                new Promise((resolve) => {
                    this.textureLoader.load(filename, resolve, undefined, (err) => {
                        console.warn(`⚠ Skipping texture: ${filename}`, err);
                        resolve(null);
                    });
                })
            )
        ).then(results => results.filter(tex => tex !== null));

        if (textures.length === 0) {
            console.error("No valid textures loaded");
            return;
        }

        const cols = Math.ceil(Math.sqrt(textures.length));
        const rows = Math.ceil(textures.length / cols);
        const tileWidth = textureWidth / cols;
        const tileHeight = textureHeight / rows;

        textures.forEach((texture, index) => {
            const img = texture.image;
            const col = index % cols;
            const row = Math.floor(index / cols);
            ctx.drawImage(img, col * tileWidth, row * tileHeight, tileWidth, tileHeight);
        });

        const sphereTexture = new THREE.Texture(canvas);
        sphereTexture.needsUpdate = true;
        this.screenshotSphere.material.map = sphereTexture;
        this.screenshotSphere.material.needsUpdate = true;

        console.log(`🌍 Applied ${textures.length} screenshots to sphere`);
    }

    shuffleImages() {
        if (!this.imagesToLoad || this.imagesToLoad.length === 0) {
            this.showMessage("shuffleStatus", "No images to shuffle", "error");
            return;
        }

        this.showStatus("shuffleStatus", true);
        this.imagesToLoad = this.imagesToLoad.sort(() => Math.random() - 0.5);
        this.updateScreenshotSphereTexture();
        if (!this.shuffleSound.isPlaying) {
            this.shuffleSound.play();
        }
        this.showMessage("shuffleStatus", "Images shuffled successfully", "success");
        this.showStatus("shuffleStatus", false);
    }

    showRemoveButton(mesh) {
        if (!this.isRemoveActive || mesh.userData.buttonCreated) return;

        const removeBtn = document.createElement("button");
        removeBtn.textContent = "Remove";
        removeBtn.style.cssText = `
            position: absolute;
            z-index: 1000;
            padding: 8px 12px;
            background: rgba(220, 53, 69, 0.8);
            color: #fff;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.8rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s ease;
        `;
        document.body.appendChild(removeBtn);

        const updateButtonPosition = () => {
            const screenPos = new THREE.Vector3(0, 0, 0); // Center of sphere
            screenPos.project(this.camera);
            const xPos = (screenPos.x + 1) / 2 * window.innerWidth;
            const yPos = (1 - screenPos.y) / 2 * window.innerHeight;
            removeBtn.style.left = `${xPos}px`;
            removeBtn.style.top = `${yPos - 30}px`;
            removeBtn.style.display = "block";
        };

        updateButtonPosition();

        const updateLoop = () => {
            if (this.isRemoveActive) {
                updateButtonPosition();
            } else {
                removeBtn.remove();
                mesh.userData.buttonCreated = false;
                return;
            }
            requestAnimationFrame(updateLoop);
        };
        updateLoop();

        removeBtn.addEventListener("click", () => {
            this.removeAllImages();
            removeBtn.remove();
            mesh.userData.buttonCreated = false;
        });

        removeBtn.addEventListener("mouseover", () => {
            removeBtn.style.opacity = "0.8";
            removeBtn.style.transform = "scale(1.05)";
        });
        removeBtn.addEventListener("mouseout", () => {
            removeBtn.style.opacity = "1";
            removeBtn.style.transform = "scale(1)";
        });

        mesh.userData.buttonCreated = true;
    }

    handleDownload() {
        this.showStatus("downloadStatus", true);
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        const highResWidth = Math.max(screenWidth * 2, 1920);
        const highResHeight = Math.max(screenHeight * 2, 1080);

        const originalSize = { width: this.renderer.domElement.width, height: this.renderer.domElement.height };
        this.renderer.setSize(highResWidth, highResHeight, false);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.render(this.scene, this.camera);

        const imgData = this.renderer.domElement.toDataURL("image/png", 1.0);

        this.renderer.setSize(originalSize.width, originalSize.height, false);
        this.renderer.render(this.scene, this.camera);

        this.downloadFile(imgData, "rendered_high_res_image.png");
        this.showMessage("downloadStatus", "Image downloaded successfully", "success");
        this.showStatus("downloadStatus", false);
    }

    handleZoom() {
        const zoomSlider = document.getElementById("zoomSlider");
        const zoomValue = document.getElementById("zoomValue");
        const zoomLevel = parseFloat(zoomSlider.value);
        zoomValue.textContent = zoomLevel.toFixed(1);
        this.controls.maxDistance = zoomLevel;
        this.controls.update();
        if (!this.is360View) {
            this.camera.position.z = zoomLevel;
            this.camera.updateProjectionMatrix();
        }
        console.log(`🔍 Zoom level updated: ${zoomLevel}`);
    }

    handleRadius() {
        const radiusSlider = document.getElementById("radiusSlider");
        const radiusValue = document.getElementById("radiusValue");
        this.radius = parseFloat(radiusSlider.value);
        radiusValue.textContent = this.radius.toFixed(1);
        this.screenshotSphere.geometry.dispose();
        this.screenshotSphere.geometry = new THREE.SphereGeometry(this.radius, 32, 32);
    }

    async handleScreenshotSubmit(event) {
        event.preventDefault();
        const url = document.getElementById("url").value;
        if (!url) {
            this.showMessage("screenshotStatus", "Please enter a valid URL", "error");
            return;
        }

        this.showStatus("screenshotStatus", true);

        try {
            const response = await fetch("http://localhost:3000/api/capture", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url })
            });

            const result = await response.json();
            if (result.sessionId) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.showMessage("screenshotStatus", `Screenshots captured for ${url}`, "success");
                this.loadImages(this.sessionId);
            } else {
                this.showMessage("screenshotStatus", "Failed to capture screenshot", "error");
            }
        } catch (error) {
            console.error("Error:", error);
            this.showMessage("screenshotStatus", `Failed to capture screenshot: ${error.message}`, "error");
        } finally {
            this.showStatus("screenshotStatus", false);
        }
    }

    async handleUploadSubmit(event) {
        event.preventDefault();
        const sessionId = this.sessionId || null;
        const fileInput = document.getElementById("images");
        if (!fileInput.files?.length) {
            this.showMessage("uploadStatus", "Please select at least one image to upload", "error");
            return;
        }

        this.showStatus("uploadStatus", true);

        const formData = new FormData();
        for (const file of fileInput.files) {
            formData.append("images", file);
        }

        try {
            const response = await fetch(`http://localhost:3000/api/upload${sessionId ? `/${sessionId}` : ''}`, {
                method: "POST",
                body: formData
            });

            const result = await response.json();
            if (result.success) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.showMessage("uploadStatus", `Uploaded ${result.filePaths.length} images successfully`, "success");
                this.loadImages(this.sessionId);
            } else {
                this.showMessage("uploadStatus", `Upload failed: ${result.error || "Unknown error"}`, "error");
            }
        } catch (error) {
            console.error("Error uploading files:", error);
            this.showMessage("uploadStatus", `Failed to upload images: ${error.message}`, "error");
        } finally {
            this.showStatus("uploadStatus", false);
        }
    }

    showImagePreviews(event) {
        const files = event.target.files;
        const previewContainer = document.getElementById("previewContainer");
        previewContainer.innerHTML = "";

        for (const file of files) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = document.createElement("img");
                img.src = e.target.result;
                img.classList.add("preview-thumbnail");
                img.addEventListener("click", () => {
                    console.log(`Clicked preview for ${file.name}`);
                });
                previewContainer.appendChild(img);
            };
            reader.readAsDataURL(file);
        }
    }

    startRecording() {
        if (this.recording.isRecording) {
            this.showMessage("startRecordingStatus", "Recording already in progress", "error");
            return;
        }

        this.showStatus("startRecordingStatus", true);
        this.recording.chunks = [];
        this.renderer.setSize(1920, 1080);
        const stream = this.renderer.domElement.captureStream(30);

        try {
            this.recording.mediaRecorder = new MediaRecorder(stream, { mimeType: "video/mp4" });
            this.setupRecorder("mp4", "360-video.mp4");
        } catch (e) {
            console.error("MP4 recording failed, switching to WebM.", e);
            this.recording.mediaRecorder = new MediaRecorder(stream, { mimeType: "video/webm" });
            this.setupRecorder("webm", "360-video.webm");
        }

        const indicator = document.getElementById("recordingIndicator");
        indicator.classList.remove("hidden");
        indicator.textContent = "Recording... (2 minutes remaining)";

        let timeLeft = 120;
        this.recordingTimer = setInterval(() => {
            timeLeft--;
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            indicator.textContent = `Recording... (${minutes}:${seconds < 10 ? '0' : ''}${seconds} remaining)`;
            if (timeLeft <= 0) {
                clearInterval(this.recordingTimer);
                this.stopRecording();
            }
        }, 1000);
        this.showMessage("startRecordingStatus", "Recording started", "success");
        this.showStatus("startRecordingStatus", false);
    }

    setupRecorder(type, filename) {
        this.recording.mediaRecorder.ondataavailable = (event) => {
            this.recording.chunks.push(event.data);
        };

        this.recording.mediaRecorder.onstop = () => {
            this.recording.blob = new Blob(this.recording.chunks, { type: `video/${type}` });
            this.recording.url = URL.createObjectURL(this.recording.blob);
            this.downloadFile(this.recording.url, filename);
        };

        this.recording.mediaRecorder.start();
        setTimeout(() => this.stopRecording(), 120000);
        this.recording.isRecording = true;
        console.log(`Recording started in ${type} format...`);
    }

    stopRecording() {
        if (!this.recording.isRecording) {
            this.showMessage("stopRecordingStatus", "No recording in progress", "error");
            return;
        }

        this.showStatus("stopRecordingStatus", true);
        this.recording.mediaRecorder.stop();
        this.recording.isRecording = false;

        const indicator = document.getElementById("recordingIndicator");
        indicator.classList.add("hidden");
        if (this.recordingTimer) {
            clearInterval(this.recordingTimer);
            this.recordingTimer = null;
        }

        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.showMessage("stopRecordingStatus", "Recording stopped", "success");
        this.showStatus("stopRecordingStatus", false);
        console.log("Recording stopped...");
    }

    toggleRotate() {
        this.showStatus("toggleRotateStatus", true);
        this.controls.autoRotate = !this.controls.autoRotate;
        this.showMessage("toggleRotateStatus", this.controls.autoRotate ? "Auto-rotate enabled" : "Auto-rotate disabled", "success");
        this.showStatus("toggleRotateStatus", false);
        console.log(this.controls.autoRotate ? "🔄 Auto-rotate enabled" : "🛑 Auto-rotate disabled");
    }

    rotateScene(angle) {
        this.showStatus("prevPageStatus", true);
        this.scene.rotation.y += angle;
        this.showMessage("prevPageStatus", "Rotated left", "success");
        this.showStatus("prevPageStatus", false);

        this.showStatus("nextPageStatus", true);
        this.scene.rotation.y += angle;
        this.showMessage("nextPageStatus", "Rotated right", "success");
        this.showStatus("nextPageStatus", false);
    }

    handleResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        console.log("🔄 Window resized");
    }

    downloadFile(data, filename) {
        const link = document.createElement("a");
        link.href = data;
        link.download = filename;
        link.click();
    }

    showStatus(statusId, show) {
        const statusElement = document.getElementById(statusId);
        if (statusElement) {
            statusElement.classList.toggle("hidden", !show);
            if (show) {
                statusElement.classList.remove("success", "error");
                statusElement.classList.add("loading");
                statusElement.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            } else {
                statusElement.classList.remove("loading");
            }
        }
    }

    showMessage(statusId, message, type) {
        const statusElement = document.getElementById(statusId);
        if (statusElement) {
            statusElement.classList.remove("hidden", "loading");
            statusElement.classList.add(type === "success" ? "success" : "error");
            statusElement.innerHTML = type === "success" ? '<i class="fas fa-check"></i>' : '<i class="fas fa-exclamation-triangle"></i>';
            statusElement.setAttribute("data-tooltip", message);

            setTimeout(() => {
                statusElement.classList.add("hidden");
                statusElement.removeAttribute("data-tooltip");
                statusElement.classList.remove("success", "error");
            }, 3000);
        }
    }
}

const app = new ThreeJSApp();
app.init();







SPHERE 2

import * as THREE from "three";
import { OrbitControls } from "OrbitControls";

class ThreeJSApp {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 0, 3);

        this.renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true,
            preserveDrawingBuffer: true
        });
        this.renderer.setClearColor(0x000000, 0.2);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);
        document.body.style.backgroundColor = "#0f0f1a";

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enableZoom = true;
        this.controls.minDistance = 0.1;
        this.controls.maxDistance = 10;
        this.controls.enablePan = false;
        this.controls.autoRotate = false;
        this.controls.autoRotateSpeed = 1.0;

        this.images = [];
        this.radius = 5;
        this.sessionId = localStorage.getItem('sessionId');
        this.textureLoader = new THREE.TextureLoader();

        // Audio setup
        this.audioListener = new THREE.AudioListener();
        this.camera.add(this.audioListener);
        this.backgroundAudio = new THREE.Audio(this.audioListener);
        this.clickSound = new THREE.Audio(this.audioListener);
        this.shuffleSound = new THREE.Audio(this.audioListener);

        this.recording = {
            mediaRecorder: null,
            chunks: [],
            isRecording: false,
            blob: null,
            url: null
        };
        this.isRemoveActive = false;
        this.is360View = false;
        this.isSphericalMap = false;
        this.sphereMesh = null;
        this.spherePatches = [];
        this.controlsVisible = true;

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.selectedMesh = null;
        this.focusedMesh = null;
    }

    addLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0x00d4ff, 1, 10);
        pointLight.position.set(0, 0, 0);
        this.scene.add(pointLight);
    }

    addBackgroundEnvironment() {
        this.loadEnvironmentMap('https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg');
    }

    loadEnvironmentMap(url) {
        this.textureLoader.load(
            url,
            (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                this.scene.background = texture;
                console.log("🌌 Background environment map loaded from:", url);
            },
            undefined,
            (err) => console.error("❌ Error loading environment map:", err)
        );
    }

    setupAudio() {
        this.textureLoader.manager.onLoad = () => {
            this.backgroundAudio.setBuffer(this.loadAudio('path/to/ambient-background.mp3'));
            this.backgroundAudio.setLoop(true);
            this.backgroundAudio.setVolume(0.3);
            this.backgroundAudio.play();
            console.log("🎶 Background audio started");
        };

        this.clickSound.setBuffer(this.loadAudio('path/to/click-sound.mp3'));
        this.clickSound.setVolume(0.5);

        this.shuffleSound.setBuffer(this.loadAudio('path/to/shuffle-sound.mp3'));
        this.shuffleSound.setVolume(0.5);
    }

    loadAudio(url) {
        const audioLoader = new THREE.AudioLoader();
        let buffer;
        audioLoader.load(url, (audioBuffer) => {
            buffer = audioBuffer;
        });
        return buffer;
    }

    init() {
        console.log("🚀 Three.js script loaded");
        this.addLighting();
        this.addBackgroundEnvironment();
        this.setupAudio();
        this.setupEventListeners();
        if (this.sessionId) {
            this.loadImages(this.sessionId);
        }
        this.animate();
        window.addEventListener("resize", () => this.handleResize());
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        if (this.controls.autoRotate) {
            this.controls.update();
        } else if (!this.is360View && !this.isSphericalMap && this.autoRotate) {
            this.scene.rotation.y += 0.005;
        }
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }

    setupEventListeners() {
        document.getElementById("downloadBtn").addEventListener("click", () => this.handleDownload());
        document.getElementById("zoomSlider").addEventListener("input", () => this.handleZoom());
        document.getElementById("radiusSlider").addEventListener("input", () => this.handleRadius());
        document.getElementById("screenshotForm").addEventListener("submit", (e) => this.handleScreenshotSubmit(e));
        document.getElementById("uploadForm").addEventListener("submit", (e) => this.handleUploadSubmit(e));
        document.getElementById("startRecordingBtn").addEventListener("click", () => this.startRecording());
        document.getElementById("stopRecordingBtn").addEventListener("click", () => this.stopRecording());
        document.getElementById("toggleRotateBtn").addEventListener("click", () => this.toggleRotate());
        document.getElementById("shuffleBtn").addEventListener("click", () => this.shuffleImages());
        document.getElementById("prevPage").addEventListener("click", () => this.rotateScene(-Math.PI / 8));
        document.getElementById("nextPage").addEventListener("click", () => this.rotateScene(Math.PI / 8));
        document.getElementById("toggleViewBtn").addEventListener("click", () => this.toggleViewMode());
        document.getElementById("toggleControlsBtn").addEventListener("click", () => this.toggleControls());
        document.getElementById("toggleSphericalMapBtn").addEventListener("click", () => this.toggleSphericalMap());

        this.renderer.domElement.addEventListener("click", (event) => this.onCanvasClick(event));
        this.renderer.domElement.addEventListener("dblclick", (event) => this.onDoubleClick(event));
        this.renderer.domElement.addEventListener("mousemove", (event) => this.onMouseMove(event));
        this.renderer.domElement.addEventListener("touchstart", (event) => this.onTouchStart(event));
        this.renderer.domElement.addEventListener("touchmove", (event) => this.onTouchMove(event));

        document.getElementById("toggleRemoveBtn").addEventListener("click", () => this.toggleRemove());
        document.getElementById("removeBtn").addEventListener("click", () => this.removeSelectedImage());
        document.getElementById("removeAllBtn").addEventListener("click", () => this.removeAllImages());

        document.getElementById("images").addEventListener("change", (event) => this.showImagePreviews(event));
        document.getElementById("envMapInput").addEventListener("change", (event) => this.handleEnvMapUpload(event));
    }

    handleEnvMapUpload(event) {
        const file = event.target.files[0];
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const url = e.target.result;
                this.loadEnvironmentMap(url);
                console.log("🌌 User uploaded new environment map");
            };
            reader.readAsDataURL(file);
        } else {
            console.error("❌ Please upload a valid image file for the environment map");
            this.showMessage("toggleViewStatus", "Invalid file type. Please upload an image.", "error");
        }
    }

    toggleControls() {
        this.controlsVisible = !this.controlsVisible;
        const controlPanels = document.querySelectorAll(".control-panel");
        const toggleButton = document.getElementById("toggleControlsBtn");

        controlPanels.forEach(panel => {
            panel.classList.toggle("hidden-panel", !this.controlsVisible);
        });

        toggleButton.textContent = this.controlsVisible ? "Hide Controls" : "Show Controls";
        toggleButton.querySelector("i").className = this.controlsVisible ? "fas fa-eye" : "fas fa-eye-slash";
        console.log(this.controlsVisible ? "🖥️ Controls visible" : "🖥️ Controls hidden");
    }

    onMouseMove(event) {
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    onTouchStart(event) {
        const touch = event.touches[0];
        this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        this.onCanvasClick(event);
    }

    onTouchMove(event) {
        event.preventDefault();
        const touch = event.touches[0];
        this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
        this.scene.rotation.y += (touch.clientX - this.lastTouchX) * 0.005;
        this.lastTouchX = touch.clientX;
    }

    onDoubleClick(event) {
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.scene.children, true);

        if (intersects.length > 0) {
            const intersectedObject = intersects[0].object;
            if (intersectedObject.userData.filename) {
                if (this.focusedMesh === intersectedObject) {
                    this.focusedMesh.scale.set(1, 1, 1);
                    this.focusedMesh.material.uniforms.opacity.value = 1;
                    this.focusedMesh = null;
                    this.images.forEach(img => {
                        img.mesh.material.uniforms.opacity.value = 1;
                    });
                    this.showMessage("toggleViewStatus", "View reset", "success");
                } else {
                    if (this.focusedMesh) {
                        this.focusedMesh.scale.set(1, 1, 1);
                        this.focusedMesh.material.uniforms.opacity.value = 1;
                    }

                    this.focusedMesh = intersectedObject;
                    this.focusedMesh.scale.set(2, 2, 2);
                    this.focusedMesh.material.uniforms.opacity.value = 1;

                    this.images.forEach(img => {
                        if (img.mesh !== this.focusedMesh) {
                            img.mesh.material.uniforms.opacity.value = 0.3;
                        }
                    });
                    this.showMessage("toggleViewStatus", "Image focused", "success");
                }
            }
        } else if (this.focusedMesh) {
            this.focusedMesh.scale.set(1, 1, 1);
            this.focusedMesh.material.uniforms.opacity.value = 1;
            this.focusedMesh = null;
            this.images.forEach(img => {
                img.mesh.material.uniforms.opacity.value = 1;
            });
            this.showMessage("toggleViewStatus", "View reset", "success");
        }
    }

    onCanvasClick(event) {
        if (!this.isRemoveActive) return;

        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.scene.children, true);

        if (intersects.length > 0) {
            const intersectedObject = intersects[0].object;
            if (intersectedObject.userData.onClick) {
                this.selectedMesh = intersectedObject;
                this.showRemoveButton(intersectedObject);
                if (!this.clickSound.isPlaying) {
                    this.clickSound.play();
                }
            }
        }
    }

    toggleRemove() {
        this.showStatus("toggleRemoveStatus", true);
        this.isRemoveActive = !this.isRemoveActive;
        const removeControls = document.getElementById("removeControls");
        setTimeout(() => {
            removeControls.classList.toggle("hidden", !this.isRemoveActive);
            this.showMessage("toggleRemoveStatus", this.isRemoveActive ? "Remove mode enabled" : "Remove mode disabled", "success");
            this.showStatus("toggleRemoveStatus", false);
        }, 500);
    }

    hideAllRemoveButtons() {
        const removeButtons = document.querySelectorAll("button[style*='Remove']");
        removeButtons.forEach(btn => btn.remove());
        this.images.forEach(img => {
            img.mesh.userData.buttonCreated = false;
        });
    }

    removeSelectedImage() {
        if (this.selectedMesh) {
            this.showStatus("removeSelectedStatus", true);
            this.removeImage(this.selectedMesh);
            this.hideAllRemoveButtons();
            this.selectedMesh = null;
            this.showMessage("removeSelectedStatus", "Image removed", "success");
            this.showStatus("removeSelectedStatus", false);
        } else {
            this.showMessage("removeSelectedStatus", "No image selected for removal", "error");
        }
    }

    removeAllImages() {
        this.showStatus("removeAllStatus", true);
        while (this.scene.children.length > 2) {
            const child = this.scene.children[2];
            this.scene.remove(child);
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        }
        this.images = [];
        this.spherePatches = [];
        console.log("🗑️ All images removed");
        this.showMessage("removeAllStatus", "All images removed", "success");
        this.showStatus("removeAllStatus", false);
    }

    toggleViewMode() {
        this.showStatus("toggleViewStatus", true);
        if (!this.is360View && !this.isSphericalMap) {
            this.is360View = true;
            this.isSphericalMap = false;
            console.log("🔄 Switched to 360-degree view");
        } else if (this.is360View && !this.isSphericalMap) {
            this.is360View = false;
            this.isSphericalMap = true;
            console.log("🌍 Switched to Spherical Map view");
        } else {
            this.is360View = false;
            this.isSphericalMap = false;
            console.log("🔄 Switched to 3D view");
        }

        if (this.isSphericalMap) {
            this.camera.position.set(0, 0, this.radius * 2);
            this.controls.maxDistance = this.radius * 3;
            this.controls.minDistance = this.radius + 0.1;
            this.controls.enablePan = false;
            this.updateSphericalMap();
        } else if (this.is360View) {
            this.camera.position.set(0, 0, 0);
            this.controls.maxDistance = 10;
            this.controls.minDistance = 0.1;
            this.controls.enablePan = false;
            this.updateImagePositions();
        } else {
            this.camera.position.set(0, 0, 3);
            this.controls.maxDistance = 5;
            this.controls.minDistance = 2;
            this.controls.enablePan = false;
            this.updateImagePositions();
        }
        
        this.camera.updateProjectionMatrix();
        this.showMessage("toggleViewStatus", 
            this.isSphericalMap ? "Switched to Spherical Map view" : 
            this.is360View ? "Switched to 360 view" : "Switched to 3D view", 
            "success"
        );
        this.showStatus("toggleViewStatus", false);
    }

    toggleSphericalMap() {
        this.showStatus("toggleSphericalMapStatus", true);
        this.isSphericalMap = !this.isSphericalMap;
        
        console.log("Toggling spherical map:", this.isSphericalMap ? "Enabled" : "Disabled");
        if (this.isSphericalMap) {
            this.is360View = false;
            this.camera.position.set(0, 0, this.radius * 2);
            this.controls.maxDistance = this.radius * 3;
            this.controls.minDistance = this.radius + 0.1;
            this.updateSphericalMap();
        } else {
            this.is360View = false;
            this.camera.position.set(0, 0, 3);
            this.controls.maxDistance = 5;
            this.controls.minDistance = 2;
            this.updateImagePositions();
        }
        
        this.camera.updateProjectionMatrix();
        this.showMessage("toggleSphericalMapStatus", 
            this.isSphericalMap ? "Spherical Map enabled" : "Spherical Map disabled", 
            "success"
        );
        this.showStatus("toggleSphericalMapStatus", false);
    }

    createSphericalMap() {
        // Remove existing sphere and patches
        if (this.sphereMesh) {
            this.scene.remove(this.sphereMesh);
            this.sphereMesh.geometry.dispose();
            this.sphereMesh.material.dispose();
            this.sphereMesh = null;
        }

        // Remove existing patches
        this.spherePatches.forEach(patch => {
            this.scene.remove(patch.mesh);
            patch.mesh.geometry.dispose();
            patch.mesh.material.dispose();
        });
        this.spherePatches = [];

        console.log("Creating spherical map...");

        // Create the base sphere with a fallback texture
        const geometry = new THREE.SphereGeometry(this.radius, 32, 32);
        const material = new THREE.MeshBasicMaterial({
            color: 0x808080, // Gray color to confirm the sphere renders
            side: THREE.DoubleSide,
        });

        this.sphereMesh = new THREE.Mesh(geometry, material);
        this.scene.add(this.sphereMesh);
        console.log("Base sphere created with gray color");

        if (this.images.length === 0) {
            console.warn("No images available to map onto the sphere");
            return;
        }

        console.log("Current images:", this.images);

        // Map each screenshot as a small patch on the sphere
        const totalImages = this.images.length;
        const goldenRatio = (Math.sqrt(5) + 1) / 2;

        for (let index = 0; index < totalImages; index++) {
            const texture = this.images[index].mesh.material.uniforms.map.value;
            const filename = this.images[index].filename;

            if (!texture) {
                console.warn(`Texture for image ${filename} is not available`);
                continue;
            }

            // Calculate position using spherical coordinates
            const y = 1 - (index / (totalImages - 1)) * 2; // Distribute vertically
            const radiusAtY = Math.sqrt(1 - y * y);
            const theta = goldenRatio * index * Math.PI * 2; // Distribute horizontally
            const phi = Math.acos(y);

            const x = this.radius * Math.sin(phi) * Math.cos(theta);
            const yPos = this.radius * Math.cos(phi);
            const z = this.radius * Math.sin(phi) * Math.sin(theta);

            // Create a small plane for the screenshot
            const aspectRatio = texture.image.width / texture.image.height;
            const planeHeight = 1.0; // Increased size for visibility
            const planeWidth = planeHeight * aspectRatio;

            const planeGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const planeMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide,
            });

            const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
            planeMesh.position.set(x, yPos, z);
            planeMesh.lookAt(new THREE.Vector3(0, 0, 0)); // Face the center of the sphere
            planeMesh.userData = { filename, buttonCreated: false };
            planeMesh.userData.onClick = () => this.showRemoveButton(planeMesh);

            this.scene.add(planeMesh);
            this.spherePatches.push({ mesh: planeMesh, filename });

            console.log(`🖼️ Added screenshot patch: ${filename} at position (${x}, ${yPos}, ${z})`);
        }

        console.log("Total patches added:", this.spherePatches.length);
        console.log("Scene children after adding patches:", this.scene.children.length);
    }

    updateSphericalMap() {
        console.log("Updating spherical map...");
        if (!this.isSphericalMap) {
            console.log("Not in spherical map mode, skipping update");
            return;
        }

        if (!this.imagesToLoad || this.imagesToLoad.length === 0) {
            console.warn("No images to load for spherical map");
            this.clearScene();
            this.createSphericalMap();
            return;
        }

        this.clearScene();
        this.createSphericalMap();
    }

    async loadImages(sessionId) {
        this.clearScene();

        try {
            this.showStatus("toggleViewStatus", true);
            const response = await fetch(`http://localhost:3000/api/screenshots/${sessionId}/`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            if (!data.screenshots?.length) {
                this.showMessage("toggleViewStatus", "No screenshots found", "error");
                return;
            }

            data.screenshots.sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
            this.imagesToLoad = data.screenshots;
            console.log("Images to load:", this.imagesToLoad);
            this.updateImagePositions();
            this.showMessage("toggleViewStatus", "Images loaded successfully", "success");
        } catch (error) {
            console.error("❌ Error fetching images:", error);
            this.showMessage("toggleViewStatus", `Failed to load images: ${error.message}`, "error");
        } finally {
            this.showStatus("toggleViewStatus", false);
        }
    }

    clearScene() {
        while (this.scene.children.length > 2) {
            const child = this.scene.children[2];
            this.scene.remove(child);
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        }
        this.images = [];
        this.spherePatches = [];
        console.log("🗑️ Scene cleared");
    }

    async addImage(filename, theta, phiOrIndex) {
        try {
            const texture = await this.loadTexture(filename);
            const aspectRatio = texture.image.width / texture.image.height;
            const planeHeight = this.is360View ? 1.5 : window.innerHeight / 300;
            const planeWidth = planeHeight * aspectRatio;

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    map: { value: texture },
                    opacity: { value: 1.0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D map;
                    uniform float opacity;
                    varying vec2 vUv;
                    void main() {
                        vec4 tex = texture2D(map, vUv);
                        if (!gl_FrontFacing) {
                            tex = texture2D(map, vec2(1.0 - vUv.x, vUv.y));
                        }
                        gl_FragColor = vec4(tex.rgb, tex.a * opacity);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });

            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const mesh = new THREE.Mesh(geometry, material);

            if (this.is360View) {
                const x = this.radius * Math.sin(phiOrIndex) * Math.cos(theta);
                const y = this.radius * Math.cos(phiOrIndex);
                const z = this.radius * Math.sin(phiOrIndex) * Math.sin(theta);
                mesh.position.set(x, y, z);
            } else {
                const angle = theta;
                const x = this.radius * Math.cos(angle);
                const z = this.radius * Math.sin(angle);
                mesh.position.set(x, 0, z);
            }
            mesh.lookAt(0, 0, 0);
            mesh.userData = { filename, buttonCreated: false };
            mesh.userData.onClick = () => this.showRemoveButton(mesh);

            this.scene.add(mesh);
            this.images.push({ mesh, filename });

            console.log(`🛠 Layer added: ${filename} at position (${mesh.position.x}, ${mesh.position.y}, ${mesh.position.z})`);
            console.log("Images array updated:", this.images);
        } catch (error) {
            console.warn(`⚠ Skipping texture: ${filename}`, error);
        }
    }

    loadTexture(filename) {
        return new Promise((resolve, reject) => {
            this.textureLoader.load(
                filename,
                (texture) => {
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
                    console.log("Texture loaded successfully:", filename);
                    resolve(texture);
                },
                undefined,
                (err) => {
                    console.error("Error loading texture:", filename, err);
                    reject(err);
                }
            );
        });
    }

    updateImagePositions() {
        this.clearScene();

        if (!this.imagesToLoad || this.imagesToLoad.length === 0) {
            console.warn("No images to position");
            return;
        }

        console.log("Updating image positions for mode:", this.isSphericalMap ? "Spherical" : this.is360View ? "360" : "3D");
        if (this.isSphericalMap) {
            this.updateSphericalMap();
        } else {
            const totalImages = this.imagesToLoad.length;
            const goldenRatio = (Math.sqrt(5) + 1) / 2;

            if (this.is360View) {
                for (let index = 0; index < totalImages; index++) {
                    const y = 1 - (index / (totalImages - 1)) * 2;
                    const radiusAtY = Math.sqrt(1 - y * y);
                    const theta = goldenRatio * index * Math.PI * 2;
                    const phi = Math.acos(y);
                    this.addImage(this.imagesToLoad[index], theta, phi);
                }
            } else {
                const angleIncrement = (2 * Math.PI) / totalImages;
                for (let index = 0; index < totalImages; index++) {
                    const angle = index * angleIncrement;
                    this.addImage(this.imagesToLoad[index], angle, angleIncrement);
                }
            }
        }
    }

    shuffleImages() {
        if (this.images.length === 0) {
            this.showMessage("shuffleStatus", "No images to shuffle", "error");
            return;
        }

        this.showStatus("shuffleStatus", true);
        this.images = this.images.sort(() => Math.random() - 0.5);
        this.imagesToLoad = this.images.map(img => img.mesh.userData.filename);
        this.updateImagePositions();
        if (!this.shuffleSound.isPlaying) {
            this.shuffleSound.play();
        }
        this.showMessage("shuffleStatus", "Images shuffled successfully", "success");
        this.showStatus("shuffleStatus", false);
    }

    removeImage(mesh) {
        this.scene.remove(mesh);
        this.images = this.images.filter(img => img.mesh !== mesh);
        this.spherePatches = this.spherePatches.filter(patch => patch.mesh !== mesh);
        this.imagesToLoad = this.images.map(img => img.mesh.userData.filename);
        console.log(`🗑️ Removed image: ${mesh.userData.filename}`);
        this.updateImagePositions();
    }

    showRemoveButton(mesh) {
        if (!this.isRemoveActive || mesh.userData.buttonCreated) return;

        const removeBtn = document.createElement("button");
        removeBtn.textContent = "Remove";
        removeBtn.style.cssText = `
            position: absolute;
            z-index: 1000;
            padding: 8px 12px;
            background: rgba(220, 53, 69, 0.8);
            color: #fff;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 0.8rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s ease;
        `;
        document.body.appendChild(removeBtn);

        const updateButtonPosition = () => {
            const screenPos = new THREE.Vector3();
            mesh.getWorldPosition(screenPos);
            screenPos.project(this.camera);

            const xPos = (screenPos.x + 1) / 2 * window.innerWidth;
            const yPos = (1 - screenPos.y) / 2 * window.innerHeight;

            removeBtn.style.left = `${xPos}px`;
            removeBtn.style.top = `${yPos - 30}px`;
            removeBtn.style.display = "block";
        };

        updateButtonPosition();

        const updateLoop = () => {
            if (this.isRemoveActive) {
                updateButtonPosition();
            } else {
                removeBtn.remove();
                mesh.userData.buttonCreated = false;
                return;
            }
            requestAnimationFrame(updateLoop);
        };
        updateLoop();

        removeBtn.addEventListener("click", () => {
            this.removeImage(mesh);
            removeBtn.remove();
            mesh.userData.buttonCreated = false;
        });

        removeBtn.addEventListener("mouseover", () => {
            removeBtn.style.opacity = "0.8";
            removeBtn.style.transform = "scale(1.05)";
        });
        removeBtn.addEventListener("mouseout", () => {
            removeBtn.style.opacity = "1";
            removeBtn.style.transform = "scale(1)";
        });

        mesh.userData.buttonCreated = true;
    }

    handleDownload() {
        this.showStatus("downloadStatus", true);
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        const highResWidth = Math.max(screenWidth * 2, 1920);
        const highResHeight = Math.max(screenHeight * 2, 1080);

        const originalSize = { width: this.renderer.domElement.width, height: this.renderer.domElement.height };
        this.renderer.setSize(highResWidth, highResHeight, false);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.render(this.scene, this.camera);

        const imgData = this.renderer.domElement.toDataURL("image/png", 1.0);

        this.renderer.setSize(originalSize.width, originalSize.height, false);
        this.renderer.render(this.scene, this.camera);

        this.downloadFile(imgData, "rendered_high_res_image.png");
        this.showMessage("downloadStatus", "Image downloaded successfully", "success");
        this.showStatus("downloadStatus", false);
    }

    handleZoom() {
        const zoomSlider = document.getElementById("zoomSlider");
        const zoomValue = document.getElementById("zoomValue");
        const zoomLevel = parseFloat(zoomSlider.value);
        zoomValue.textContent = zoomLevel.toFixed(1);
        this.controls.maxDistance = zoomLevel;
        this.controls.update();
        if (!this.is360View && !this.isSphericalMap) {
            this.camera.position.z = zoomLevel;
            this.camera.updateProjectionMatrix();
        }
        console.log(`🔍 Zoom level updated: ${zoomLevel}`);
    }

    handleRadius() {
        const radiusSlider = document.getElementById("radiusSlider");
        const radiusValue = document.getElementById("radiusValue");
        this.radius = parseFloat(radiusSlider.value);
        radiusValue.textContent = this.radius.toFixed(1);
        this.updateImagePositions();
    }

    async handleScreenshotSubmit(event) {
        event.preventDefault();
        const url = document.getElementById("url").value;
        if (!url) {
            this.showMessage("screenshotStatus", "Please enter a valid URL", "error");
            return;
        }

        this.showStatus("screenshotStatus", true);

        try {
            const response = await fetch("http://localhost:3000/api/capture", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url })
            });
            
            const result = await response.json();
            if (result.sessionId) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.showMessage("screenshotStatus", `Screenshots captured for ${url}`, "success");
                this.loadImages(this.sessionId);
            } else {
                this.showMessage("screenshotStatus", "Failed to capture screenshot", "error");
            }
        } catch (error) {
            console.error("Error:", error);
            this.showMessage("screenshotStatus", `Failed to capture screenshot: ${error.message}`, "error");
        } finally {
            this.showStatus("screenshotStatus", false);
        }
    }

    async handleUploadSubmit(event) {
        event.preventDefault();
        const sessionId = this.sessionId || null;
        const fileInput = document.getElementById("images");
        if (!fileInput.files?.length) {
            this.showMessage("uploadStatus", "Please select at least one image to upload", "error");
            return;
        }

        this.showStatus("uploadStatus", true);

        const formData = new FormData();
        for (const file of fileInput.files) {
            formData.append("images", file);
        }

        try {
            const response = await fetch(`http://localhost:3000/api/upload${sessionId ? `/${sessionId}` : ''}`, {
                method: "POST",
                body: formData
            });
            
            const result = await response.json();
            if (result.success) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.showMessage("uploadStatus", `Uploaded ${result.filePaths.length} images successfully`, "success");
                this.loadImages(this.sessionId);
            } else {
                this.showMessage("uploadStatus", `Upload failed: ${result.error || "Unknown error"}`, "error");
            }
        } catch (error) {
            console.error("Error uploading files:", error);
            this.showMessage("uploadStatus", `Failed to upload images: ${error.message}`, "error");
        } finally {
            this.showStatus("uploadStatus", false);
        }
    }

    showImagePreviews(event) {
        const files = event.target.files;
        const previewContainer = document.getElementById("previewContainer");
        previewContainer.innerHTML = "";

        for (const file of files) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = document.createElement("img");
                img.src = e.target.result;
                img.classList.add("preview-thumbnail");
                img.addEventListener("click", () => {
                    console.log(`Clicked preview for ${file.name}`);
                });
                previewContainer.appendChild(img);
            };
            reader.readAsDataURL(file);
        }
    }

    startRecording() {
        if (this.recording.isRecording) {
            this.showMessage("startRecordingStatus", "Recording already in progress", "error");
            return;
        }

        this.showStatus("startRecordingStatus", true);
        this.recording.chunks = [];
        this.renderer.setSize(1920, 1080);
        const stream = this.renderer.domElement.captureStream(30);

        try {
            this.recording.mediaRecorder = new MediaRecorder(stream, { mimeType: "video/mp4" });
            this.setupRecorder("mp4", "360-video.mp4");
        } catch (e) {
            console.error("MP4 recording failed, switching to WebM.", e);
            this.recording.mediaRecorder = new MediaRecorder(stream, { mimeType: "video/webm" });
            this.setupRecorder("webm", "360-video.webm");
        }

        const indicator = document.getElementById("recordingIndicator");
        indicator.classList.remove("hidden");
        indicator.textContent = "Recording... (2 minutes remaining)";

        let timeLeft = 120;
        this.recordingTimer = setInterval(() => {
            timeLeft--;
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            indicator.textContent = `Recording... (${minutes}:${seconds < 10 ? '0' : ''}${seconds} remaining)`;
            if (timeLeft <= 0) {
                clearInterval(this.recordingTimer);
                this.stopRecording();
            }
        }, 1000);
        this.showMessage("startRecordingStatus", "Recording started", "success");
        this.showStatus("startRecordingStatus", false);
    }

    setupRecorder(type, filename) {
        this.recording.mediaRecorder.ondataavailable = (event) => {
            this.recording.chunks.push(event.data);
        };

        this.recording.mediaRecorder.onstop = () => {
            this.recording.blob = new Blob(this.recording.chunks, { type: `video/${type}` });
            this.recording.url = URL.createObjectURL(this.recording.blob);
            this.downloadFile(this.recording.url, filename);
        };

        this.recording.mediaRecorder.start();
        setTimeout(() => this.stopRecording(), 120000);
        this.recording.isRecording = true;
        console.log(`Recording started in ${type} format...`);
    }

    stopRecording() {
        if (!this.recording.isRecording) {
            this.showMessage("stopRecordingStatus", "No recording in progress", "error");
            return;
        }

        this.showStatus("stopRecordingStatus", true);
        this.recording.mediaRecorder.stop();
        this.recording.isRecording = false;

        const indicator = document.getElementById("recordingIndicator");
        indicator.classList.add("hidden");
        if (this.recordingTimer) {
            clearInterval(this.recordingTimer);
            this.recordingTimer = null;
        }

        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.showMessage("stopRecordingStatus", "Recording stopped", "success");
        this.showStatus("stopRecordingStatus", false);
        console.log("Recording stopped...");
    }

    toggleRotate() {
        this.showStatus("toggleRotateStatus", true);
        this.controls.autoRotate = !this.controls.autoRotate;
        this.showMessage("toggleRotateStatus", this.controls.autoRotate ? "Auto-rotate enabled" : "Auto-rotate disabled", "success");
        this.showStatus("toggleRotateStatus", false);
        console.log(this.controls.autoRotate ? "🔄 Auto-rotate enabled" : "🛑 Auto-rotate disabled");
    }

    rotateScene(angle) {
        this.showStatus("prevPageStatus", true);
        this.scene.rotation.y += angle;
        this.showMessage("prevPageStatus", "Rotated left", "success");
        this.showStatus("prevPageStatus", false);

        this.showStatus("nextPageStatus", true);
        this.scene.rotation.y += angle;
        this.showMessage("nextPageStatus", "Rotated right", "success");
        this.showStatus("nextPageStatus", false);
    }

    handleResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        console.log("🔄 Window resized");
    }

    downloadFile(data, filename) {
        const link = document.createElement("a");
        link.href = data;
        link.download = filename;
        link.click();
    }

    showStatus(statusId, show) {
        const statusElement = document.getElementById(statusId);
        if (statusElement) {
            statusElement.classList.toggle("hidden", !show);
            if (show) {
                statusElement.classList.remove("success", "error");
                statusElement.classList.add("loading");
                statusElement.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            } else {
                statusElement.classList.remove("loading");
            }
        }
    }

    showMessage(statusId, message, type) {
        const statusElement = document.getElementById(statusId);
        if (statusElement) {
            statusElement.classList.remove("hidden", "loading");
            statusElement.classList.add(type === "success" ? "success" : "error");
            statusElement.innerHTML = type === "success" ? '<i class="fas fa-check"></i>' : '<i class="fas fa-exclamation-triangle"></i>';
            statusElement.setAttribute("data-tooltip", message);
            
            setTimeout(() => {
                statusElement.classList.add("hidden");
                statusElement.removeAttribute("data-tooltip");
                statusElement.classList.remove("success", "error");
            }, 3000);
        }
    }
}

const app = new ThreeJSApp();
app.init();




#BACKEND OLD STABLE VERSION


import puppeteer from 'puppeteer-extra';
import StealthPlugin from 'puppeteer-extra-plugin-stealth';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import express from 'express';
import cors from 'cors';
import { v4 as uuidv4 } from 'uuid';
import multer from 'multer';

puppeteer.use(StealthPlugin());

class ScreenshotServer {
    constructor() {
        this.__filename = fileURLToPath(import.meta.url);
        this.__dirname = path.dirname(this.__filename);
        this.app = express();
        this.PORT = 3000;
        this.outputDir = path.join(this.__dirname, 'screenshots');
        this.upload = this.configureMulter();
    }

    async init() {
        try {
            await fs.ensureDir(this.outputDir);
            console.log('🗂 Base screenshot directory ensured:', this.outputDir);

            // Verify write permissions
            const testFile = path.join(this.outputDir, 'test.txt');
            await fs.writeFile(testFile, 'test');
            await fs.unlink(testFile);
            console.log('✅ Write permissions confirmed for outputDir');
        } catch (error) {
            console.error('❌ No write permissions for outputDir:', error);
            process.exit(1);
        }

        this.setupMiddleware();
        this.setupRoutes();
        this.startServer();
    }

    setupMiddleware() {
        this.app.use(cors());
        this.app.use(express.json());
        this.app.use(express.urlencoded({ extended: true }));
        this.app.use(express.static(path.join(this.__dirname, 'public')));
        this.app.use('/screenshots', express.static(this.outputDir));
    }

    configureMulter() {
        return multer({ storage: multer.memoryStorage() });
    }

    setupRoutes() {
        this.app.get('/api/screenshots/:sessionId', async (req, res) => this.handleGetScreenshots(req, res));
        this.app.post('/api/capture', async (req, res) => this.handleCapture(req, res));
        this.app.post('/api/upload/:sessionId?', this.upload.array('images'), (req, res) => this.handleUpload(req, res));
    }

    startServer() {
        this.app.listen(this.PORT, () => {
            console.log(`🚀 Server running at http://localhost:${this.PORT}`);
        });
    }

    async handleGetScreenshots(req, res) {
        const { sessionId } = req.params;
        const sessionDir = path.join(this.outputDir, sessionId);

        try {
            if (!fs.existsSync(sessionDir)) {
                return res.status(404).json({ error: 'Session not found' });
            }

            const files = await fs.readdir(sessionDir);
            const imageFiles = files.filter(file => file.match(/\.(png|jpg|jpeg)$/i));
            const screenshotUrls = imageFiles.map(file => `/screenshots/${sessionId}/${file}`);
            console.log(`📸 Found ${imageFiles.length} images in session ${sessionId}:`, screenshotUrls);
            res.json({ screenshots: screenshotUrls });
        } catch (error) {
            console.error('❌ Error fetching screenshots:', error);
            res.status(500).json({ error: 'Failed to retrieve screenshots' });
        }
    }

    async handleCapture(req, res) {
        const { url } = req.body;
        if (!url) {
            return res.status(400).json({ error: 'URL is required' });
        }

        const sessionId = uuidv4();
        const sessionDir = path.join(this.outputDir, sessionId);

        await fs.ensureDir(sessionDir);
        console.log(`🌐 Capturing new screenshots for: ${url} in session: ${sessionId}`);

        try {
            await this.captureMockup(url, sessionDir);
            res.json({ success: true, message: `Screenshots captured for ${url}`, sessionId });
        } catch (error) {
            console.error('❌ Screenshot capture failed:', error);
            res.status(500).json({ error: 'Failed to capture screenshot' });
        }
    }

    async handleUpload(req, res) {
        const sessionId = req.params.sessionId || uuidv4();
        const sessionDir = path.join(this.outputDir, sessionId);

        if (!req.files || req.files.length === 0) {
            return res.status(400).json({ error: 'No files uploaded' });
        }

        try {
            await fs.ensureDir(sessionDir);
            if (req.params.sessionId && fs.existsSync(sessionDir)) {
                await fs.emptyDir(sessionDir);
                console.log(`🗑️ Cleared existing files in session: ${sessionId}`);
            }

            console.log(`📤 Received ${req.files.length} files:`, req.files.map(f => ({
                originalname: f.originalname,
                mimetype: f.mimetype,
                size: f.size
            })));

            const filePaths = [];
            for (const file of req.files) {
                const filename = `${file.fieldname}-${Date.now()}-${Math.round(Math.random() * 1e9)}${path.extname(file.originalname)}`;
                const filePath = path.join(sessionDir, filename);
                await fs.writeFile(filePath, file.buffer);
                console.log(`✅ Saved: ${filePath}`);
                filePaths.push(`/screenshots/${sessionId}/${filename}`);
            }

            const filesAfterUpload = await fs.readdir(sessionDir);
            console.log(`📂 Files in directory: ${filesAfterUpload.length}`, filesAfterUpload);

            res.json({ 
                success: true, 
                message: `Uploaded ${req.files.length} images successfully`, 
                sessionId,
                filePaths 
            });
        } catch (error) {
            console.error('❌ Error handling upload:', error);
            res.status(500).json({ error: 'Failed to upload images', details: error.message });
        }
    }

    async captureMockup(url, sessionDir) {
        console.log(`🌐 Navigating to: ${url}`);

        const browser = await puppeteer.launch({
            headless: true,
            args: ['--no-sandbox', '--disable-setuid-sandbox']
        });

        const page = await browser.newPage();
        await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36');
        await page.setViewport({ width: 1440, height: 900 });

        await page.goto(url, { waitUntil: 'networkidle2' });

        try {
            await page.waitForSelector('button', { timeout: 5000 });
            const accepted = await page.evaluate(() => {
                const buttons = Array.from(document.querySelectorAll('button'));
                const acceptButton = buttons.find(btn => 
                    /accept|consent/i.test(btn.innerText)
                );
                if (acceptButton) {
                    acceptButton.click();
                    console.log(`✅ Clicked cookie button: ${acceptButton.innerText}`);
                    return true;
                }
                return false;
            });
            if (!accepted) console.log("⚠️ No consent button found.");
        } catch (error) {
            console.log("⚠️ No cookie popups detected.");
        }

        await new Promise(resolve => setTimeout(resolve, 4000));
        const totalHeight = await page.evaluate(() => document.body.scrollHeight);
        const viewportHeight = await page.viewport().height;
        let currentPosition = 0;
        let index = 0;

        while (currentPosition < totalHeight) {
            const screenshotPath = path.join(sessionDir, `section_${index}.png`);
            await new Promise(resolve => setTimeout(resolve, 5000));
            await page.screenshot({ path: screenshotPath, fullPage: false });
            console.log(`✅ Screenshot captured: ${screenshotPath}`);
            currentPosition += viewportHeight;
            await page.evaluate((scrollAmount) => window.scrollBy(0, scrollAmount), viewportHeight);
            await new Promise(resolve => setTimeout(resolve, 3000));
            index++;
        }

        await browser.close();
        console.log('📸 Screenshot capture completed.');
    }
}

const server = new ScreenshotServer();
server.init();




#VIRTUAL ART GALLLERY
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

class ThreeJSApp {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 1.6, 5); // Eye-level height, starting position

        this.renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true,
            preserveDrawingBuffer: true
        });
        this.renderer.setClearColor(0x000000, 0.2);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);
        document.body.style.backgroundColor = "#0f0f1a";

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enableZoom = true;
        this.controls.minDistance = 0.1;
        this.controls.maxDistance = 10;
        this.controls.enablePan = false;
        this.controls.screenSpacePanning = false;
        this.controls.maxPolarAngle = Math.PI / 2; // Limit vertical rotation

        this.images = [];
        this.sessionId = localStorage.getItem('sessionId');
        this.textureLoader = new THREE.TextureLoader();

        this.audioListener = new THREE.AudioListener();
        this.camera.add(this.audioListener);
        this.backgroundAudio = new THREE.Audio(this.audioListener);
        this.clickSound = new THREE.Audio(this.audioListener);

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.selectedMesh = null;

        this.rooms = [];
        this.currentRoom = 0;

        this.addLighting();
        this.createGallery();
        this.setupAudio();
        this.setupMovementControls();
    }

    addLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 10);
        this.scene.add(directionalLight);
    }

    createGallery() {
        // Create multiple rooms
        const roomGeometry = new THREE.BoxGeometry(10, 5, 10);
        const wallMaterial = new THREE.MeshPhongMaterial({ color: 0xeeeeee });
        const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });

        // Room 1
        const room1 = new THREE.Group();
        const floor1 = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), floorMaterial);
        floor1.rotation.x = -Math.PI / 2;
        floor1.position.y = 0;
        room1.add(floor1);

        const walls1 = [
            new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial), // Back wall
            new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial), // Front wall
            new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial), // Left wall
            new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial)  // Right wall
        ];
        walls1[0].position.set(0, 2.5, -5);
        walls1[1].position.set(0, 2.5, 5);
        walls1[1].rotation.y = Math.PI;
        walls1[2].position.set(-5, 2.5, 0);
        walls1[2].rotation.y = Math.PI / 2;
        walls1[3].position.set(5, 2.5, 0);
        walls1[3].rotation.y = -Math.PI / 2;

        walls1.forEach(wall => room1.add(wall));
        room1.position.set(0, 0, 0);
        this.rooms.push(room1);

        // Room 2 (connected to Room 1)
        const room2 = new THREE.Group();
        const floor2 = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), floorMaterial);
        floor2.rotation.x = -Math.PI / 2;
        floor2.position.y = 0;
        room2.add(floor2);

        const walls2 = [
            new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial)
        ];
        walls2[0].position.set(0, 2.5, -5);
        walls2[1].position.set(0, 2.5, 5);
        walls2[1].rotation.y = Math.PI;
        walls2[2].position.set(-5, 2.5, 0);
        walls2[2].rotation.y = Math.PI / 2;
        walls2[3].position.set(5, 2.5, 0);
        walls2[3].rotation.y = -Math.PI / 2;

        walls2.forEach(wall => room2.add(wall));
        room2.position.set(15, 0, 0); // Positioned to the right of Room 1
        this.rooms.push(room2);

        this.rooms.forEach(room => this.scene.add(room));
    }

    setupAudio() {
        this.backgroundAudio.setBuffer(this.loadAudio('path/to/ambient-gallery.mp3'));
        this.backgroundAudio.setLoop(true);
        this.backgroundAudio.setVolume(0.3);
        this.backgroundAudio.play();

        this.clickSound.setBuffer(this.loadAudio('path/to/click-sound.mp3'));
        this.clickSound.setVolume(0.5);
    }

    loadAudio(url) {
        const audioLoader = new THREE.AudioLoader();
        let buffer;
        audioLoader.load(url, (audioBuffer) => {
            buffer = audioBuffer;
        });
        return buffer;
    }

    init() {
        console.log("🚀 Virtual Gallery loaded");
        this.setupEventListeners();
        if (this.sessionId) {
            this.loadImages(this.sessionId);
        }
        this.animate();
        window.addEventListener("resize", () => this.handleResize());
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }

    setupEventListeners() {
        this.renderer.domElement.addEventListener("click", (event) => this.onCanvasClick(event));
        document.getElementById("uploadForm")?.addEventListener("submit", (e) => this.handleUploadSubmit(e));
        document.getElementById("screenshotForm")?.addEventListener("submit", (e) => this.handleScreenshotSubmit(e));
    }

    setupMovementControls() {
        const moveSpeed = 0.1;
        const keys = { w: false, a: false, s: false, d: false };

        document.addEventListener("keydown", (event) => {
            switch (event.key) {
                case "w": keys.w = true; break;
                case "a": keys.a = true; break;
                case "s": keys.s = true; break;
                case "d": keys.d = true; break;
            }
        });

        document.addEventListener("keyup", (event) => {
            switch (event.key) {
                case "w": keys.w = false; break;
                case "a": keys.a = false; break;
                case "s": keys.s = false; break;
                case "d": keys.d = false; break;
            }
        });

        const updatePosition = () => {
            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);

            if (keys.w) this.camera.position.addScaledVector(direction, moveSpeed);
            if (keys.s) this.camera.position.addScaledVector(direction, -moveSpeed);
            if (keys.a) {
                const left = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                this.camera.position.addScaledVector(left, -moveSpeed);
            }
            if (keys.d) {
                const right = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                this.camera.position.addScaledVector(right, moveSpeed);
            }

            // Simple collision detection with walls
            this.camera.position.y = 1.6; // Keep at eye level
            this.camera.position.x = Math.max(-4.5, Math.min(19.5, this.camera.position.x)); // Room bounds
            this.camera.position.z = Math.max(-4.5, Math.min(4.5, this.camera.position.z));

            requestAnimationFrame(updatePosition);
        };
        updatePosition();
    }

    async loadImages(sessionId) {
        try {
            const response = await fetch(`http://localhost:3000/api/screenshots/${sessionId}/`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            if (!data.screenshots?.length) {
                console.log("No screenshots found");
                return;
            }

            this.imagesToLoad = data.screenshots;
            this.displayImagesInGallery();
        } catch (error) {
            console.error("❌ Error fetching images:", error);
        }
    }

    async displayImagesInGallery() {
        if (!this.imagesToLoad) return;

        this.clearScene();
        const totalImages = this.imagesToLoad.length;
        let imageIndex = 0;

        for (let room of this.rooms) {
            const wallPositions = [
                { pos: new THREE.Vector3(0, 2, -4.9), rot: 0 },      // Back wall
                { pos: new THREE.Vector3(-4.9, 2, 0), rot: Math.PI / 2 }, // Left wall
                { pos: new THREE.Vector3(4.9, 2, 0), rot: -Math.PI / 2 }  // Right wall
            ];

            for (let wall of wallPositions) {
                if (imageIndex >= totalImages) break;

                const texture = await this.loadTexture(this.imagesToLoad[imageIndex]);
                const aspectRatio = texture.image.width / texture.image.height;
                const planeHeight = 2;
                const planeWidth = planeHeight * aspectRatio;

                const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geometry, material);

                mesh.position.copy(wall.pos);
                mesh.rotation.y = wall.rot;
                mesh.userData = { filename: this.imagesToLoad[imageIndex] };

                room.add(mesh);
                this.images.push({ mesh, filename: this.imagesToLoad[imageIndex] });
                imageIndex++;
            }
            if (imageIndex >= totalImages) break;
        }
    }

    clearScene() {
        this.images.forEach(img => {
            img.mesh.parent.remove(img.mesh);
            img.mesh.geometry.dispose();
            img.mesh.material.dispose();
        });
        this.images = [];
    }

    loadTexture(filename) {
        return new Promise((resolve, reject) => {
            this.textureLoader.load(
                filename,
                (texture) => {
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    resolve(texture);
                },
                undefined,
                (err) => reject(err)
            );
        });
    }

    onCanvasClick(event) {
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.images.map(img => img.mesh));

        if (intersects.length > 0) {
            const mesh = intersects[0].object;
            console.log(`Clicked image: ${mesh.userData.filename}`);
            if (!this.clickSound.isPlaying) this.clickSound.play();
        }
    }

    async handleScreenshotSubmit(event) {
        event.preventDefault();
        const url = document.getElementById("url")?.value;
        if (!url) return;

        try {
            const response = await fetch("http://localhost:3000/api/capture", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url })
            });
            const result = await response.json();
            if (result.sessionId) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error capturing screenshot:", error);
        }
    }

    async handleUploadSubmit(event) {
        event.preventDefault();
        const fileInput = document.getElementById("images");
        if (!fileInput?.files?.length) return;

        const formData = new FormData();
        for (const file of fileInput.files) {
            formData.append("images", file);
        }

        try {
            const response = await fetch(`http://localhost:3000/api/upload${this.sessionId ? `/${this.sessionId}` : ''}`, {
                method: "POST",
                body: formData
            });
            const result = await response.json();
            if (result.success) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error uploading files:", error);
        }
    }

    handleResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
}

const app = new ThreeJSApp();
app.init();



3D VIRTUAL ART Gallery
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Virtual Art Gallery</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f0f1a;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            font-family: Arial, sans-serif;
        }
        .control-panel {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
        .hidden-panel {
            display: none;
        }
        .top-panel {
            top: 0;
            width: 100%;
            text-align: center;
        }
        .sidebar {
            position: absolute;
            top: 60px;
            width: 250px;
            height: calc(100% - 120px);
        }
        .left-sidebar {
            left: 0;
        }
        .right-sidebar {
            right: 0;
        }
        .bottom-panel {
            bottom: 0;
            width: 100%;
            text-align: center;
        }
        .glow-btn {
            background: #00d4ff;
            border: none;
            padding: 8px 16px;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            box-shadow: 0 0 10px #00d4ff;
            transition: background 0.3s, transform 0.2s;
        }
        .glow-btn:hover {
            background: #00b0d4;
            transform: scale(1.05);
        }
        .action-group {
            margin: 5px;
            display: inline-block;
        }
        .form-group {
            margin: 10px 0;
        }
        .preview-container img {
            max-width: 50px;
            margin: 5px;
            cursor: pointer;
        }
        .slider-group {
            margin: 10px 0;
        }
        .title {
            margin: 0;
            font-size: 1.5em;
            text-shadow: 0 0 5px #00d4ff;
        }
        input[type="file"], input[type="text"] {
            width: 100%;
            padding: 5px;
            margin: 5px 0;
            border-radius: 3px;
            border: 1px solid #00d4ff;
            background: #1a1a2e;
            color: white;
        }
        .status-indicator {
            margin-left: 5px;
            vertical-align: middle;
        }
        .status-indicator.hidden {
            display: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
                "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js"
            }
        }
    </script>
</head>
<body>
    <div id="ui-overlay">
        <button id="toggleControlsBtn" class="glow-btn toggle-controls-btn">Hide Controls</button>

        <div class="control-panel top-panel">
            <h1 class="title">Virtual Art Gallery</h1>
            <div class="button-group">
                <div class="action-group">
                    <button id="downloadBtn" class="glow-btn">Download View</button>
                    <span id="downloadStatus" class="status-indicator hidden"><i class="fas fa-spinner fa-spin"></i></span>
                </div>
            </div>
        </div>

        <div class="control-panel sidebar left-sidebar">
            <form id="uploadForm" class="form-group">
                <h3>Upload Images</h3>
                <input type="file" id="images" multiple accept="image/*">
                <div id="previewContainer" class="preview-container"></div>
                <div class="action-group">
                    <button type="submit" class="glow-btn submit-btn">Upload</button>
                    <span id="uploadStatus" class="status-indicator hidden"><i class="fas fa-spinner fa-spin"></i></span>
                </div>
            </form>
            <form id="screenshotForm" class="form-group">
                <h3>Capture Screenshot</h3>
                <input type="text" id="url" placeholder="Enter URL">
                <div class="action-group">
                    <button type="submit" class="glow-btn submit-btn">Capture</button>
                    <span id="screenshotStatus" class="status-indicator hidden"><i class="fas fa-spinner fa-spin"></i></span>
                </div>
            </form>
        </div>

        <div class="control-panel sidebar right-sidebar">
            <div class="slider-group">
                <label for="zoomSlider">Zoom: <span id="zoomValue">5.0</span></label>
                <input type="range" id="zoomSlider" min="0.1" max="10" step="0.1" value="5">
            </div>
        </div>

        <div class="control-panel bottom-panel">
            <div class="action-group">
                <button id="prevPage" class="glow-btn nav-btn">← Previous Room</button>
                <span id="prevPageStatus" class="status-indicator hidden"><i class="fas fa-spinner fa-spin"></i></span>
            </div>
            <div class="action-group">
                <button id="nextPage" class="glow-btn nav-btn">Next Room →</button>
                <span id="nextPageStatus" class="status-indicator hidden"><i class="fas fa-spinner fa-spin"></i></span>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

        class ThreeJSApp {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 1.6, 5);

                this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true, preserveDrawingBuffer: true });
                this.renderer.setClearColor(0x000000, 0.2);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.enableZoom = true;
                this.controls.minDistance = 0.1;
                this.controls.maxDistance = 10;
                this.controls.enablePan = false;
                this.controls.screenSpacePanning = false;
                this.controls.maxPolarAngle = Math.PI / 2;

                this.images = [];
                this.sessionId = localStorage.getItem('sessionId');
                this.textureLoader = new THREE.TextureLoader();

                this.audioListener = new THREE.AudioListener();
                this.camera.add(this.audioListener);
                this.backgroundAudio = new THREE.Audio(this.audioListener);
                this.clickSound = new THREE.Audio(this.audioListener);

                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.selectedMesh = null;

                this.rooms = [];
                this.currentRoom = 0;
                this.isMoving = false;

                this.addLighting();
                this.createGallery();
                this.setupAudio();
                this.setupMovementControls();
            }

            addLighting() {
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(0, 10, 10);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
            }

            createGallery() {
                const wallMaterial = new THREE.MeshPhongMaterial({ color: 0xeeeeee });
                const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                const doorMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513, transparent: true, opacity: 0.8 });

                const room1 = new THREE.Group();
                const floor1 = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), floorMaterial);
                floor1.rotation.x = -Math.PI / 2;
                room1.add(floor1);

                const walls1 = [
                    new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial),
                    new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial),
                    new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial),
                    new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial)
                ];
                walls1[0].position.set(0, 2.5, -5);
                walls1[1].position.set(0, 2.5, 5);
                walls1[1].rotation.y = Math.PI;
                walls1[2].position.set(-5, 2.5, 0);
                walls1[2].rotation.y = Math.PI / 2;
                walls1[3].position.set(5, 2.5, 0);
                walls1[3].rotation.y = -Math.PI / 2;

                const door1 = new THREE.Mesh(new THREE.PlaneGeometry(2, 4), doorMaterial);
                door1.position.set(5, 2, 0);
                door1.rotation.y = -Math.PI / 2;
                door1.userData = { nextRoom: 1 };
                room1.add(door1);

                walls1.forEach(wall => room1.add(wall));
                room1.position.set(0, 0, 0);
                this.rooms.push(room1);

                const room2 = new THREE.Group();
                const floor2 = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), floorMaterial);
                floor2.rotation.x = -Math.PI / 2;
                room2.add(floor2);

                const walls2 = [
                    new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial),
                    new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial),
                    new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial),
                    new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial)
                ];
                walls2[0].position.set(0, 2.5, -5);
                walls2[1].position.set(0, 2.5, 5);
                walls2[1].rotation.y = Math.PI;
                walls2[2].position.set(-5, 2.5, 0);
                walls2[2].rotation.y = Math.PI / 2;
                walls2[3].position.set(5, 2.5, 0);
                walls2[3].rotation.y = -Math.PI / 2;

                const door2 = new THREE.Mesh(new THREE.PlaneGeometry(2, 4), doorMaterial);
                door2.position.set(-5, 2, 0);
                door2.rotation.y = Math.PI / 2;
                door2.userData = { nextRoom: 0 };
                room2.add(door2);

                walls2.forEach(wall => room2.add(wall));
                room2.position.set(15, 0, 0);
                this.rooms.push(room2);

                this.rooms.forEach(room => this.scene.add(room));
            }

            setupAudio() {
                this.backgroundAudio.setBuffer(this.loadAudio('path/to/ambient-gallery.mp3'));
                this.backgroundAudio.setLoop(true);
                this.backgroundAudio.setVolume(0.3);
                this.backgroundAudio.play();

                this.clickSound.setBuffer(this.loadAudio('path/to/click-sound.mp3'));
                this.clickSound.setVolume(0.5);
            }

            loadAudio(url) {
                const audioLoader = new THREE.AudioLoader();
                let buffer;
                audioLoader.load(url, (audioBuffer) => buffer = audioBuffer);
                return buffer;
            }

            init() {
                console.log("🚀 Virtual Gallery loaded");
                this.setupEventListeners();
                if (this.sessionId) this.loadImages(this.sessionId);
                this.animate();
                window.addEventListener("resize", () => this.handleResize());
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            setupEventListeners() {
                this.renderer.domElement.addEventListener("click", (event) => this.onCanvasClick(event));
                document.getElementById("uploadForm")?.addEventListener("submit", (e) => this.handleUploadSubmit(e));
                document.getElementById("screenshotForm")?.addEventListener("submit", (e) => this.handleScreenshotSubmit(e));
                document.getElementById("downloadBtn")?.addEventListener("click", () => this.handleDownload());
                document.getElementById("zoomSlider")?.addEventListener("input", () => this.handleZoom());
                document.getElementById("toggleControlsBtn")?.addEventListener("click", () => this.toggleControls());
                document.getElementById("prevPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom - 1));
                document.getElementById("nextPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom + 1));
            }

            toggleControls() {
                const controlPanels = document.querySelectorAll(".control-panel");
                const toggleButton = document.getElementById("toggleControlsBtn");
                controlPanels.forEach(panel => panel.classList.toggle("hidden-panel"));
                toggleButton.textContent = toggleButton.textContent === "Hide Controls" ? "Show Controls" : "Hide Controls";
            }

            setupMovementControls() {
                const moveSpeed = 0.1;
                const keys = { w: false, a: false, s: false, d: false };

                document.addEventListener("keydown", (event) => {
                    switch (event.key.toLowerCase()) {
                        case "w": keys.w = true; break;
                        case "a": keys.a = true; break;
                        case "s": keys.s = true; break;
                        case "d": keys.d = true; break;
                    }
                });

                document.addEventListener("keyup", (event) => {
                    switch (event.key.toLowerCase()) {
                        case "w": keys.w = false; break;
                        case "a": keys.a = false; break;
                        case "s": keys.s = false; break;
                        case "d": keys.d = false; break;
                    }
                });

                const updatePosition = () => {
                    if (this.isMoving) return;

                    const direction = new THREE.Vector3();
                    this.camera.getWorldDirection(direction);
                    direction.y = 0;
                    direction.normalize();

                    if (keys.w) this.camera.position.addScaledVector(direction, moveSpeed);
                    if (keys.s) this.camera.position.addScaledVector(direction, -moveSpeed);
                    if (keys.a) {
                        const left = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                        this.camera.position.addScaledVector(left, -moveSpeed);
                    }
                    if (keys.d) {
                        const right = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                        this.camera.position.addScaledVector(right, moveSpeed);
                    }

                    this.checkCollisions();
                    requestAnimationFrame(updatePosition);
                };
                updatePosition();
            }

            checkCollisions() {
                this.camera.position.y = 1.6;
                const roomBounds = this.rooms[this.currentRoom].position;
                const minX = roomBounds.x - 4.5;
                const maxX = roomBounds.x + 4.5;
                const minZ = roomBounds.z - 4.5;
                const maxZ = roomBounds.z + 4.5;

                this.camera.position.x = Math.max(minX, Math.min(maxX, this.camera.position.x));
                this.camera.position.z = Math.max(minZ, Math.min(maxZ, this.camera.position.z));
            }

            moveToRoom(roomIndex) {
                if (roomIndex < 0 || roomIndex >= this.rooms.length || this.isMoving) return;

                this.isMoving = true;
                const targetPos = this.rooms[roomIndex].position.clone().add(new THREE.Vector3(0, 1.6, 0));
                const startPos = this.camera.position.clone();
                const duration = 1000;
                const startTime = performance.now();

                const animateMove = (time) => {
                    const elapsed = time - startTime;
                    const t = Math.min(elapsed / duration, 1);
                    this.camera.position.lerpVectors(startPos, targetPos, t);

                    if (t < 1) {
                        requestAnimationFrame(animateMove);
                    } else {
                        this.currentRoom = roomIndex;
                        this.isMoving = false;
                    }
                };
                requestAnimationFrame(animateMove);
            }

            async loadImages(sessionId) {
                try {
                    const response = await fetch(`http://localhost:3000/api/screenshots/${sessionId}/`);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();
                    if (!data.screenshots?.length) {
                        console.log("No screenshots found");
                        return;
                    }

                    this.imagesToLoad = data.screenshots;
                    this.displayImagesInGallery();
                } catch (error) {
                    console.error("❌ Error fetching images:", error);
                }
            }

            async displayImagesInGallery() {
                if (!this.imagesToLoad) return;

                this.clearScene();
                const totalImages = this.imagesToLoad.length;
                let imageIndex = 0;

                for (let room of this.rooms) {
                    const wallPositions = [
                        { pos: new THREE.Vector3(-3, 2, -4.9), rot: 0 },
                        { pos: new THREE.Vector3(3, 2, -4.9), rot: 0 },
                        { pos: new THREE.Vector3(-4.9, 2, -2), rot: Math.PI / 2 },
                        { pos: new THREE.Vector3(-4.9, 2, 2), rot: Math.PI / 2 },
                        { pos: new THREE.Vector3(4.9, 2, -2), rot: -Math.PI / 2 },
                        { pos: new THREE.Vector3(4.9, 2, 2), rot: -Math.PI / 2 }
                    ];

                    for (let wall of wallPositions) {
                        if (imageIndex >= totalImages) break;

                        const texture = await this.loadTexture(this.imagesToLoad[imageIndex]);
                        const aspectRatio = texture.image.width / texture.image.height;
                        const planeHeight = 2;
                        const planeWidth = Math.min(planeHeight * aspectRatio, 3);

                        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                        const mesh = new THREE.Mesh(geometry, material);

                        mesh.position.copy(wall.pos).add(room.position);
                        mesh.rotation.y = wall.rot;
                        mesh.userData = { filename: this.imagesToLoad[imageIndex] };

                        room.add(mesh);
                        this.images.push({ mesh, filename: this.imagesToLoad[imageIndex] });
                        imageIndex++;
                    }
                    if (imageIndex >= totalImages) break;
                }
            }

            clearScene() {
                this.images.forEach(img => {
                    img.mesh.parent.remove(img.mesh);
                    img.mesh.geometry.dispose();
                    img.mesh.material.dispose();
                });
                this.images = [];
            }

            loadTexture(filename) {
                return new Promise((resolve, reject) => {
                    this.textureLoader.load(
                        filename,
                        (texture) => {
                            texture.minFilter = THREE.LinearFilter;
                            texture.magFilter = THREE.LinearFilter;
                            resolve(texture);
                        },
                        undefined,
                        (err) => reject(err)
                    );
                });
            }

            onCanvasClick(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects([...this.images.map(img => img.mesh), ...this.scene.children.filter(obj => obj.userData.nextRoom !== undefined)]);

                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    if (obj.userData.nextRoom !== undefined) {
                        this.moveToRoom(obj.userData.nextRoom);
                    } else if (obj.userData.filename) {
                        console.log(`Clicked image: ${obj.userData.filename}`);
                        if (!this.clickSound.isPlaying) this.clickSound.play();
                        this.focusImage(obj);
                    }
                }
            }

            focusImage(mesh) {
                const targetPos = mesh.position.clone().sub(this.camera.getWorldDirection().multiplyScalar(2));
                targetPos.y = 1.6;
                const startPos = this.camera.position.clone();
                const duration = 500;
                const startTime = performance.now();

                const animateFocus = (time) => {
                    const elapsed = time - startTime;
                    const t = Math.min(elapsed / duration, 1);
                    this.camera.position.lerpVectors(startPos, targetPos, t);
                    this.camera.lookAt(mesh.position);

                    if (t < 1) requestAnimationFrame(animateFocus);
                };
                requestAnimationFrame(animateFocus);
            }

            handleDownload() {
                const imgData = this.renderer.domElement.toDataURL("image/png");
                const link = document.createElement("a");
                link.href = imgData;
                link.download = "gallery_view.png";
                link.click();
            }

            handleZoom() {
                const zoomSlider = document.getElementById("zoomSlider");
                const zoomValue = document.getElementById("zoomValue");
                const zoomLevel = parseFloat(zoomSlider.value);
                zoomValue.textContent = zoomLevel.toFixed(1);
                this.controls.maxDistance = zoomLevel;
                this.controls.update();
            }

            async handleScreenshotSubmit(event) {
                event.preventDefault();
                const url = document.getElementById("url")?.value;
                if (!url) return;

                try {
                    const response = await fetch("http://localhost:3000/api/capture", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ url })
                    });
                    const result = await response.json();
                    if (result.sessionId) {
                        this.sessionId = result.sessionId;
                        localStorage.setItem('sessionId', this.sessionId);
                        this.loadImages(this.sessionId);
                    }
                } catch (error) {
                    console.error("Error capturing screenshot:", error);
                }
            }

            async handleUploadSubmit(event) {
                event.preventDefault();
                const fileInput = document.getElementById("images");
                if (!fileInput?.files?.length) return;

                const formData = new FormData();
                for (const file of fileInput.files) {
                    formData.append("images", file);
                }

                try {
                    const response = await fetch(`http://localhost:3000/api/upload${this.sessionId ? `/${this.sessionId}` : ''}`, {
                        method: "POST",
                        body: formData
                    });
                    const result = await response.json();
                    if (result.success) {
                        this.sessionId = result.sessionId;
                        localStorage.setItem('sessionId', this.sessionId);
                        this.loadImages(this.sessionId);
                    }
                } catch (error) {
                    console.error("Error uploading files:", error);
                }
            }

            handleResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        const app = new ThreeJSApp();
        app.init();
    </script>
</body>
</html>




NEW LIGHTING 3D Gallery
import * as THREE from 'three';
import { OrbitControls } from 'OrbitControls';
import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/UnrealBloomPass.js';
import { RGBELoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/RGBELoader.js'; // Add this import

class ThreeJSApp {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 1.6, 5);

        this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true, preserveDrawingBuffer: true });
        this.renderer.setClearColor(0x000000, 0);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.2;
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);

        // Post-processing setup
        this.composer = new EffectComposer(this.renderer);
        const renderPass = new RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.7, // Strength
            0.4, // Radius
            0.85 // Threshold
        );
        this.composer.addPass(bloomPass);

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enableZoom = true;
        this.controls.minDistance = 0.5;
        this.controls.maxDistance = 10;
        this.controls.enablePan = false;
        this.controls.screenSpacePanning = false;
        this.controls.maxPolarAngle = Math.PI / 2;

        this.images = [];
        this.sessionId = localStorage.getItem('sessionId');
        this.textureLoader = new THREE.TextureLoader();

        this.audioListener = new THREE.AudioListener();
        this.camera.add(this.audioListener);
        this.backgroundAudio = new THREE.Audio(this.audioListener);
        this.clickSound = new THREE.Audio(this.audioListener);

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.selectedMesh = null;

        this.rooms = [];
        this.currentRoom = 0;
        this.isMoving = false;

        this.addLighting();
        this.addEnvironmentMap();
        this.createGallery();
        this.setupAudio();
        this.setupMovementControls();
    }

    addLighting() {
        const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
        this.scene.add(ambientLight);

        const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
        keyLight.position.set(5, 10, 5);
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.width = 2048;
        keyLight.shadow.mapSize.height = 2048;
        keyLight.shadow.camera.near = 0.5;
        keyLight.shadow.camera.far = 50;
        keyLight.shadow.bias = -0.0001;
        this.scene.add(keyLight);

        const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight.position.set(-5, 5, -5);
        this.scene.add(fillLight);
    }

    addEnvironmentMap() {
        const envMapUrl = 'https://threejs.org/examples/textures/equirectangular/royal_esplanade_1k.hdr';
        const rgbeLoader = new RGBELoader(); // Use the imported RGBELoader
        rgbeLoader.load(envMapUrl, (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            this.scene.environment = texture;
            // this.scene.background = texture; // Uncomment if you want the background visible
            console.log("🌟 Environment map loaded");
        }, undefined, (err) => {
            console.error("❌ Error loading environment map:", err);
        });
    }

    createGallery() {
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.4, metalness: 0.1 });
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xf5f5f5, roughness: 0.7, metalness: 0 });
        const glassMaterial = new THREE.MeshPhysicalMaterial({ 
            color: 0xaaaaaa, 
            transparent: true, 
            opacity: 0.3, 
            roughness: 0, 
            metalness: 0.1, 
            transmission: 0.9 
        });
        const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.8 });

        const room1 = new THREE.Group();
        const floor1 = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), floorMaterial);
        floor1.rotation.x = -Math.PI / 2;
        floor1.receiveShadow = true;
        room1.add(floor1);

        const walls1 = [
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial)
        ];
        walls1[0].position.set(0, 2, -6);
        walls1[1].position.set(0, 2, 6);
        walls1[1].rotation.y = Math.PI;
        walls1[2].position.set(-6, 2, 0);
        walls1[2].rotation.y = Math.PI / 2;
        walls1[3].position.set(6, 2, 0);
        walls1[3].rotation.y = -Math.PI / 2;
        walls1.forEach(wall => {
            wall.receiveShadow = true;
            room1.add(wall);
        });

        const door1 = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 3.5), glassMaterial);
        door1.position.set(6, 1.75, 0);
        door1.rotation.y = -Math.PI / 2;
        door1.userData = { nextRoom: 1 };
        room1.add(door1);

        room1.position.set(0, 0, 0);
        this.rooms.push(room1);

        const room2 = new THREE.Group();
        const floor2 = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), floorMaterial);
        floor2.rotation.x = -Math.PI / 2;
        floor2.receiveShadow = true;
        room2.add(floor2);

        const walls2 = [
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial)
        ];
        walls2[0].position.set(0, 2, -6);
        walls2[1].position.set(0, 2, 6);
        walls2[1].rotation.y = Math.PI;
        walls2[2].position.set(-6, 2, 0);
        walls2[2].rotation.y = Math.PI / 2;
        walls2[3].position.set(6, 2, 0);
        walls2[3].rotation.y = -Math.PI / 2;
        walls2.forEach(wall => {
            wall.receiveShadow = true;
            room2.add(wall);
        });

        const door2 = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 3.5), glassMaterial);
        door2.position.set(-6, 1.75, 0);
        door2.rotation.y = Math.PI / 2;
        door2.userData = { nextRoom: 0 };
        room2.add(door2);

        room2.position.set(18, 0, 0);
        this.rooms.push(room2);

        this.rooms.forEach(room => this.scene.add(room));
    }

    setupAudio() {
        this.backgroundAudio.setBuffer(this.loadAudio('sweet.mp3'));
        this.backgroundAudio.setLoop(true);
        this.backgroundAudio.setVolume(0.2);
        this.backgroundAudio.play();

        this.clickSound.setBuffer(this.loadAudio('sweet.mp3'));
        this.clickSound.setVolume(0.5);
    }

    loadAudio(url) {
        const audioLoader = new THREE.AudioLoader();
        let buffer;
        audioLoader.load(url, (audioBuffer) => buffer = audioBuffer);
        return buffer;
    }

    init() {
        console.log("🚀 Virtual Gallery loaded");
        this.setupEventListeners();
        if (this.sessionId) this.loadImages(this.sessionId);
        this.animate();
        window.addEventListener("resize", () => this.handleResize());
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        this.controls.update();
        this.composer.render();
    }

    setupEventListeners() {
        this.renderer.domElement.addEventListener("click", (event) => this.onCanvasClick(event));
        document.getElementById("uploadForm")?.addEventListener("submit", (e) => this.handleUploadSubmit(e));
        document.getElementById("screenshotForm")?.addEventListener("submit", (e) => this.handleScreenshotSubmit(e));
        document.getElementById("downloadBtn")?.addEventListener("click", () => this.handleDownload());
        document.getElementById("zoomSlider")?.addEventListener("input", () => this.handleZoom());
        document.getElementById("toggleControlsBtn")?.addEventListener("click", () => this.toggleControls());
        document.getElementById("prevPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom - 1));
        document.getElementById("nextPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom + 1));
    }

    toggleControls() {
        const controlPanels = document.querySelectorAll(".control-panel");
        const toggleButton = document.getElementById("toggleControlsBtn");
        controlPanels.forEach(panel => panel.classList.toggle("hidden-panel"));
        toggleButton.textContent = toggleButton.textContent === "Hide Controls" ? "Show Controls" : "Hide Controls";
    }

    setupMovementControls() {
        const moveSpeed = 0.1;
        const keys = { w: false, a: false, s: false, d: false };

        document.addEventListener("keydown", (event) => {
            switch (event.key.toLowerCase()) {
                case "w": keys.w = true; break;
                case "a": keys.a = true; break;
                case "s": keys.s = true; break;
                case "d": keys.d = true; break;
            }
        });

        document.addEventListener("keyup", (event) => {
            switch (event.key.toLowerCase()) {
                case "w": keys.w = false; break;
                case "a": keys.a = false; break;
                case "s": keys.s = false; break;
                case "d": keys.d = false; break;
            }
        });

        const updatePosition = () => {
            if (this.isMoving) return;

            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            if (keys.w) this.camera.position.addScaledVector(direction, moveSpeed);
            if (keys.s) this.camera.position.addScaledVector(direction, -moveSpeed);
            if (keys.a) {
                const left = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                this.camera.position.addScaledVector(left, -moveSpeed);
            }
            if (keys.d) {
                const right = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                this.camera.position.addScaledVector(right, moveSpeed);
            }

            this.checkCollisions();
            requestAnimationFrame(updatePosition);
        };
        updatePosition();
    }

    checkCollisions() {
        this.camera.position.y = 1.6;
        const roomBounds = this.rooms[this.currentRoom].position;
        const minX = roomBounds.x - 5.5;
        const maxX = roomBounds.x + 5.5;
        const minZ = roomBounds.z - 5.5;
        const maxZ = roomBounds.z + 5.5;

        this.camera.position.x = Math.max(minX, Math.min(maxX, this.camera.position.x));
        this.camera.position.z = Math.max(minZ, Math.min(maxZ, this.camera.position.z));
    }

    moveToRoom(roomIndex) {
        if (roomIndex < 0 || roomIndex >= this.rooms.length || this.isMoving) return;

        this.isMoving = true;
        const targetPos = this.rooms[roomIndex].position.clone().add(new THREE.Vector3(0, 1.6, 4));
        const startPos = this.camera.position.clone();
        const duration = 1000;
        const startTime = performance.now();

        const animateMove = (time) => {
            const elapsed = time - startTime;
            const t = Math.min(elapsed / duration, 1);
            this.camera.position.lerpVectors(startPos, targetPos, t);

            if (t < 1) {
                requestAnimationFrame(animateMove);
            } else {
                this.currentRoom = roomIndex;
                this.isMoving = false;
            }
        };
        requestAnimationFrame(animateMove);
    }

    async loadImages(sessionId) {
        try {
            const response = await fetch(`http://localhost:3000/api/screenshots/${sessionId}/`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            if (!data.screenshots?.length) {
                console.log("No screenshots found");
                return;
            }

            this.imagesToLoad = data.screenshots;
            this.displayImagesInGallery();
        } catch (error) {
            console.error("❌ Error fetching images:", error);
        }
    }

    async displayImagesInGallery() {
        if (!this.imagesToLoad) return;

        this.clearScene();
        const totalImages = this.imagesToLoad.length;
        let imageIndex = 0;

        const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.8 });

        for (let room of this.rooms) {
            const wallPositions = [
                { pos: new THREE.Vector3(-4, 2, -5.9), rot: 0 },
                { pos: new THREE.Vector3(-1, 2, -5.9), rot: 0 },
                { pos: new THREE.Vector3(2, 2, -5.9), rot: 0 },
                { pos: new THREE.Vector3(-5.9, 2, -2), rot: Math.PI / 2 },
                { pos: new THREE.Vector3(-5.9, 2, 2), rot: Math.PI / 2 },
                { pos: new THREE.Vector3(5.9, 2, -2), rot: -Math.PI / 2 },
                { pos: new THREE.Vector3(5.9, 2, 2), rot: -Math.PI / 2 }
            ];

            for (let wall of wallPositions) {
                if (imageIndex >= totalImages) break;

                const texture = await this.loadTexture(this.imagesToLoad[imageIndex]);
                const aspectRatio = texture.image.width / texture.image.height;
                const planeHeight = 2.5;
                const planeWidth = Math.min(planeHeight * aspectRatio, 3.5);

                const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                const material = new THREE.MeshStandardMaterial({ 
                    map: texture, 
                    side: THREE.DoubleSide, 
                    roughness: 0.8, 
                    metalness: 0 
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(wall.pos).add(room.position);
                mesh.rotation.y = wall.rot;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = { filename: this.imagesToLoad[imageIndex] };
                room.add(mesh);
                this.images.push({ mesh, filename: this.imagesToLoad[imageIndex] });

                const frameThickness = 0.1;
                const frameGeometry = new THREE.BoxGeometry(planeWidth + 0.2, planeHeight + 0.2, frameThickness);
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.position.copy(mesh.position);
                frame.position.z -= frameThickness / 2;
                frame.rotation.y = wall.rot;
                frame.castShadow = true;
                frame.receiveShadow = true;
                room.add(frame);

                const spotlight = new THREE.SpotLight(0xffffff, 2, 10, Math.PI / 8, 0.5, 2);
                spotlight.position.set(wall.pos.x, 3.8, wall.pos.z).add(room.position);
                spotlight.target = mesh;
                spotlight.castShadow = true;
                spotlight.shadow.mapSize.width = 1024;
                spotlight.shadow.mapSize.height = 1024;
                room.add(spotlight);

                const volGeometry = new THREE.CylinderGeometry(0.1, 0.5, 2, 32, 1, true);
                const volMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, 
                    transparent: true, 
                    opacity: 0.1, 
                    blending: THREE.AdditiveBlending 
                });
                const volLight = new THREE.Mesh(volGeometry, volMaterial);
                volLight.position.set(wall.pos.x, 2.9, wall.pos.z).add(room.position);
                volLight.rotation.x = Math.PI / 2;
                room.add(volLight);

                imageIndex++;
            }
            if (imageIndex >= totalImages) break;
        }
    }

    clearScene() {
        this.images.forEach(img => {
            img.mesh.parent.remove(img.mesh);
            img.mesh.geometry.dispose();
            img.mesh.material.dispose();
        });
        this.images = [];
        this.rooms.forEach(room => {
            room.children.forEach(child => {
                if (child instanceof THREE.SpotLight || child.material?.color?.getHex() === 0x333333 || child.material?.blending === THREE.AdditiveBlending) {
                    room.remove(child);
                }
            });
        });
    }

    loadTexture(filename) {
        return new Promise((resolve, reject) => {
            this.textureLoader.load(
                filename,
                (texture) => {
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    resolve(texture);
                },
                undefined,
                (err) => reject(err)
            );
        });
    }

    onCanvasClick(event) {
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects([...this.images.map(img => img.mesh), ...this.scene.children.filter(obj => obj.userData.nextRoom !== undefined)]);

        if (intersects.length > 0) {
            const obj = intersects[0].object;
            if (obj.userData.nextRoom !== undefined) {
                this.moveToRoom(obj.userData.nextRoom);
            } else if (obj.userData.filename) {
                console.log(`Clicked image: ${obj.userData.filename}`);
                if (!this.clickSound.isPlaying) this.clickSound.play();
                this.focusImage(obj);
            }
        }
    }

    focusImage(mesh) {
        const targetPos = mesh.position.clone().sub(this.camera.getWorldDirection().multiplyScalar(2));
        targetPos.y = 1.6;
        const startPos = this.camera.position.clone();
        const duration = 500;
        const startTime = performance.now();

        const animateFocus = (time) => {
            const elapsed = time - startTime;
            const t = Math.min(elapsed / duration, 1);
            this.camera.position.lerpVectors(startPos, targetPos, t);
            this.camera.lookAt(mesh.position);

            if (t < 1) requestAnimationFrame(animateFocus);
        };
        requestAnimationFrame(animateFocus);
    }

    handleDownload() {
        this.composer.render();
        const imgData = this.renderer.domElement.toDataURL("image/png");
        const link = document.createElement("a");
        link.href = imgData;
        link.download = "gallery_view.png";
        link.click();
    }

    handleZoom() {
        const zoomSlider = document.getElementById("zoomSlider");
        const zoomValue = document.getElementById("zoomValue");
        const zoomLevel = parseFloat(zoomSlider.value);
        zoomValue.textContent = zoomLevel.toFixed(1);
        this.controls.maxDistance = zoomLevel;
        this.controls.update();
    }

    async handleScreenshotSubmit(event) {
        event.preventDefault();
        const url = document.getElementById("url")?.value;
        if (!url) return;

        try {
            const response = await fetch("http://localhost:3000/api/capture", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url })
            });
            const result = await response.json();
            if (result.sessionId) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error capturing screenshot:", error);
        }
    }

    async handleUploadSubmit(event) {
        event.preventDefault();
        const fileInput = document.getElementById("images");
        if (!fileInput?.files?.length) return;

        const formData = new FormData();
        for (const file of fileInput.files) {
            formData.append("images", file);
        }

        try {
            const response = await fetch(`http://localhost:3000/api/upload${this.sessionId ? `/${this.sessionId}` : ''}`, {
                method: "POST",
                body: formData
            });
            const result = await response.json();
            if (result.success) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error uploading files:", error);
        }
    }

    handleResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.composer.setSize(window.innerWidth, window.innerHeight);
    }
}

const app = new ThreeJSApp();
app.init();

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Modern Virtual Art Gallery</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />

    <link rel="stylesheet" href="index.css" />
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
                "OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js",
                "postprocessing": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js",
                "RGBELoader": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/RGBELoader.js"
            }
        }
    </script>
    <script type="module" src="mockup.js"></script>
</head>
<body>
    <div id="ui-overlay">
       

        <div class="control-panel top-panel">
            <h1 class="title">Modern Virtual Art Gallery</h1>
            <div class="button-group">
                <div class="action-group">
                    <button id="downloadBtn" class="glow-btn">Download View</button>
                    <span id="downloadStatus" class="status-indicator hidden"><i class="fas fa-spinner fa-spin"></i></span>
                </div>
            </div>
        </div>

        <div class="control-panel sidebar left-sidebar">
            <form id="uploadForm" class="form-group">
                <h3>Upload Artwork</h3>
                <input type="file" id="images" multiple accept="image/*">
                <div id="previewContainer" class="preview-container"></div>
                <div class="action-group">
                    <button type="submit" class="glow-btn submit-btn">Upload</button>
                    <span id="uploadStatus" class="status-indicator hidden"><i class="fas fa-spinner fa-spin"></i></span>
                </div>
            </form>
            <form id="screenshotForm" class="form-group">
                <h3>Capture Screenshot</h3>
                <input type="text" id="url" placeholder="Enter URL">
                <div class="action-group">
                    <button type="submit" class="glow-btn submit-btn">Capture</button>
                    <span id="screenshotStatus" class="status-indicator hidden"><i class="fas fa-spinner fa-spin"></i></span>
                </div>
            </form>
            <button id="toggleControlsBtn" class="glow-btn toggle-controls-btn">Hide Controls</button>
        </div>
        

        <div class="control-panel sidebar right-sidebar">
            <div class="slider-group">
                <label for="zoomSlider">Zoom: <span id="zoomValue">5.0</span></label>
                <input type="range" id="zoomSlider" min="0.5" max="10" step="0.1" value="5">
            </div>
        </div>

        <div class="control-panel bottom-panel">
            <div class="action-group">
                <button id="prevPage" class="glow-btn nav-btn">← Previous Room</button>
                <span id="prevPageStatus" class="status-indicator hidden"><i class="fas fa-spinner fa-spin"></i></span>
            </div>
            <div class="action-group">
                <button id="nextPage" class="glow-btn nav-btn">Next Room →</button>
                <span id="nextPageStatus" class="status-indicator hidden"><i class="fas fa-spinner fa-spin"></i></span>
            </div>
        </div>
    </div>
    
</body>
</html>





WORKING WITH IMAGE ISSUES


import * as THREE from 'three';
import { OrbitControls } from 'OrbitControls';

class ThreeJSApp {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 1.6, 5); // Eye-level height
        this.camera.lookAt(0, 1.6, 0); // Look at the center of the room

        this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true, preserveDrawingBuffer: true });
        this.renderer.setClearColor(0x000000, 0);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.setPixelRatio(window.devicePixelRatio); // High resolution rendering
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enableZoom = true;
        this.controls.minDistance = 0.5;
        this.controls.maxDistance = 10;
        this.controls.enablePan = false;
        this.controls.screenSpacePanning = false;
        this.controls.maxPolarAngle = Math.PI / 2;

        this.images = [];
        this.sessionId = localStorage.getItem('sessionId');
        this.textureLoader = new THREE.TextureLoader();

        this.audioListener = new THREE.AudioListener();
        this.camera.add(this.audioListener);
        this.backgroundAudio = new THREE.Audio(this.audioListener);
        this.clickSound = new THREE.Audio(this.audioListener);

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.selectedMesh = null;

        this.rooms = [];
        this.currentRoom = 0;
        this.isMoving = false;

        this.addLighting();
        this.createGallery();
        this.setupAudio();
        this.setupMovementControls();
    }

    addLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(0, 10, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        this.scene.add(directionalLight);

        const ceilingLight = new THREE.DirectionalLight(0xffffff, 0.8);
        ceilingLight.position.set(0, 10, 0);
        ceilingLight.castShadow = true;
        this.scene.add(ceilingLight);
    }

    createGallery() {
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.4, metalness: 0.1 });
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xf5f5f5, roughness: 0.3 });
        const glassMaterial = new THREE.MeshPhysicalMaterial({ 
            color: 0xaaaaaa, 
            transparent: true, 
            opacity: 0.3, 
            roughness: 0, 
            metalness: 0.1, 
            transmission: 0.9 
        });
        const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.8 });

        // Room 1
        const room1 = new THREE.Group();
        const floor1 = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), floorMaterial);
        floor1.rotation.x = -Math.PI / 2;
        floor1.receiveShadow = true;
        room1.add(floor1);

        const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0xd3d3d3, roughness: 0.5 });
        const ceiling1 = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), ceilingMaterial);
        ceiling1.position.y = 4;
        ceiling1.rotation.x = Math.PI / 2;
        ceiling1.receiveShadow = true;
        room1.add(ceiling1);

        const walls1 = [
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial), // Back
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial), // Front
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial), // Left
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial)  // Right
        ];
        walls1[0].position.set(0, 2, -6);
        walls1[1].position.set(0, 2, 6);
        walls1[1].rotation.y = Math.PI;
        walls1[2].position.set(-6, 2, 0);
        walls1[2].rotation.y = Math.PI / 2;
        walls1[3].position.set(6, 2, 0);
        walls1[3].rotation.y = -Math.PI / 2;
        walls1.forEach(wall => {
            wall.receiveShadow = true;
            room1.add(wall);
        });

        const door1 = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 3.5), glassMaterial);
        door1.position.set(6, 1.75, 0);
        door1.rotation.y = -Math.PI / 2;
        door1.userData = { nextRoom: 1 };
        room1.add(door1);

        room1.position.set(0, 0, 0);
        this.rooms.push(room1);

        // Room 2
        const room2 = new THREE.Group();
        const floor2 = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), floorMaterial);
        floor2.rotation.x = -Math.PI / 2;
        floor2.receiveShadow = true;
        room2.add(floor2);

        const ceiling2 = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), ceilingMaterial);
        ceiling2.position.y = 4;
        ceiling2.rotation.x = Math.PI / 2;
        ceiling2.receiveShadow = true;
        room2.add(ceiling2);

        const walls2 = [
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial)
        ];
        walls2[0].position.set(0, 2, -6);
        walls2[1].position.set(0, 2, 6);
        walls2[1].rotation.y = Math.PI;
        walls2[2].position.set(-6, 2, 0);
        walls2[2].rotation.y = Math.PI / 2;
        walls2[3].position.set(6, 2, 0);
        walls2[3].rotation.y = -Math.PI / 2;
        walls2.forEach(wall => {
            wall.receiveShadow = true;
            room2.add(wall);
        });

        const door2 = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 3.5), glassMaterial);
        door2.position.set(-6, 1.75, 0);
        door2.rotation.y = Math.PI / 2;
        door2.userData = { nextRoom: 0 };
        room2.add(door2);

        room2.position.set(18, 0, 0);
        this.rooms.push(room2);

        this.rooms.forEach(room => this.scene.add(room));
    }

    setupAudio() {
        this.backgroundAudio.setBuffer(this.loadAudio('sweet.mp3'));
        this.backgroundAudio.setLoop(true);
        this.backgroundAudio.setVolume(0.2);
        this.backgroundAudio.play();

        this.clickSound.setBuffer(this.loadAudio('sweet.mp3'));
        this.clickSound.setVolume(0.5);
    }

    loadAudio(url) {
        const audioLoader = new THREE.AudioLoader();
        let buffer;
        audioLoader.load(url, (audioBuffer) => buffer = audioBuffer);
        return buffer;
    }

    init() {
        console.log("🚀 Virtual Gallery loaded");
        this.setupEventListeners();
        if (this.sessionId) this.loadImages(this.sessionId);
        this.animate();
        window.addEventListener("resize", () => this.handleResize());
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }

    setupEventListeners() {
        this.renderer.domElement.addEventListener("click", (event) => this.onCanvasClick(event));
        document.getElementById("uploadForm")?.addEventListener("submit", (e) => this.handleUploadSubmit(e));
        document.getElementById("screenshotForm")?.addEventListener("submit", (e) => this.handleScreenshotSubmit(e));
        document.getElementById("downloadBtn")?.addEventListener("click", () => this.handleDownload());
        document.getElementById("zoomSlider")?.addEventListener("input", () => this.handleZoom());
        document.getElementById("toggleControlsBtn")?.addEventListener("click", () => this.toggleControls());
        document.getElementById("prevPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom - 1));
        document.getElementById("nextPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom + 1));
    }

    toggleControls() {
        const controlPanels = document.querySelectorAll(".control-panel");
        const toggleButton = document.getElementById("toggleControlsBtn");
        controlPanels.forEach(panel => panel.classList.toggle("hidden-panel"));
        toggleButton.textContent = toggleButton.textContent === "Hide Controls" ? "Show Controls" : "Hide Controls";
    }

    setupMovementControls() {
        const moveSpeed = 0.1;
        const keys = { w: false, a: false, s: false, d: false };

        document.addEventListener("keydown", (event) => {
            switch (event.key.toLowerCase()) {
                case "w": keys.w = true; break;
                case "a": keys.a = true; break;
                case "s": keys.s = true; break;
                case "d": keys.d = true; break;
            }
        });

        document.addEventListener("keyup", (event) => {
            switch (event.key.toLowerCase()) {
                case "w": keys.w = false; break;
                case "a": keys.a = false; break;
                case "s": keys.s = false; break;
                case "d": keys.d = false; break;
            }
        });

        const updatePosition = () => {
            if (this.isMoving) return;

            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            if (keys.w) this.camera.position.addScaledVector(direction, moveSpeed);
            if (keys.s) this.camera.position.addScaledVector(direction, -moveSpeed);
            if (keys.a) {
                const left = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                this.camera.position.addScaledVector(left, -moveSpeed);
            }
            if (keys.d) {
                const right = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                this.camera.position.addScaledVector(right, moveSpeed);
            }

            this.checkCollisions();
            requestAnimationFrame(updatePosition);
        };
        updatePosition();
    }

    checkCollisions() {
        this.camera.position.y = 1.6; // Fixed eye level
        const roomBounds = this.rooms[this.currentRoom].position;
        const minX = roomBounds.x - 5.5;
        const maxX = roomBounds.x + 5.5;
        const minZ = roomBounds.z - 5.5;
        const maxZ = roomBounds.z + 5.5;

        this.camera.position.x = Math.max(minX, Math.min(maxX, this.camera.position.x));
        this.camera.position.z = Math.max(minZ, Math.min(maxZ, this.camera.position.z));
    }

    moveToRoom(roomIndex) {
        if (roomIndex < 0 || roomIndex >= this.rooms.length || this.isMoving) return;

        this.isMoving = true;
        const targetPos = this.rooms[roomIndex].position.clone().add(new THREE.Vector3(0, 1.6, 4));
        const startPos = this.camera.position.clone();
        const duration = 1000;
        const startTime = performance.now();

        const animateMove = (time) => {
            const elapsed = time - startTime;
            const t = Math.min(elapsed / duration, 1);
            this.camera.position.lerpVectors(startPos, targetPos, t);

            if (t < 1) {
                requestAnimationFrame(animateMove);
            } else {
                this.currentRoom = roomIndex;
                this.isMoving = false;
            }
        };
        requestAnimationFrame(animateMove);
    }

    async loadImages(sessionId) {
        try {
            const response = await fetch(`http://localhost:3000/api/screenshots/${sessionId}/`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            console.log("📸 Found images in session", sessionId + ":", data.screenshots);
            if (!data.screenshots?.length) {
                console.log("No screenshots found");
                return;
            }

            this.imagesToLoad = data.screenshots.map(img => `http://localhost:3000${img}`);
            this.displayImagesInGallery();
        } catch (error) {
            console.error("❌ Error fetching images:", error);
        }
    }

    async displayImagesInGallery() {
        if (!this.imagesToLoad) return;

        this.clearScene();
        const totalImages = this.imagesToLoad.length;
        let imageIndex = 0;

        const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.8 });
        const fallbackMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0 }); // Red for failed textures

        for (let room of this.rooms) {
            const wallPositions = [
                { pos: new THREE.Vector3(-4, 2, -5.9), rot: 0 }, // Back wall
                { pos: new THREE.Vector3(-1, 2, -5.9), rot: 0 },
                { pos: new THREE.Vector3(2, 2, -5.9), rot: 0 },
                { pos: new THREE.Vector3(-5.9, 2, -2), rot: Math.PI / 2 }, // Left wall
                { pos: new THREE.Vector3(-5.9, 2, 2), rot: Math.PI / 2 },
                { pos: new THREE.Vector3(5.9, 2, -2), rot: -Math.PI / 2 }, // Right wall
                { pos: new THREE.Vector3(5.9, 2, 2), rot: -Math.PI / 2 }
            ];

            console.log(`Processing room at position ${room.position.x}, ${room.position.z} with ${wallPositions.length} positions`);

            for (let wall of wallPositions) {
                if (imageIndex >= totalImages) {
                    console.log(`No more images to place. Stopped at index ${imageIndex}`);
                    break;
                }

                console.log(`Attempting to load texture for image ${imageIndex}: ${this.imagesToLoad[imageIndex]}`);
                const texture = await this.loadTexture(this.imagesToLoad[imageIndex]);
                let material;
                if (!texture.image) {
                    console.warn(`Texture failed to load for ${this.imagesToLoad[imageIndex]}. Using fallback material.`);
                    material = fallbackMaterial; // Use red material for failed loads
                } else {
                    material = new THREE.MeshStandardMaterial({
                        map: texture,
                        side: THREE.DoubleSide,
                        roughness: 0.2,
                        metalness: 0.0,
                        envMapIntensity: 0.5
                    });
                }

                console.log(`Placing image ${imageIndex} at position ${wall.pos.x}, ${wall.pos.z} with rotation ${wall.rot}`);

                const aspectRatio = texture.image ? texture.image.width / texture.image.height : 1;
                const maxWidth = 3.5;
                const planeHeight = 2.5;
                const planeWidth = Math.min(planeHeight * aspectRatio, maxWidth);

                const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(wall.pos).add(room.position);
                mesh.rotation.y = wall.rot;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = { filename: this.imagesToLoad[imageIndex] };
                room.add(mesh);
                this.images.push({ mesh, filename: this.imagesToLoad[imageIndex] });

                // Frame with adjusted offset based on rotation
                const frameThickness = 0.1;
                const frameGeometry = new THREE.BoxGeometry(planeWidth + 0.2, planeHeight + 0.2, frameThickness);
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.position.copy(mesh.position);
                if (Math.abs(wall.rot) === Math.PI / 2) {
                    // For left and right walls, adjust x offset instead of z
                    frame.position.x += (wall.rot > 0 ? -frameThickness / 2 : frameThickness / 2);
                } else {
                    // For back wall, adjust z offset
                    frame.position.z -= frameThickness / 2;
                }
                frame.rotation.y = wall.rot;
                frame.castShadow = true;
                frame.receiveShadow = true;
                room.add(frame);

                // Spotlight with adjusted position
                const spotlight = new THREE.SpotLight(0xffffff, 2.0, 15, Math.PI / 6, 0.7);
                const lightOffset = 1; // Move light slightly in front of the image
                if (Math.abs(wall.rot) === Math.PI / 2) {
                    // For left and right walls, adjust x position
                    spotlight.position.set(
                        wall.pos.x + (wall.rot > 0 ? lightOffset : -lightOffset),
                        4.5,
                        wall.pos.z
                    ).add(room.position);
                } else {
                    // For back wall, adjust z position
                    spotlight.position.set(wall.pos.x, 4.5, wall.pos.z + lightOffset).add(room.position);
                }
                spotlight.target = mesh;
                spotlight.castShadow = true;
                spotlight.shadow.mapSize.width = 1024;
                spotlight.shadow.mapSize.height = 1024;
                room.add(spotlight);

                imageIndex++;
            }
        }

        console.log(`Total images placed: ${this.images.length} out of ${totalImages}`);
    }

    clearScene() {
        this.images.forEach(img => {
            img.mesh.parent.remove(img.mesh);
            img.mesh.geometry.dispose();
            if (img.mesh.material.map) img.mesh.material.map.dispose();
            img.mesh.material.dispose();
        });
        this.images = [];
        this.rooms.forEach(room => {
            room.children.forEach(child => {
                if (child instanceof THREE.SpotLight || child.material?.color?.getHex() === 0x333333) {
                    room.remove(child);
                }
            });
        });
    }

    loadTexture(filename) {
        return new Promise((resolve, reject) => {
            this.textureLoader.load(
                filename,
                (texture) => {
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.generateMipmaps = true;
                    texture.anisotropy = this.renderer.capabilities.getMaxAnisotropy() || 1;
                    console.log(`Successfully loaded texture: ${filename}`);
                    resolve(texture);
                },
                undefined,
                (err) => {
                    console.error(`Failed to load texture ${filename}:`, err);
                    reject(err);
                }
            );
        });
    }

    onCanvasClick(event) {
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects([...this.images.map(img => img.mesh), ...this.scene.children.filter(obj => obj.userData.nextRoom !== undefined)]);

        if (intersects.length > 0) {
            const obj = intersects[0].object;
            if (obj.userData.nextRoom !== undefined) {
                this.moveToRoom(obj.userData.nextRoom);
            } else if (obj.userData.filename) {
                console.log(`Clicked image: ${obj.userData.filename}`);
                if (!this.clickSound.isPlaying) this.clickSound.play();
                this.focusImage(obj);
            }
        }
    }

    focusImage(mesh) {
        const targetPos = mesh.position.clone().sub(this.camera.getWorldDirection().multiplyScalar(2));
        targetPos.y = 1.6;
        const startPos = this.camera.position.clone();
        const duration = 500;
        const startTime = performance.now();

        const animateFocus = (time) => {
            const elapsed = time - startTime;
            const t = Math.min(elapsed / duration, 1);
            this.camera.position.lerpVectors(startPos, targetPos, t);
            this.camera.lookAt(mesh.position);

            if (t < 1) requestAnimationFrame(animateFocus);
        };
        requestAnimationFrame(animateFocus);
    }

    handleDownload() {
        const imgData = this.renderer.domElement.toDataURL("image/png");
        const link = document.createElement("a");
        link.href = imgData;
        link.download = "gallery_view.png";
        link.click();
    }

    handleZoom() {
        const zoomSlider = document.getElementById("zoomSlider");
        const zoomValue = document.getElementById("zoomValue");
        const zoomLevel = parseFloat(zoomSlider.value);
        zoomValue.textContent = zoomLevel.toFixed(1);
        this.controls.maxDistance = zoomLevel;
        this.controls.update();
    }

    async handleScreenshotSubmit(event) {
        event.preventDefault();
        const url = document.getElementById("url")?.value;
        if (!url) return;

        try {
            const response = await fetch("http://localhost:3000/api/capture", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url })
            });
            const result = await response.json();
            if (result.sessionId) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error capturing screenshot:", error);
        }
    }

    async handleUploadSubmit(event) {
        event.preventDefault();
        const fileInput = document.getElementById("images");
        if (!fileInput?.files?.length) return;

        const formData = new FormData();
        for (const file of fileInput.files) {
            formData.append("images", file);
        }

        try {
            const response = await fetch(`http://localhost:3000/api/upload${this.sessionId ? `/${this.sessionId}` : ''}`, {
                method: "POST",
                body: formData
            });
            const result = await response.json();
            if (result.success) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error uploading files:", error);
        }
    }

    handleResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
}

const app = new ThreeJSApp();
app.init();



#STABLE Environment
import * as THREE from "three";
import { OrbitControls } from "OrbitControls";

class ThreeJSApp {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 1.6, 5);
        this.camera.lookAt(0, 1.6, 0);

        this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true, preserveDrawingBuffer: true });
        this.renderer.setClearColor(0x000000, 0);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enableZoom = true;
        this.controls.minDistance = 0.5;
        this.controls.maxDistance = 10;
        this.controls.enablePan = false;
        this.controls.screenSpacePanning = false;
        this.controls.maxPolarAngle = Math.PI / 2;

        this.images = [];
        this.sessionId = localStorage.getItem('sessionId');
        this.textureLoader = new THREE.TextureLoader();

        this.audioListener = new THREE.AudioListener();
        this.camera.add(this.audioListener);
        this.backgroundAudio = new THREE.Audio(this.audioListener);
        this.clickSound = new THREE.Audio(this.audioListener);

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.selectedMesh = null;

        this.rooms = [];
        this.currentRoom = 0;
        this.isMoving = false;

        this.addLighting();
        this.createGallery();
        this.setupAudio();
        this.setupMovementControls();
        this.createAvatar();
    }

    addLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(0, 10, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        this.scene.add(directionalLight);

        const ceilingLight = new THREE.DirectionalLight(0xffffff, 0.8);
        ceilingLight.position.set(0, 10, 0);
        ceilingLight.castShadow = true;
        this.scene.add(ceilingLight);
    }

    createGallery() {
        const concreteColor = 0x888888;
        const concreteRoughness = 0.7;
        const concreteMetalness = 0.1;

        const floorMaterial = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: 0.3,
            metalness: concreteMetalness
        });

        const noiseTexture = new THREE.Texture(this.generateNoiseCanvas(256, 256));
        noiseTexture.needsUpdate = true;
        noiseTexture.wrapS = noiseTexture.wrapT = THREE.RepeatWrapping;
        noiseTexture.repeat.set(4, 4);
        floorMaterial.map = noiseTexture;
        floorMaterial.normalMap = noiseTexture;
        floorMaterial.normalScale.set(0.1, 0.1);

        const ceilingMaterial = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: concreteRoughness,
            metalness: concreteMetalness
        });
        ceilingMaterial.map = noiseTexture;

        const glassMaterial = new THREE.MeshPhysicalMaterial({ 
            color: 0xaaaaaa, 
            transparent: true, 
            opacity: 0.3, 
            roughness: 0, 
            metalness: 0.1, 
            transmission: 0.9 
        });
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xf5f5f5, roughness: 0.3 });

        const room1 = new THREE.Group();
        const floor1 = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), floorMaterial);
        floor1.rotation.x = -Math.PI / 2;
        floor1.receiveShadow = true;
        room1.add(floor1);

        const ceiling1 = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), ceilingMaterial);
        ceiling1.position.y = 5;
        ceiling1.rotation.x = Math.PI / 2;
        ceiling1.receiveShadow = true;
        room1.add(ceiling1);

        const panelSize = 2;
        const panelDepth = 0.2;
        const panelSpacing = 0.5;
        const panelMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: concreteRoughness,
            metalness: concreteMetalness
        });

        for (let i = -2; i <= 2; i++) {
            for (let j = -2; j <= 2; j++) {
                if (Math.abs(i) === 2 && Math.abs(j) === 2) continue;
                const panel = new THREE.Mesh(
                    new THREE.PlaneGeometry(panelSize, panelSize),
                    panelMaterial
                );
                panel.position.set(
                    i * (panelSize + panelSpacing),
                    5 - panelDepth,
                    j * (panelSize + panelSpacing)
                );
                panel.rotation.x = Math.PI / 2;
                panel.receiveShadow = true;
                room1.add(panel);
            }
        }

        const walls1 = [
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial), // Back wall
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial), // Front wall
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial), // Left wall
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial)  // Right wall
        ];
        walls1[0].position.set(0, 2.5, -7.5);
        walls1[1].position.set(0, 2.5, 7.5);
        walls1[1].rotation.y = Math.PI;
        walls1[2].position.set(-7.5, 2.5, 0);
        walls1[2].rotation.y = Math.PI / 2;
        walls1[3].position.set(7.5, 2.5, 0);
        walls1[3].rotation.y = -Math.PI / 2;
        walls1.forEach(wall => {
            wall.receiveShadow = true;
            room1.add(wall);
        });

        const windowFrame = new THREE.Mesh(new THREE.PlaneGeometry(4, 3), glassMaterial);
        windowFrame.position.set(0, 2.5, -7.4);
        room1.add(windowFrame);

        const windowBarsGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        for (let i = -3; i <= 3; i++) {
            const barV = new THREE.Mesh(windowBarsGeometry.clone(), glassMaterial);
            barV.scale.y = 3;
            barV.position.set(i * 0.6, 2.5, -7.4);
            room1.add(barV);
            const barH = new THREE.Mesh(windowBarsGeometry.clone(), glassMaterial);
            barH.scale.x = 4;
            barH.position.set(0, 2.5 + i * 0.5, -7.4);
            room1.add(barH);
        }

        // Remove freestanding panels
        // (Commented out to avoid adding them)
        // const freestandingPanelMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
        // const panelGeometry = new THREE.PlaneGeometry(3, 3);
        // const panels = [
        //     new THREE.Mesh(panelGeometry, freestandingPanelMaterial),
        //     new THREE.Mesh(panelGeometry, freestandingPanelMaterial)
        // ];
        // panels[0].position.set(-3, 1.5, 2);
        // panels[0].rotation.y = Math.PI / 4;
        // panels[1].position.set(3, 1.5, 2);
        // panels[1].rotation.y = -Math.PI / 4;
        // panels.forEach(panel => {
        //     panel.receiveShadow = true;
        //     room1.add(panel);
        // });

        room1.position.set(0, 0, 0);
        this.rooms.push(room1);

        const room2 = new THREE.Group();
        const floor2 = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), floorMaterial);
        floor2.rotation.x = -Math.PI / 2;
        floor2.receiveShadow = true;
        room2.add(floor2);

        const ceiling2 = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), ceilingMaterial);
        ceiling2.position.y = 4;
        ceiling2.rotation.x = Math.PI / 2;
        ceiling2.receiveShadow = true;
        room2.add(ceiling2);

        for (let i = -2; i <= 2; i++) {
            for (let j = -2; j <= 2; j++) {
                if (Math.abs(i) === 2 && Math.abs(j) === 2) continue;
                const panel = new THREE.Mesh(
                    new THREE.PlaneGeometry(panelSize, panelSize),
                    panelMaterial
                );
                panel.position.set(
                    i * (panelSize + panelSpacing),
                    4 - panelDepth,
                    j * (panelSize + panelSpacing)
                );
                panel.rotation.x = Math.PI / 2;
                panel.receiveShadow = true;
                room2.add(panel);
            }
        }

        const walls2 = [
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial)
        ];
        walls2[0].position.set(0, 2, -6);
        walls2[1].position.set(0, 2, 6);
        walls2[1].rotation.y = Math.PI;
        walls2[2].position.set(-6, 2, 0);
        walls2[2].rotation.y = Math.PI / 2;
        walls2[3].position.set(6, 2, 0);
        walls2[3].rotation.y = -Math.PI / 2;
        walls2.forEach(wall => {
            wall.receiveShadow = true;
            room2.add(wall);
        });

        const door2 = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 3.5), glassMaterial);
        door2.position.set(-6, 1.75, 0);
        door2.rotation.y = Math.PI / 2;
        door2.userData = { nextRoom: 0 };
        room2.add(door2);

        room2.position.set(18, 0, 0);
        this.rooms.push(room2);

        this.rooms.forEach(room => this.scene.add(room));
    }

    generateNoiseCanvas(width, height) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext('2d');
        const imageData = context.createImageData(width, height);

        for (let i = 0; i < imageData.data.length; i += 4) {
            const noise = Math.random() * 0.1 + 0.9;
            imageData.data[i] = 136 * noise;
            imageData.data[i + 1] = 136 * noise;
            imageData.data[i + 2] = 136 * noise;
            imageData.data[i + 3] = 255;
        }

        context.putImageData(imageData, 0, 0);
        return canvas;
    }

    createAvatar() {
        const avatarMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3
        });

        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1, 32), avatarMaterial);
        body.position.set(2, 0.5, 2);
        this.scene.add(body);

        const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), avatarMaterial);
        head.position.set(2, 1.2, 2);
        this.scene.add(head);

        const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 32);
        const leftArm = new THREE.Mesh(armGeometry, avatarMaterial);
        leftArm.position.set(1.7, 0.7, 2);
        leftArm.rotation.z = Math.PI / 4;
        this.scene.add(leftArm);

        const rightArm = new THREE.Mesh(armGeometry, avatarMaterial);
        rightArm.position.set(2.3, 0.7, 2);
        rightArm.rotation.z = -Math.PI / 4;
        this.scene.add(rightArm);

        const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 32);
        const leftLeg = new THREE.Mesh(legGeometry, avatarMaterial);
        leftLeg.position.set(1.8, 0.25, 2);
        this.scene.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, avatarMaterial);
        rightLeg.position.set(2.2, 0.25, 2);
        this.scene.add(rightLeg);
    }

    async setupAudio() {
        try {
            const backgroundBuffer = await this.loadAudio('sweet.mp3');
            this.backgroundAudio.setBuffer(backgroundBuffer);
            this.backgroundAudio.setLoop(true);
            this.backgroundAudio.setVolume(0.2);
            this.backgroundAudio.play();

            const clickBuffer = await this.loadAudio('sweet.mp3');
            this.clickSound.setBuffer(clickBuffer);
            this.clickSound.setVolume(0.5);
        } catch (error) {
            console.error("Error loading audio:", error);
        }
    }

    loadAudio(url) {
        return new Promise((resolve, reject) => {
            const audioLoader = new THREE.AudioLoader();
            audioLoader.load(
                url,
                (audioBuffer) => resolve(audioBuffer),
                undefined,
                (err) => reject(err)
            );
        });
    }

    init() {
        console.log("🚀 Virtual Gallery loaded");
        this.setupEventListeners();
        if (this.sessionId) this.loadImages(this.sessionId);
        this.animate();
        window.addEventListener("resize", () => this.handleResize());
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }

    setupEventListeners() {
        this.renderer.domElement.addEventListener("click", (event) => this.onCanvasClick(event));
        document.getElementById("uploadForm")?.addEventListener("submit", (e) => this.handleUploadSubmit(e));
        document.getElementById("screenshotForm")?.addEventListener("submit", (e) => this.handleScreenshotSubmit(e));
        document.getElementById("downloadBtn")?.addEventListener("click", () => this.handleDownload());
        document.getElementById("zoomSlider")?.addEventListener("input", () => this.handleZoom());
        document.getElementById("toggleControlsBtn")?.addEventListener("click", () => this.toggleControls());
        document.getElementById("prevPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom - 1));
        document.getElementById("nextPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom + 1));
    }

    toggleControls() {
        const controlPanels = document.querySelectorAll(".control-panel");
        const toggleButton = document.getElementById("toggleControlsBtn");
        controlPanels.forEach(panel => panel.classList.toggle("hidden-panel"));
        toggleButton.textContent = toggleButton.textContent === "Hide Controls" ? "Show Controls" : "Hide Controls";
    }

    setupMovementControls() {
        const moveSpeed = 0.1;
        const keys = { w: false, a: false, s: false, d: false };

        document.addEventListener("keydown", (event) => {
            switch (event.key.toLowerCase()) {
                case "w": keys.w = true; break;
                case "a": keys.a = true; break;
                case "s": keys.s = true; break;
                case "d": keys.d = true; break;
            }
        });

        document.addEventListener("keyup", (event) => {
            switch (event.key.toLowerCase()) {
                case "w": keys.w = false; break;
                case "a": keys.a = false; break;
                case "s": keys.s = false; break;
                case "d": keys.d = false; break;
            }
        });

        const updatePosition = () => {
            if (this.isMoving) return;

            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            if (keys.w) this.camera.position.addScaledVector(direction, moveSpeed);
            if (keys.s) this.camera.position.addScaledVector(direction, -moveSpeed);
            if (keys.a) {
                const left = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                this.camera.position.addScaledVector(left, -moveSpeed);
            }
            if (keys.d) {
                const right = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                this.camera.position.addScaledVector(right, moveSpeed);
            }

            this.checkCollisions();
            requestAnimationFrame(updatePosition);
        };
        updatePosition();
    }

    checkCollisions() {
        this.camera.position.y = 1.6;
        const roomBounds = this.rooms[this.currentRoom].position;
        const minX = roomBounds.x - 7;
        const maxX = roomBounds.x + 7;
        const minZ = roomBounds.z - 7;
        const maxZ = roomBounds.z + 7;

        this.camera.position.x = Math.max(minX, Math.min(maxX, this.camera.position.x));
        this.camera.position.z = Math.max(minZ, Math.min(maxZ, this.camera.position.z));
    }

    moveToRoom(roomIndex) {
        if (roomIndex < 0 || roomIndex >= this.rooms.length || this.isMoving) return;

        this.isMoving = true;

        const targetRoomPos = this.rooms[roomIndex].position;
        const currentRoomPos = this.rooms[this.currentRoom].position;
        let targetPos;

        if (roomIndex > this.currentRoom) {
            targetPos = new THREE.Vector3(targetRoomPos.x - 8, 1.6, targetRoomPos.z);
        } else {
            targetPos = new THREE.Vector3(targetRoomPos.x + 8, 1.6, targetRoomPos.z);
        }

        const startPos = this.camera.position.clone();
        const duration = 1000;
        const startTime = performance.now();

        const animateMove = (time) => {
            const elapsed = time - startTime;
            const t = Math.min(elapsed / duration, 1);
            this.camera.position.lerpVectors(startPos, targetPos, t);
            const lookAtPos = new THREE.Vector3(targetRoomPos.x, 1.6, targetRoomPos.z);
            this.camera.lookAt(lookAtPos);

            if (t < 1) {
                requestAnimationFrame(animateMove);
            } else {
                this.currentRoom = roomIndex;
                this.isMoving = false;
            }
        };
        requestAnimationFrame(animateMove);
    }

    async loadImages(sessionId) {
        try {
            const response = await fetch(`http://localhost:3000/api/screenshots/${sessionId}/`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            console.log("📸 Found images in session", sessionId + ":", data.screenshots);
            if (!data.screenshots?.length) {
                console.log("No screenshots found");
                return;
            }
            this.imagesToLoad = data.screenshots.map(img => `http://localhost:3000${img}`);
            this.displayImagesInGallery();
        } catch (error) {
            console.error("❌ Error fetching images:", error);
        }
    }

    async displayImagesInGallery() {
        if (!this.imagesToLoad) return;

        this.clearScene();
        const totalImages = this.imagesToLoad.length;
        let imageIndex = 0;

        const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.8 });
        const fallbackMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0 });

        for (let room of this.rooms) {
            const wallPositions = [
                { pos: new THREE.Vector3(-4, 2, -7.5), rot: 0 }, // Back wall, left
                { pos: new THREE.Vector3(-1, 2, -7.5), rot: 0 }, // Back wall, center
                { pos: new THREE.Vector3(2, 2, -7.5), rot: 0 },  // Back wall, right
                { pos: new THREE.Vector3(-7.5, 2, -2), rot: Math.PI / 2 }, // Left wall
                { pos: new THREE.Vector3(7.5, 2, -2), rot: -Math.PI / 2 }, // Right wall, first
                { pos: new THREE.Vector3(7.5, 2, 2), rot: -Math.PI / 2 }  // Right wall, second
                // Removed freestanding panel positions
            ];

            for (let wall of wallPositions) {
                if (imageIndex >= totalImages) break;

                const texture = await this.loadTexture(this.imagesToLoad[imageIndex]);
                let material = texture.image ? 
                    new THREE.MeshStandardMaterial({
                        map: texture,
                        side: THREE.DoubleSide,
                        roughness: 0.2,
                        metalness: 0.0,
                        envMapIntensity: 0.5
                    }) : 
                    fallbackMaterial;

                const aspectRatio = texture.image ? texture.image.width / texture.image.height : 1;
                const maxWidth = 3.5;
                const planeHeight = 2.5;
                const planeWidth = Math.min(planeHeight * aspectRatio, maxWidth);

                const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(wall.pos).add(room.position);
                mesh.rotation.y = wall.rot;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = { filename: this.imagesToLoad[imageIndex] };
                room.add(mesh);
                this.images.push({ mesh, filename: this.imagesToLoad[imageIndex] });

                const frameThickness = 0.1;
                const frameGeometry = new THREE.BoxGeometry(planeWidth + 0.2, planeHeight + 0.2, frameThickness);
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.position.copy(mesh.position);
                frame.position.z -= Math.abs(wall.rot) === Math.PI / 2 ? 0 : frameThickness / 2;
                frame.position.x += Math.abs(wall.rot) === Math.PI / 2 ? (wall.rot > 0 ? -frameThickness / 2 : frameThickness / 2) : 0;
                frame.rotation.y = wall.rot;
                frame.castShadow = true;
                frame.receiveShadow = true;
                room.add(frame);

                const spotlight = new THREE.SpotLight(0xffffff, 2.0, 15, Math.PI / 6, 0.7);
                const lightOffset = 1;
                spotlight.position.set(
                    wall.pos.x + (Math.abs(wall.rot) === Math.PI / 2 ? (wall.rot > 0 ? lightOffset : -lightOffset) : 0),
                    4.5,
                    wall.pos.z + (Math.abs(wall.rot) === Math.PI / 2 ? 0 : lightOffset)
                ).add(room.position);
                spotlight.target = mesh;
                spotlight.castShadow = true;
                spotlight.shadow.mapSize.width = 1024;
                spotlight.shadow.mapSize.height = 1024;
                room.add(spotlight);

                imageIndex++;
            }
        }
    }

    clearScene() {
        this.images.forEach(img => {
            img.mesh.parent.remove(img.mesh);
            img.mesh.geometry.dispose();
            if (img.mesh.material.map) img.mesh.material.map.dispose();
            img.mesh.material.dispose();
        });
        this.images = [];
        this.rooms.forEach(room => {
            const toRemove = room.children.filter(child => 
                child instanceof THREE.SpotLight || 
                (child.material?.color?.getHex() === 0x333333)
            );
            toRemove.forEach(child => room.remove(child));
        });
    }

    loadTexture(filename) {
        return new Promise((resolve, reject) => {
            this.textureLoader.load(
                filename,
                (texture) => {
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.generateMipmaps = true;
                    texture.anisotropy = this.renderer.capabilities.getMaxAnisotropy() || 1;
                    resolve(texture);
                },
                undefined,
                (err) => reject(err)
            );
        });
    }

    onCanvasClick(event) {
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects([...this.images.map(img => img.mesh), ...this.scene.children.filter(obj => obj.userData.nextRoom !== undefined)]);

        if (intersects.length > 0) {
            const obj = intersects[0].object;
            if (obj.userData.nextRoom !== undefined) {
                this.moveToRoom(obj.userData.nextRoom);
            } else if (obj.userData.filename) {
                console.log(`Clicked image: ${obj.userData.filename}`);
                if (!this.clickSound.isPlaying) this.clickSound.play();
                this.focusImage(obj);
            }
        }
    }

    focusImage(mesh) {
        const targetPos = mesh.position.clone().sub(this.camera.getWorldDirection().multiplyScalar(2));
        targetPos.y = 1.6;
        const startPos = this.camera.position.clone();
        const duration = 500;
        const startTime = performance.now();

        const animateFocus = (time) => {
            const elapsed = time - startTime;
            const t = Math.min(elapsed / duration, 1);
            this.camera.position.lerpVectors(startPos, targetPos, t);
            this.camera.lookAt(mesh.position);

            if (t < 1) requestAnimationFrame(animateFocus);
        };
        requestAnimationFrame(animateFocus);
    }

    handleDownload() {
        const imgData = this.renderer.domElement.toDataURL("image/png");
        const link = document.createElement("a");
        link.href = imgData;
        link.download = "gallery_view.png";
        link.click();
    }

    handleZoom() {
        const zoomSlider = document.getElementById("zoomSlider");
        const zoomValue = document.getElementById("zoomValue");
        const zoomLevel = parseFloat(zoomSlider.value);
        zoomValue.textContent = zoomLevel.toFixed(1);
        this.controls.maxDistance = zoomLevel;
        this.controls.update();
    }

    async handleScreenshotSubmit(event) {
        event.preventDefault();
        const url = document.getElementById("url")?.value;
        if (!url) return;

        try {
            const response = await fetch("http://localhost:3000/api/capture", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url })
            });
            const result = await response.json();
            if (result.sessionId) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error capturing screenshot:", error);
        }
    }

    async handleUploadSubmit(event) {
        event.preventDefault();
        const fileInput = document.getElementById("images");
        if (!fileInput?.files?.length) return;

        const formData = new FormData();
        for (const file of fileInput.files) {
            formData.append("images", file);
        }

        try {
            const response = await fetch(`http://localhost:3000/api/upload${this.sessionId ? `/${this.sessionId}` : ''}`, {
                method: "POST",
                body: formData
            });
            const result = await response.json();
            if (result.success) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error uploading files:", error);
        }
    }

    handleResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
}

const app = new ThreeJSApp();
app.init();




IMAGE onDoubleClick
import * as THREE from "three";
import { OrbitControls } from "OrbitControls"; // Fixed import path

class ThreeJSApp {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        this.roomCameraSettings = [
            { position: new THREE.Vector3(0, 1.6, 5), lookAt: new THREE.Vector3(0, 1.6, 0) },
            { position: new THREE.Vector3(18, 1.6, 5), lookAt: new THREE.Vector3(18, 1.6, 0) }
        ];
        const initialSettings = this.roomCameraSettings[0];
        this.camera.position.copy(initialSettings.position);
        this.camera.lookAt(initialSettings.lookAt);

        this.renderer = new THREE.WebGLRenderer({ alpha: false, antialias: true, preserveDrawingBuffer: true });
        this.renderer.setClearColor(0x000000, 1);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enableZoom = true;
        this.controls.minDistance = 0.5;
        this.controls.maxDistance = 10;
        this.controls.enablePan = false;
        this.controls.screenSpacePanning = false;
        this.controls.maxPolarAngle = Math.PI * 0.75;
        this.controls.target.copy(initialSettings.lookAt);
        this.controls.update();

        this.images = [];
        this.sessionId = localStorage.getItem('sessionId');
        this.textureLoader = new THREE.TextureLoader();

        this.audioListener = new THREE.AudioListener();
        this.camera.add(this.audioListener);
        this.backgroundAudio = new THREE.Audio(this.audioListener);
        this.clickSound = new THREE.Audio(this.audioListener);

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.selectedMesh = null;

        this.rooms = [];
        this.currentRoom = 0;
        this.isMoving = false;

        // Store initial camera state for reset
        this.previousCameraState = {
            position: this.camera.position.clone(),
            target: this.controls.target.clone()
        };

        // Double-click detection
        this.lastClickTime = 0;
        this.clickDelay = 300; // Time in ms for double-click detection

        this.addLighting();
        this.createGallery();
        this.setupAudio();
        this.setupMovementControls();
        this.createAvatar();
    }

    addLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(0, 10, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        this.scene.add(directionalLight);

        const ceilingLight = new THREE.DirectionalLight(0xffffff, 0.8);
        ceilingLight.position.set(0, 10, 0);
        ceilingLight.castShadow = true;
        this.scene.add(ceilingLight);
    }

    createGallery() {
        const concreteColor = 0x888888;
        const concreteRoughness = 0.7;
        const concreteMetalness = 0.1;

        const floorMaterial = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: 0.3,
            metalness: concreteMetalness
        });

        const noiseTexture = new THREE.Texture(this.generateNoiseCanvas(256, 256));
        noiseTexture.needsUpdate = true;
        noiseTexture.wrapS = noiseTexture.wrapT = THREE.RepeatWrapping;
        noiseTexture.repeat.set(4, 4);
        floorMaterial.map = noiseTexture;
        floorMaterial.normalMap = noiseTexture;
        floorMaterial.normalScale.set(0.1, 0.1);

        const ceilingMaterial = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: concreteRoughness,
            metalness: concreteMetalness
        });
        ceilingMaterial.map = noiseTexture;

        const glassMaterial = new THREE.MeshPhysicalMaterial({ 
            color: 0xaaaaaa, 
            transparent: true, 
            opacity: 0.3, 
            roughness: 0, 
            metalness: 0.1, 
            transmission: 0.9 
        });
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xf5f5f5, roughness: 0.3 });

        const room1 = new THREE.Group();
        const floor1 = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), floorMaterial);
        floor1.rotation.x = -Math.PI / 2;
        floor1.receiveShadow = true;
        room1.add(floor1);

        const ceiling1 = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), ceilingMaterial);
        ceiling1.position.y = 5;
        ceiling1.rotation.x = Math.PI / 2;
        ceiling1.receiveShadow = true;
        room1.add(ceiling1);

        const panelSize = 2;
        const panelDepth = 0.2;
        const panelSpacing = 0.5;
        const panelMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: concreteRoughness,
            metalness: concreteMetalness
        });

        for (let i = -2; i <= 2; i++) {
            for (let j = -2; j <= 2; j++) {
                if (Math.abs(i) === 2 && Math.abs(j) === 2) continue;
                const panel = new THREE.Mesh(
                    new THREE.PlaneGeometry(panelSize, panelSize),
                    panelMaterial
                );
                panel.position.set(
                    i * (panelSize + panelSpacing),
                    5 - panelDepth,
                    j * (panelSize + panelSpacing)
                );
                panel.rotation.x = Math.PI / 2;
                panel.receiveShadow = true;
                room1.add(panel);
            }
        }

        const walls1 = [
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial)
        ];
        walls1[0].position.set(0, 2.5, -7.5);
        walls1[1].position.set(0, 2.5, 7.5);
        walls1[1].rotation.y = Math.PI;
        walls1[2].position.set(-7.5, 2.5, 0);
        walls1[2].rotation.y = Math.PI / 2;
        walls1[3].position.set(7.5, 2.5, 0);
        walls1[3].rotation.y = -Math.PI / 2;
        walls1.forEach(wall => {
            wall.receiveShadow = true;
            room1.add(wall);
        });

        const windowFrame = new THREE.Mesh(new THREE.PlaneGeometry(4, 3), glassMaterial);
        windowFrame.position.set(0, 2.5, -7.4);
        room1.add(windowFrame);

        const windowBarsGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        for (let i = -3; i <= 3; i++) {
            const barV = new THREE.Mesh(windowBarsGeometry.clone(), glassMaterial);
            barV.scale.y = 3;
            barV.position.set(i * 0.6, 2.5, -7.4);
            room1.add(barV);
            const barH = new THREE.Mesh(windowBarsGeometry.clone(), glassMaterial);
            barH.scale.x = 4;
            barH.position.set(0, 2.5 + i * 0.5, -7.4);
            room1.add(barH);
        }

        room1.position.set(0, 0, 0);
        this.rooms.push(room1);

        const room2 = new THREE.Group();
        const floor2 = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), floorMaterial);
        floor2.rotation.x = -Math.PI / 2;
        floor2.receiveShadow = true;
        room2.add(floor2);

        const ceiling2 = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), ceilingMaterial);
        ceiling2.position.y = 4;
        ceiling2.rotation.x = Math.PI / 2;
        ceiling2.receiveShadow = true;
        room2.add(ceiling2);

        for (let i = -2; i <= 2; i++) {
            for (let j = -2; j <= 2; j++) {
                if (Math.abs(i) === 2 && Math.abs(j) === 2) continue;
                const panel = new THREE.Mesh(
                    new THREE.PlaneGeometry(panelSize, panelSize),
                    panelMaterial
                );
                panel.position.set(
                    i * (panelSize + panelSpacing),
                    4 - panelDepth,
                    j * (panelSize + panelSpacing)
                );
                panel.rotation.x = Math.PI / 2;
                panel.receiveShadow = true;
                room2.add(panel);
            }
        }

        const walls2 = [
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial)
        ];
        walls2[0].position.set(0, 2, -6);
        walls2[1].position.set(0, 2, 6);
        walls2[1].rotation.y = Math.PI;
        walls2[2].position.set(-6, 2, 0);
        walls2[2].rotation.y = Math.PI / 2;
        walls2[3].position.set(6, 2, 0);
        walls2[3].rotation.y = -Math.PI / 2;
        walls2.forEach(wall => {
            wall.receiveShadow = true;
            room2.add(wall);
        });

        const door2 = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 3.5), glassMaterial);
        door2.position.set(-6, 1.75, 0);
        door2.rotation.y = Math.PI / 2;
        door2.userData = { nextRoom: 0 };
        room2.add(door2);

        room2.position.set(18, 0, 0);
        this.rooms.push(room2);

        this.rooms.forEach(room => this.scene.add(room));
    }

    generateNoiseCanvas(width, height) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext('2d');
        const imageData = context.createImageData(width, height);

        for (let i = 0; i < imageData.data.length; i += 4) {
            const noise = Math.random() * 0.1 + 0.9;
            imageData.data[i] = 136 * noise;
            imageData.data[i + 1] = 136 * noise;
            imageData.data[i + 2] = 136 * noise;
            imageData.data[i + 3] = 255;
        }

        context.putImageData(imageData, 0, 0);
        return canvas;
    }

    createAvatar() {
        const avatarMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3
        });

        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1, 32), avatarMaterial);
        body.position.set(2, 0.5, 2);
        this.scene.add(body);

        const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), avatarMaterial);
        head.position.set(2, 1.2, 2);
        this.scene.add(head);

        const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 32);
        const leftArm = new THREE.Mesh(armGeometry, avatarMaterial);
        leftArm.position.set(1.7, 0.7, 2);
        leftArm.rotation.z = Math.PI / 4;
        this.scene.add(leftArm);

        const rightArm = new THREE.Mesh(armGeometry, avatarMaterial);
        rightArm.position.set(2.3, 0.7, 2);
        rightArm.rotation.z = -Math.PI / 4;
        this.scene.add(rightArm);

        const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 32);
        const leftLeg = new THREE.Mesh(legGeometry, avatarMaterial);
        leftLeg.position.set(1.8, 0.25, 2);
        this.scene.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, avatarMaterial);
        rightLeg.position.set(2.2, 0.25, 2);
        this.scene.add(rightLeg);
    }

    async setupAudio() {
        try {
            const backgroundBuffer = await this.loadAudio('sweet.mp3');
            this.backgroundAudio.setBuffer(backgroundBuffer);
            this.backgroundAudio.setLoop(true);
            this.backgroundAudio.setVolume(0.2);
            this.backgroundAudio.play();

            const clickBuffer = await this.loadAudio('sweet.mp3');
            this.clickSound.setBuffer(clickBuffer);
            this.clickSound.setVolume(0.5);
        } catch (error) {
            console.error("Error loading audio:", error);
        }
    }

    loadAudio(url) {
        return new Promise((resolve, reject) => {
            const audioLoader = new THREE.AudioLoader();
            audioLoader.load(
                url,
                (audioBuffer) => resolve(audioBuffer),
                undefined,
                (err) => reject(err)
            );
        });
    }

    init() {
        console.log("🚀 Virtual Gallery loaded");
        this.setupEventListeners();
        if (this.sessionId) this.loadImages(this.sessionId);
        this.animate();
        window.addEventListener("resize", () => this.handleResize());
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }

    setupEventListeners() {
        this.renderer.domElement.addEventListener("click", (event) => this.onCanvasClick(event));
        document.getElementById("uploadForm")?.addEventListener("submit", (e) => this.handleUploadSubmit(e));
        document.getElementById("screenshotForm")?.addEventListener("submit", (e) => this.handleScreenshotSubmit(e));
        document.getElementById("downloadBtn")?.addEventListener("click", () => this.handleDownload());
        document.getElementById("zoomSlider")?.addEventListener("input", () => this.handleZoom());
        document.getElementById("toggleControlsBtn")?.addEventListener("click", () => this.toggleControls());
        document.getElementById("prevPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom - 1));
        document.getElementById("nextPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom + 1));
    }

    toggleControls() {
        const controlPanels = document.querySelectorAll(".control-panel");
        const toggleButton = document.getElementById("toggleControlsBtn");
        controlPanels.forEach(panel => panel.classList.toggle("hidden-panel"));
        toggleButton.textContent = toggleButton.textContent === "Hide Controls" ? "Show Controls" : "Hide Controls";
    }

    setupMovementControls() {
        const moveSpeed = 0.1;
        const keys = { w: false, a: false, s: false, d: false };

        document.addEventListener("keydown", (event) => {
            switch (event.key.toLowerCase()) {
                case "w": keys.w = true; break;
                case "a": keys.a = true; break;
                case "s": keys.s = true; break;
                case "d": keys.d = true; break;
            }
        });

        document.addEventListener("keyup", (event) => {
            switch (event.key.toLowerCase()) {
                case "w": keys.w = false; break;
                case "a": keys.a = false; break;
                case "s": keys.s = false; break;
                case "d": keys.d = false; break;
            }
        });

        const updatePosition = () => {
            if (this.isMoving) return;

            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            if (keys.w) this.camera.position.addScaledVector(direction, moveSpeed);
            if (keys.s) this.camera.position.addScaledVector(direction, -moveSpeed);
            if (keys.a) {
                const left = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                this.camera.position.addScaledVector(left, -moveSpeed);
            }
            if (keys.d) {
                const right = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                this.camera.position.addScaledVector(right, moveSpeed);
            }

            this.checkCollisions();
            requestAnimationFrame(updatePosition);
        };
        updatePosition();
    }

    checkCollisions() {
        this.camera.position.y = 1.6;
        const roomBounds = this.rooms[this.currentRoom].position;
        const minX = roomBounds.x - 7;
        const maxX = roomBounds.x + 7;
        const minZ = roomBounds.z - 7;
        const maxZ = roomBounds.z + 7;

        this.camera.position.x = Math.max(minX, Math.min(maxX, this.camera.position.x));
        this.camera.position.z = Math.max(minZ, Math.min(maxZ, this.camera.position.z));
    }

    moveToRoom(roomIndex) {
        if (roomIndex < 0 || roomIndex >= this.rooms.length || this.isMoving) return;

        this.isMoving = true;
        const settings = this.roomCameraSettings[roomIndex];
        const targetPos = settings.position.clone();
        const lookAtPos = settings.lookAt.clone();
        const startPos = this.camera.position.clone();
        const duration = 1000;
        const startTime = performance.now();

        const animateMove = (time) => {
            const elapsed = time - startTime;
            const t = Math.min(elapsed / duration, 1);
            const easedT = 0.5 - 0.5 * Math.cos(Math.PI * t);
            this.camera.position.lerpVectors(startPos, targetPos, easedT);
            this.camera.lookAt(lookAtPos);
            this.controls.target.copy(lookAtPos);
            this.controls.update();

            if (t < 1) {
                requestAnimationFrame(animateMove);
            } else {
                this.currentRoom = roomIndex;
                this.isMoving = false;
                this.previousCameraState = {
                    position: this.camera.position.clone(),
                    target: this.controls.target.clone()
                };
            }
        };
        requestAnimationFrame(animateMove);
    }

    async loadImages(sessionId) {
        try {
            const response = await fetch(`http://localhost:3000/api/screenshots/${sessionId}/`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            console.log("📸 Found images in session", sessionId + ":", data.screenshots);
            if (!data.screenshots?.length) {
                console.log("No screenshots found");
                return;
            }
            this.imagesToLoad = data.screenshots.map(img => `http://localhost:3000${img}`);
            this.displayImagesInGallery();
        } catch (error) {
            console.error("❌ Error fetching images:", error);
        }
    }

    async displayImagesInGallery() {
        if (!this.imagesToLoad) return;

        this.clearScene();
        const totalImages = this.imagesToLoad.length;
        let imageIndex = 0;

        const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.8 });
        const fallbackMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0 });

        for (let room of this.rooms) {
            const wallLength = room === this.rooms[0] ? 15 : 12;
            const planeWidth = 3.5;
            const planeHeight = 2.5;
            const spacing = 0.5;
            const numImagesPerWall = Math.floor(wallLength / (planeWidth + spacing));

            const wallConfigs = [
                { basePos: new THREE.Vector3(0, 2, -wallLength / 2), rot: 0, dir: 'x' },
                { basePos: new THREE.Vector3(-wallLength / 2, 2, 0), rot: Math.PI / 2, dir: 'z' },
                { basePos: new THREE.Vector3(wallLength / 2, 2, 0), rot: -Math.PI / 2, dir: 'z' },
                { basePos: new THREE.Vector3(0, 2, wallLength / 2), rot: Math.PI, dir: 'x' }
            ];

            for (let wall of wallConfigs) {
                if (imageIndex >= totalImages) break;

                const wallPositions = [];
                for (let i = 0; i < numImagesPerWall && imageIndex < totalImages; i++) {
                    const offset = -wallLength / 2 + (i + 0.5) * (wallLength / numImagesPerWall);
                    const pos = wall.basePos.clone();
                    if (wall.dir === 'x') pos.x += offset;
                    else pos.z += offset;
                    wallPositions.push({ pos, rot: wall.rot });
                }

                for (let { pos, rot } of wallPositions) {
                    const texture = await this.loadTexture(this.imagesToLoad[imageIndex]);
                    let material = texture.image ? 
                        new THREE.MeshStandardMaterial({
                            map: texture,
                            side: THREE.DoubleSide,
                            roughness: 0.2,
                            metalness: 0.0,
                            envMapIntensity: 0.5
                        }) : 
                        fallbackMaterial;

                    const aspectRatio = texture.image ? texture.image.width / texture.image.height : 1;
                    const maxWidth = 3.5;
                    const planeWidth = Math.min(planeHeight * aspectRatio, maxWidth);

                    const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(pos).add(room.position);
                    if (rot === Math.PI) mesh.position.z -= 0.1;
                    if (rot === 0) mesh.position.z += 0.1;
                    mesh.rotation.y = rot;
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData = { filename: this.imagesToLoad[imageIndex] };
                    room.add(mesh);
                    this.images.push({ mesh, filename: this.imagesToLoad[imageIndex] });

                    const frameThickness = 0.1;
                    const frameGeometry = new THREE.BoxGeometry(planeWidth + 0.2, planeHeight + 0.2, frameThickness);
                    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                    frame.position.copy(mesh.position);
                    frame.position.z -= Math.abs(rot) === Math.PI / 2 ? 0 : frameThickness / 2;
                    frame.position.x += Math.abs(rot) === Math.PI / 2 ? (rot > 0 ? -frameThickness / 2 : frameThickness / 2) : 0;
                    frame.rotation.y = rot;
                    frame.castShadow = true;
                    frame.receiveShadow = true;
                    room.add(frame);

                    const spotlight = new THREE.SpotLight(0xffffff, 2.0, 15, Math.PI / 6, 0.7);
                    const lightOffset = 1;
                    spotlight.position.set(
                        pos.x + (Math.abs(rot) === Math.PI / 2 ? (rot > 0 ? lightOffset : -lightOffset) : 0),
                        4.5,
                        pos.z + (Math.abs(rot) === Math.PI / 2 ? 0 : (rot === 0 ? -lightOffset : lightOffset))
                    ).add(room.position);
                    spotlight.target = mesh;
                    spotlight.castShadow = true;
                    spotlight.shadow.mapSize.width = 1024;
                    spotlight.shadow.mapSize.height = 1024;
                    room.add(spotlight);

                    imageIndex++;
                }
            }
        }
    }

    clearScene() {
        this.images.forEach(img => {
            img.mesh.parent.remove(img.mesh);
            img.mesh.geometry.dispose();
            if (img.mesh.material.map) img.mesh.material.map.dispose();
            img.mesh.material.dispose();
        });
        this.images = [];
        this.rooms.forEach(room => {
            const toRemove = room.children.filter(child => 
                child instanceof THREE.SpotLight || 
                (child.material?.color?.getHex() === 0x333333)
            );
            toRemove.forEach(child => room.remove(child));
        });
    }

    loadTexture(filename) {
        return new Promise((resolve, reject) => {
            this.textureLoader.load(
                filename,
                (texture) => {
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.generateMipmaps = true;
                    texture.anisotropy = this.renderer.capabilities.getMaxAnisotropy() || 1;
                    resolve(texture);
                },
                undefined,
                (err) => reject(err)
            );
        });
    }

    onCanvasClick(event) {
        const currentTime = new Date().getTime();
        const timeSinceLastClick = currentTime - this.lastClickTime;

        if (timeSinceLastClick < this.clickDelay) {
            // Double-click detected
            this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            this.raycaster.setFromCamera(this.mouse, this.camera);
            const intersects = this.raycaster.intersectObjects([...this.images.map(img => img.mesh), ...this.scene.children.filter(obj => obj.userData.nextRoom !== undefined)]);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                if (obj.userData.nextRoom !== undefined) {
                    this.moveToRoom(obj.userData.nextRoom);
                } else if (obj.userData.filename) {
                    console.log(`Double-clicked image: ${obj.userData.filename}`);
                    if (!this.clickSound.isPlaying) this.clickSound.play();
                    this.focusImage(obj);
                }
            }
        } else {
            // Single click: Reset camera to previous state
            this.resetCamera();
        }

        this.lastClickTime = currentTime;
    }

    focusImage(mesh) {
        // Store current camera state before focusing
        this.previousCameraState = {
            position: this.camera.position.clone(),
            target: this.controls.target.clone()
        };

        this.camera.updateMatrixWorld();
        this.controls.update();

        const direction = new THREE.Vector3();
        this.camera.getWorldDirection(direction);

        const targetPos = mesh.position.clone().sub(direction.multiplyScalar(2));
        targetPos.y = 1.6;
        const startPos = this.camera.position.clone();
        const duration = 500;
        const startTime = performance.now();

        const animateFocus = (time) => {
            const elapsed = time - startTime;
            const t = Math.min(elapsed / duration, 1);
            this.camera.position.lerpVectors(startPos, targetPos, t);
            this.camera.lookAt(mesh.position);
            this.controls.target.copy(mesh.position);
            this.controls.update();

            if (t < 1) requestAnimationFrame(animateFocus);
        };
        requestAnimationFrame(animateFocus);
    }

    resetCamera() {
        const startPos = this.camera.position.clone();
        const targetPos = this.previousCameraState.position.clone();
        const targetLookAt = this.previousCameraState.target.clone();
        const duration = 500;
        const startTime = performance.now();

        const animateReset = (time) => {
            const elapsed = time - startTime;
            const t = Math.min(elapsed / duration, 1);
            const easedT = 0.5 - 0.5 * Math.cos(Math.PI * t);
            this.camera.position.lerpVectors(startPos, targetPos, easedT);
            this.camera.lookAt(targetLookAt);
            this.controls.target.copy(targetLookAt);
            this.controls.update();

            if (t < 1) requestAnimationFrame(animateReset);
        };
        requestAnimationFrame(animateReset);
    }

    handleDownload() {
        const imgData = this.renderer.domElement.toDataURL("image/png");
        const link = document.createElement("a");
        link.href = imgData;
        link.download = "gallery_view.png";
        link.click();
    }

    handleZoom() {
        const zoomSlider = document.getElementById("zoomSlider");
        const zoomValue = document.getElementById("zoomValue");
        const zoomLevel = parseFloat(zoomSlider.value);
        zoomValue.textContent = zoomLevel.toFixed(1);
        this.controls.maxDistance = zoomLevel;
        this.controls.update();
    }

    async handleScreenshotSubmit(event) {
        event.preventDefault();
        const url = document.getElementById("url")?.value;
        if (!url) return;

        try {
            const response = await fetch("http://localhost:3000/api/capture", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url })
            });
            const result = await response.json();
            if (result.sessionId) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error capturing screenshot:", error);
        }
    }

    async handleUploadSubmit(event) {
        event.preventDefault();
        const fileInput = document.getElementById("images");
        if (!fileInput?.files?.length) return;

        const formData = new FormData();
        for (const file of fileInput.files) {
            formData.append("images", file);
        }

        try {
            const response = await fetch(`http://localhost:3000/api/upload${this.sessionId ? `/${this.sessionId}` : ''}`, {
                method: "POST",
                body: formData
            });
            const result = await response.json();
            if (result.success) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error uploading files:", error);
        }
    }

    handleResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
}

const app = new ThreeJSApp();
app.init();



#positionreset

import * as THREE from "three";
import { OrbitControls } from "OrbitControls"; // Fixed import path

class ThreeJSApp {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        this.roomCameraSettings = [
            { position: new THREE.Vector3(0, 1.6, 5), lookAt: new THREE.Vector3(0, 1.6, 0) },
            { position: new THREE.Vector3(18, 1.6, 5), lookAt: new THREE.Vector3(18, 1.6, 0) }
        ];
        const initialSettings = this.roomCameraSettings[0];
        this.camera.position.copy(initialSettings.position);
        this.camera.lookAt(initialSettings.lookAt);

        this.renderer = new THREE.WebGLRenderer({ alpha: false, antialias: true, preserveDrawingBuffer: true });
        this.renderer.setClearColor(0x000000, 1);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enableZoom = true;
        this.controls.minDistance = 0.5;
        this.controls.maxDistance = 10;
        this.controls.enablePan = false;
        this.controls.screenSpacePanning = false;
        this.controls.maxPolarAngle = Math.PI * 0.75;
        this.controls.target.copy(initialSettings.lookAt);
        this.controls.update();

        this.images = [];
        this.sessionId = localStorage.getItem('sessionId');
        this.textureLoader = new THREE.TextureLoader();

        this.audioListener = new THREE.AudioListener();
        this.camera.add(this.audioListener);
        this.backgroundAudio = new THREE.Audio(this.audioListener);
        this.clickSound = new THREE.Audio(this.audioListener);

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.selectedMesh = null;

        this.rooms = [];
        this.currentRoom = 0;
        this.isMoving = false;

        // Store initial camera state for reset
        this.previousCameraState = {
            position: this.camera.position.clone(),
            target: this.controls.target.clone()
        };

        // Double-click detection
        this.lastClickTime = 0;
        this.clickDelay = 300; // Time in ms for double-click detection

        this.addLighting();
        this.createGallery();
        this.setupAudio();
        this.setupMovementControls();
        this.createAvatar();
    }

    addLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(0, 10, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        this.scene.add(directionalLight);

        const ceilingLight = new THREE.DirectionalLight(0xffffff, 0.8);
        ceilingLight.position.set(0, 10, 0);
        ceilingLight.castShadow = true;
        this.scene.add(ceilingLight);
    }

    createGallery() {
        const concreteColor = 0x888888;
        const concreteRoughness = 0.7;
        const concreteMetalness = 0.1;

        const floorMaterial = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: 0.3,
            metalness: concreteMetalness
        });

        const noiseTexture = new THREE.Texture(this.generateNoiseCanvas(256, 256));
        noiseTexture.needsUpdate = true;
        noiseTexture.wrapS = noiseTexture.wrapT = THREE.RepeatWrapping;
        noiseTexture.repeat.set(4, 4);
        floorMaterial.map = noiseTexture;
        floorMaterial.normalMap = noiseTexture;
        floorMaterial.normalScale.set(0.1, 0.1);

        const ceilingMaterial = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: concreteRoughness,
            metalness: concreteMetalness
        });
        ceilingMaterial.map = noiseTexture;

        const glassMaterial = new THREE.MeshPhysicalMaterial({ 
            color: 0xaaaaaa, 
            transparent: true, 
            opacity: 0.3, 
            roughness: 0, 
            metalness: 0.1, 
            transmission: 0.9 
        });
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xf5f5f5, roughness: 0.3 });

        const room1 = new THREE.Group();
        const floor1 = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), floorMaterial);
        floor1.rotation.x = -Math.PI / 2;
        floor1.receiveShadow = true;
        room1.add(floor1);

        const ceiling1 = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), ceilingMaterial);
        ceiling1.position.y = 5;
        ceiling1.rotation.x = Math.PI / 2;
        ceiling1.receiveShadow = true;
        room1.add(ceiling1);

        const panelSize = 2;
        const panelDepth = 0.2;
        const panelSpacing = 0.5;
        const panelMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: concreteRoughness,
            metalness: concreteMetalness
        });

        for (let i = -2; i <= 2; i++) {
            for (let j = -2; j <= 2; j++) {
                if (Math.abs(i) === 2 && Math.abs(j) === 2) continue;
                const panel = new THREE.Mesh(
                    new THREE.PlaneGeometry(panelSize, panelSize),
                    panelMaterial
                );
                panel.position.set(
                    i * (panelSize + panelSpacing),
                    5 - panelDepth,
                    j * (panelSize + panelSpacing)
                );
                panel.rotation.x = Math.PI / 2;
                panel.receiveShadow = true;
                room1.add(panel);
            }
        }

        const walls1 = [
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial)
        ];
        walls1[0].position.set(0, 2.5, -7.5);
        walls1[1].position.set(0, 2.5, 7.5);
        walls1[1].rotation.y = Math.PI;
        walls1[2].position.set(-7.5, 2.5, 0);
        walls1[2].rotation.y = Math.PI / 2;
        walls1[3].position.set(7.5, 2.5, 0);
        walls1[3].rotation.y = -Math.PI / 2;
        walls1.forEach(wall => {
            wall.receiveShadow = true;
            room1.add(wall);
        });

        const windowFrame = new THREE.Mesh(new THREE.PlaneGeometry(4, 3), glassMaterial);
        windowFrame.position.set(0, 2.5, -7.4);
        room1.add(windowFrame);

        const windowBarsGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        for (let i = -3; i <= 3; i++) {
            const barV = new THREE.Mesh(windowBarsGeometry.clone(), glassMaterial);
            barV.scale.y = 3;
            barV.position.set(i * 0.6, 2.5, -7.4);
            room1.add(barV);
            const barH = new THREE.Mesh(windowBarsGeometry.clone(), glassMaterial);
            barH.scale.x = 4;
            barH.position.set(0, 2.5 + i * 0.5, -7.4);
            room1.add(barH);
        }

        room1.position.set(0, 0, 0);
        this.rooms.push(room1);

        const room2 = new THREE.Group();
        const floor2 = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), floorMaterial);
        floor2.rotation.x = -Math.PI / 2;
        floor2.receiveShadow = true;
        room2.add(floor2);

        const ceiling2 = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), ceilingMaterial);
        ceiling2.position.y = 4;
        ceiling2.rotation.x = Math.PI / 2;
        ceiling2.receiveShadow = true;
        room2.add(ceiling2);

        for (let i = -2; i <= 2; i++) {
            for (let j = -2; j <= 2; j++) {
                if (Math.abs(i) === 2 && Math.abs(j) === 2) continue;
                const panel = new THREE.Mesh(
                    new THREE.PlaneGeometry(panelSize, panelSize),
                    panelMaterial
                );
                panel.position.set(
                    i * (panelSize + panelSpacing),
                    4 - panelDepth,
                    j * (panelSize + panelSpacing)
                );
                panel.rotation.x = Math.PI / 2;
                panel.receiveShadow = true;
                room2.add(panel);
            }
        }

        const walls2 = [
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial)
        ];
        walls2[0].position.set(0, 2, -6);
        walls2[1].position.set(0, 2, 6);
        walls2[1].rotation.y = Math.PI;
        walls2[2].position.set(-6, 2, 0);
        walls2[2].rotation.y = Math.PI / 2;
        walls2[3].position.set(6, 2, 0);
        walls2[3].rotation.y = -Math.PI / 2;
        walls2.forEach(wall => {
            wall.receiveShadow = true;
            room2.add(wall);
        });

        const door2 = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 3.5), glassMaterial);
        door2.position.set(-6, 1.75, 0);
        door2.rotation.y = Math.PI / 2;
        door2.userData = { nextRoom: 0 };
        room2.add(door2);

        room2.position.set(18, 0, 0);
        this.rooms.push(room2);

        this.rooms.forEach(room => this.scene.add(room));
    }

    generateNoiseCanvas(width, height) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext('2d');
        const imageData = context.createImageData(width, height);

        for (let i = 0; i < imageData.data.length; i += 4) {
            const noise = Math.random() * 0.1 + 0.9;
            imageData.data[i] = 136 * noise;
            imageData.data[i + 1] = 136 * noise;
            imageData.data[i + 2] = 136 * noise;
            imageData.data[i + 3] = 255;
        }

        context.putImageData(imageData, 0, 0);
        return canvas;
    }

    createAvatar() {
        const avatarMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3
        });

        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1, 32), avatarMaterial);
        body.position.set(2, 0.5, 2);
        this.scene.add(body);

        const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), avatarMaterial);
        head.position.set(2, 1.2, 2);
        this.scene.add(head);

        const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 32);
        const leftArm = new THREE.Mesh(armGeometry, avatarMaterial);
        leftArm.position.set(1.7, 0.7, 2);
        leftArm.rotation.z = Math.PI / 4;
        this.scene.add(leftArm);

        const rightArm = new THREE.Mesh(armGeometry, avatarMaterial);
        rightArm.position.set(2.3, 0.7, 2);
        rightArm.rotation.z = -Math.PI / 4;
        this.scene.add(rightArm);

        const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 32);
        const leftLeg = new THREE.Mesh(legGeometry, avatarMaterial);
        leftLeg.position.set(1.8, 0.25, 2);
        this.scene.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, avatarMaterial);
        rightLeg.position.set(2.2, 0.25, 2);
        this.scene.add(rightLeg);
    }

    async setupAudio() {
        try {
            const backgroundBuffer = await this.loadAudio('sweet.mp3');
            this.backgroundAudio.setBuffer(backgroundBuffer);
            this.backgroundAudio.setLoop(true);
            this.backgroundAudio.setVolume(0.2);
            this.backgroundAudio.play();

            const clickBuffer = await this.loadAudio('sweet.mp3');
            this.clickSound.setBuffer(clickBuffer);
            this.clickSound.setVolume(0.5);
        } catch (error) {
            console.error("Error loading audio:", error);
        }
    }

    loadAudio(url) {
        return new Promise((resolve, reject) => {
            const audioLoader = new THREE.AudioLoader();
            audioLoader.load(
                url,
                (audioBuffer) => resolve(audioBuffer),
                undefined,
                (err) => reject(err)
            );
        });
    }

    init() {
        console.log("🚀 Virtual Gallery loaded");
        this.setupEventListeners();
        if (this.sessionId) this.loadImages(this.sessionId);
        this.animate();
        window.addEventListener("resize", () => this.handleResize());
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }

    setupEventListeners() {
        this.renderer.domElement.addEventListener("click", (event) => this.onCanvasClick(event));
        document.getElementById("uploadForm")?.addEventListener("submit", (e) => this.handleUploadSubmit(e));
        document.getElementById("screenshotForm")?.addEventListener("submit", (e) => this.handleScreenshotSubmit(e));
        document.getElementById("downloadBtn")?.addEventListener("click", () => this.handleDownload());
        document.getElementById("zoomSlider")?.addEventListener("input", () => this.handleZoom());
        document.getElementById("toggleControlsBtn")?.addEventListener("click", () => this.toggleControls());
        document.getElementById("prevPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom - 1));
        document.getElementById("nextPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom + 1));
    }

    toggleControls() {
        const controlPanels = document.querySelectorAll(".control-panel");
        const toggleButton = document.getElementById("toggleControlsBtn");
        controlPanels.forEach(panel => panel.classList.toggle("hidden-panel"));
        toggleButton.textContent = toggleButton.textContent === "Hide Controls" ? "Show Controls" : "Hide Controls";
    }

    setupMovementControls() {
        const moveSpeed = 0.1;
        const keys = { w: false, a: false, s: false, d: false };

        document.addEventListener("keydown", (event) => {
            switch (event.key.toLowerCase()) {
                case "w": keys.w = true; break;
                case "a": keys.a = true; break;
                case "s": keys.s = true; break;
                case "d": keys.d = true; break;
            }
        });

        document.addEventListener("keyup", (event) => {
            switch (event.key.toLowerCase()) {
                case "w": keys.w = false; break;
                case "a": keys.a = false; break;
                case "s": keys.s = false; break;
                case "d": keys.d = false; break;
            }
        });

        const updatePosition = () => {
            if (this.isMoving) return;

            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            if (keys.w) this.camera.position.addScaledVector(direction, moveSpeed);
            if (keys.s) this.camera.position.addScaledVector(direction, -moveSpeed);
            if (keys.a) {
                const left = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                this.camera.position.addScaledVector(left, -moveSpeed);
            }
            if (keys.d) {
                const right = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                this.camera.position.addScaledVector(right, moveSpeed);
            }

            this.checkCollisions();
            requestAnimationFrame(updatePosition);
        };
        updatePosition();
    }

    checkCollisions() {
        this.camera.position.y = 1.6;
        const roomBounds = this.rooms[this.currentRoom].position;
        const minX = roomBounds.x - 7;
        const maxX = roomBounds.x + 7;
        const minZ = roomBounds.z - 7;
        const maxZ = roomBounds.z + 7;

        this.camera.position.x = Math.max(minX, Math.min(maxX, this.camera.position.x));
        this.camera.position.z = Math.max(minZ, Math.min(maxZ, this.camera.position.z));
    }

    moveToRoom(roomIndex) {
        if (roomIndex < 0 || roomIndex >= this.rooms.length || this.isMoving) return;

        this.isMoving = true;
        const settings = this.roomCameraSettings[roomIndex];
        const targetPos = settings.position.clone();
        const lookAtPos = settings.lookAt.clone();
        const startPos = this.camera.position.clone();
        const duration = 1000;
        const startTime = performance.now();

        const animateMove = (time) => {
            const elapsed = time - startTime;
            const t = Math.min(elapsed / duration, 1);
            const easedT = 0.5 - 0.5 * Math.cos(Math.PI * t);
            this.camera.position.lerpVectors(startPos, targetPos, easedT);
            this.camera.lookAt(lookAtPos);
            this.controls.target.copy(lookAtPos);
            this.controls.update();

            if (t < 1) {
                requestAnimationFrame(animateMove);
            } else {
                this.currentRoom = roomIndex;
                this.isMoving = false;
                this.previousCameraState = {
                    position: this.camera.position.clone(),
                    target: this.controls.target.clone()
                };
            }
        };
        requestAnimationFrame(animateMove);
    }

    async loadImages(sessionId) {
        try {
            const response = await fetch(`http://localhost:3000/api/screenshots/${sessionId}/`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            console.log("📸 Found images in session", sessionId + ":", data.screenshots);
            if (!data.screenshots?.length) {
                console.log("No screenshots found");
                return;
            }
            this.imagesToLoad = data.screenshots.map(img => `http://localhost:3000${img}`);
            this.displayImagesInGallery();
        } catch (error) {
            console.error("❌ Error fetching images:", error);
        }
    }

    async displayImagesInGallery() {
        if (!this.imagesToLoad) return;

        this.clearScene();
        const totalImages = this.imagesToLoad.length;
        let imageIndex = 0;

        const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.8 });
        const fallbackMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0 });

        for (let room of this.rooms) {
            const wallLength = room === this.rooms[0] ? 15 : 12;
            const planeWidth = 3.5;
            const planeHeight = 2.5;
            const spacing = 0.5;
            const numImagesPerWall = Math.floor(wallLength / (planeWidth + spacing));

            const wallConfigs = [
                { basePos: new THREE.Vector3(0, 2, -wallLength / 2), rot: 0, dir: 'x' },
                { basePos: new THREE.Vector3(-wallLength / 2, 2, 0), rot: Math.PI / 2, dir: 'z' },
                { basePos: new THREE.Vector3(wallLength / 2, 2, 0), rot: -Math.PI / 2, dir: 'z' },
                { basePos: new THREE.Vector3(0, 2, wallLength / 2), rot: Math.PI, dir: 'x' }
            ];

            for (let wall of wallConfigs) {
                if (imageIndex >= totalImages) break;

                const wallPositions = [];
                for (let i = 0; i < numImagesPerWall && imageIndex < totalImages; i++) {
                    const offset = -wallLength / 2 + (i + 0.5) * (wallLength / numImagesPerWall);
                    const pos = wall.basePos.clone();
                    if (wall.dir === 'x') pos.x += offset;
                    else pos.z += offset;
                    wallPositions.push({ pos, rot: wall.rot });
                }

                for (let { pos, rot } of wallPositions) {
                    const texture = await this.loadTexture(this.imagesToLoad[imageIndex]);
                    let material = texture.image ? 
                        new THREE.MeshStandardMaterial({
                            map: texture,
                            side: THREE.DoubleSide,
                            roughness: 0.2,
                            metalness: 0.0,
                            envMapIntensity: 0.5
                        }) : 
                        fallbackMaterial;

                    const aspectRatio = texture.image ? texture.image.width / texture.image.height : 1;
                    const maxWidth = 3.5;
                    const planeWidth = Math.min(planeHeight * aspectRatio, maxWidth);

                    const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(pos).add(room.position);
                    if (rot === Math.PI) mesh.position.z -= 0.1;
                    if (rot === 0) mesh.position.z += 0.1;
                    mesh.rotation.y = rot;
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData = { filename: this.imagesToLoad[imageIndex] };
                    room.add(mesh);
                    this.images.push({ mesh, filename: this.imagesToLoad[imageIndex] });

                    const frameThickness = 0.1;
                    const frameGeometry = new THREE.BoxGeometry(planeWidth + 0.2, planeHeight + 0.2, frameThickness);
                    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                    frame.position.copy(mesh.position);
                    frame.position.z -= Math.abs(rot) === Math.PI / 2 ? 0 : frameThickness / 2;
                    frame.position.x += Math.abs(rot) === Math.PI / 2 ? (rot > 0 ? -frameThickness / 2 : frameThickness / 2) : 0;
                    frame.rotation.y = rot;
                    frame.castShadow = true;
                    frame.receiveShadow = true;
                    room.add(frame);

                    const spotlight = new THREE.SpotLight(0xffffff, 2.0, 15, Math.PI / 6, 0.7);
                    const lightOffset = 1;
                    spotlight.position.set(
                        pos.x + (Math.abs(rot) === Math.PI / 2 ? (rot > 0 ? lightOffset : -lightOffset) : 0),
                        4.5,
                        pos.z + (Math.abs(rot) === Math.PI / 2 ? 0 : (rot === 0 ? -lightOffset : lightOffset))
                    ).add(room.position);
                    spotlight.target = mesh;
                    spotlight.castShadow = true;
                    spotlight.shadow.mapSize.width = 1024;
                    spotlight.shadow.mapSize.height = 1024;
                    room.add(spotlight);

                    imageIndex++;
                }
            }
        }
    }

    clearScene() {
        this.images.forEach(img => {
            img.mesh.parent.remove(img.mesh);
            img.mesh.geometry.dispose();
            if (img.mesh.material.map) img.mesh.material.map.dispose();
            img.mesh.material.dispose();
        });
        this.images = [];
        this.rooms.forEach(room => {
            const toRemove = room.children.filter(child => 
                child instanceof THREE.SpotLight || 
                (child.material?.color?.getHex() === 0x333333)
            );
            toRemove.forEach(child => room.remove(child));
        });
    }

    loadTexture(filename) {
        return new Promise((resolve, reject) => {
            this.textureLoader.load(
                filename,
                (texture) => {
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.generateMipmaps = true;
                    texture.anisotropy = this.renderer.capabilities.getMaxAnisotropy() || 1;
                    resolve(texture);
                },
                undefined,
                (err) => reject(err)
            );
        });
    }

    onCanvasClick(event) {
        const currentTime = new Date().getTime();
        const timeSinceLastClick = currentTime - this.lastClickTime;

        if (timeSinceLastClick < this.clickDelay) {
            // Double-click detected
            this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            this.raycaster.setFromCamera(this.mouse, this.camera);
            const intersects = this.raycaster.intersectObjects([...this.images.map(img => img.mesh), ...this.scene.children.filter(obj => obj.userData.nextRoom !== undefined)]);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                if (obj.userData.nextRoom !== undefined) {
                    this.moveToRoom(obj.userData.nextRoom);
                } else if (obj.userData.filename) {
                    console.log(`Double-clicked image: ${obj.userData.filename}`);
                    if (!this.clickSound.isPlaying) this.clickSound.play();
                    this.focusImage(obj);
                }
            }
        } else {
            // Single click: Reset camera to previous state
            this.resetCamera();
        }

        this.lastClickTime = currentTime;
    }

    focusImage(mesh) {
        // Store current camera state before focusing
        this.previousCameraState = {
            position: this.camera.position.clone(),
            target: this.controls.target.clone()
        };

        this.camera.updateMatrixWorld();
        this.controls.update();

        const direction = new THREE.Vector3();
        this.camera.getWorldDirection(direction);

        const targetPos = mesh.position.clone().sub(direction.multiplyScalar(2));
        targetPos.y = 1.6;
        const startPos = this.camera.position.clone();
        const duration = 500;
        const startTime = performance.now();

        const animateFocus = (time) => {
            const elapsed = time - startTime;
            const t = Math.min(elapsed / duration, 1);
            this.camera.position.lerpVectors(startPos, targetPos, t);
            this.camera.lookAt(mesh.position);
            this.controls.target.copy(mesh.position);
            this.controls.update();

            if (t < 1) requestAnimationFrame(animateFocus);
        };
        requestAnimationFrame(animateFocus);
    }

    resetCamera() {
        const startPos = this.camera.position.clone();
        const targetPos = this.previousCameraState.position.clone();
        const targetLookAt = this.previousCameraState.target.clone();
        const duration = 500;
        const startTime = performance.now();

        const animateReset = (time) => {
            const elapsed = time - startTime;
            const t = Math.min(elapsed / duration, 1);
            const easedT = 0.5 - 0.5 * Math.cos(Math.PI * t);
            this.camera.position.lerpVectors(startPos, targetPos, easedT);
            this.camera.lookAt(targetLookAt);
            this.controls.target.copy(targetLookAt);
            this.controls.update();

            if (t < 1) requestAnimationFrame(animateReset);
        };
        requestAnimationFrame(animateReset);
    }

    handleDownload() {
        const imgData = this.renderer.domElement.toDataURL("image/png");
        const link = document.createElement("a");
        link.href = imgData;
        link.download = "gallery_view.png";
        link.click();
    }

    handleZoom() {
        const zoomSlider = document.getElementById("zoomSlider");
        const zoomValue = document.getElementById("zoomValue");
        const zoomLevel = parseFloat(zoomSlider.value);
        zoomValue.textContent = zoomLevel.toFixed(1);
        this.controls.maxDistance = zoomLevel;
        this.controls.update();
    }

    async handleScreenshotSubmit(event) {
        event.preventDefault();
        const url = document.getElementById("url")?.value;
        if (!url) return;

        try {
            const response = await fetch("http://localhost:3000/api/capture", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url })
            });
            const result = await response.json();
            if (result.sessionId) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error capturing screenshot:", error);
        }
    }

    async handleUploadSubmit(event) {
        event.preventDefault();
        const fileInput = document.getElementById("images");
        if (!fileInput?.files?.length) return;

        const formData = new FormData();
        for (const file of fileInput.files) {
            formData.append("images", file);
        }

        try {
            const response = await fetch(`http://localhost:3000/api/upload${this.sessionId ? `/${this.sessionId}` : ''}`, {
                method: "POST",
                body: formData
            });
            const result = await response.json();
            if (result.success) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error uploading files:", error);
        }
    }

    handleResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
}

const app = new ThreeJSApp();
app.init();




#no scene
import * as THREE from "three";
import { PointerLockControls } from "PointerLockControls";
import { OrbitControls } from "OrbitControls";

class CustomPointerLockControls extends PointerLockControls {
    constructor(camera, domElement) {
        super(camera, domElement);
        this.sensitivity = 0.001;
    }

    getObject() {
        return this.camera;
    }

    lock() {
        super.lock();
        this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove.bind(this));
    }

    unlock() {
        super.unlock();
        this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove.bind(this));
    }

    onMouseMove(event) {
        if (this.isLocked === true) {
            const movementX = event.movementX * this.sensitivity;
            const movementY = event.movementY * this.sensitivity;

            const euler = new THREE.Euler(0, 0, 0, "YXZ");
            euler.setFromQuaternion(this.camera.quaternion);

            euler.y -= movementX;
            euler.x -= movementY;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));

            this.camera.quaternion.setFromEuler(euler);
        }
    }

    setSensitivity(value) {
        this.sensitivity = value;
    }
}

class ThreeJSApp {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        this.roomCameraSettings = [
            { position: new THREE.Vector3(0, 1.6, 5), lookAt: new THREE.Vector3(0, 1.6, 0) },
            { position: new THREE.Vector3(18, 1.6, 5), lookAt: new THREE.Vector3(18, 1.6, 0) }
        ];
        const initialSettings = this.roomCameraSettings[0];
        this.camera.position.copy(initialSettings.position);
        this.camera.lookAt(initialSettings.lookAt);

        this.renderer = new THREE.WebGLRenderer({ alpha: false, antialias: true, preserveDrawingBuffer: true });
        this.renderer.setClearColor(0x000000, 1);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);

        this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || ('ontouchstart' in window);
        
        if (this.isMobile) {
            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.controls.target.copy(initialSettings.lookAt);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;
            this.controls.minDistance = 1;
            this.controls.maxDistance = 10;
            this.controls.enablePan = true;
            this.controls.enableZoom = true;
        } else {
            this.controls = new CustomPointerLockControls(this.camera, this.renderer.domElement);
            this.controls.getObject().position.copy(initialSettings.position);
        }

        this.images = [];
        this.sessionId = localStorage.getItem('sessionId') || 'default-session'; // Default session for testing
        this.imagesToLoad = []; // Initialize to avoid undefined errors
        this.textureLoader = new THREE.TextureLoader();

        this.audioListener = new THREE.AudioListener();
        this.camera.add(this.audioListener);
        this.backgroundAudio = new THREE.Audio(this.audioListener);
        this.clickSound = new THREE.Audio(this.audioListener);

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.selectedMesh = null;

        this.rooms = [];
        this.currentRoom = 0;
        this.isMoving = false;
        this.isFocused = false;
        this.isLocked = false;
        this.controlsVisible = true; // For toggleControls

        this.previousCameraState = {
            position: this.camera.position.clone(),
            rotation: this.camera.rotation.clone(),
            target: initialSettings.lookAt.clone()
        };

        this.lastClickTime = 0;
        this.clickDelay = 300;
        this.moveSpeed = 0.1;
        this.keys = { w: false, a: false, s: false, d: false };

        this.addLighting();
        this.createGallery();
        this.setupAudio();
        this.setupEventListeners();
        this.createAvatar();
        this.loadImages(this.sessionId); // Force image load for testing
    }

    addLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        this.scene.add(directionalLight);
    }

    createGallery() {
        const concreteColor = 0x888888;
        const concreteRoughness = 0.7;
        const concreteMetalness = 0.1;

        const floorMaterial = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: 0.3,
            metalness: concreteMetalness
        });

        const noiseTexture = new THREE.Texture(this.generateNoiseCanvas(256, 256));
        noiseTexture.needsUpdate = true;
        noiseTexture.wrapS = noiseTexture.wrapT = THREE.RepeatWrapping;
        noiseTexture.repeat.set(4, 4);
        floorMaterial.map = noiseTexture;
        floorMaterial.normalMap = noiseTexture;
        floorMaterial.normalScale.set(0.1, 0.1);

        const ceilingMaterial = new THREE.MeshStandardMaterial({
            color: 0xaaaaaa,
            roughness: 0.4,
            metalness: concreteMetalness
        });
        ceilingMaterial.map = noiseTexture;

        const glassMaterial = new THREE.MeshPhysicalMaterial({ 
            color: 0xaaaaaa, 
            transparent: true, 
            opacity: 0.3, 
            roughness: 0, 
            metalness: 0.1, 
            transmission: 0.9 
        });
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xf5f5f5, roughness: 0.3 });

        const room1 = new THREE.Group();
        const floor1 = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), floorMaterial);
        floor1.rotation.x = -Math.PI / 2;
        floor1.receiveShadow = true;
        room1.add(floor1);

        const ceiling1 = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), ceilingMaterial);
        ceiling1.position.y = 5;
        ceiling1.rotation.x = Math.PI / 2;
        ceiling1.receiveShadow = true;
        room1.add(ceiling1);

        const panelSize = 2;
        const panelDepth = 0.2;
        const panelSpacing = 0.5;
        const panelMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: concreteRoughness,
            metalness: concreteMetalness
        });

        for (let i = -2; i <= 2; i++) {
            for (let j = -2; j <= 2; j++) {
                if (i === 0 && j === 0) continue; // Skip center for skylight
                if (Math.abs(i) === 2 && Math.abs(j) === 2) continue;
                const panel = new THREE.Mesh(
                    new THREE.PlaneGeometry(panelSize, panelSize),
                    panelMaterial
                );
                panel.position.set(
                    i * (panelSize + panelSpacing),
                    5 - panelDepth,
                    j * (panelSize + panelSpacing)
                );
                panel.rotation.x = Math.PI / 2;
                panel.receiveShadow = true;
                room1.add(panel);

                const cofferLight = new THREE.SpotLight(0xffffff, 1.5, 5, Math.PI / 4, 0.5);
                cofferLight.position.set(
                    i * (panelSize + panelSpacing),
                    5 - panelDepth - 0.1,
                    j * (panelSize + panelSpacing)
                );
                cofferLight.target.position.set(
                    i * (panelSize + panelSpacing),
                    0,
                    j * (panelSize + panelSpacing)
                );
                cofferLight.castShadow = false;
                room1.add(cofferLight);
                room1.add(cofferLight.target);
            }
        }

        const skylightGeometry = new THREE.PlaneGeometry(panelSize, panelSize);
        const skylightMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x87ceeb,
            transparent: true,
            opacity: 0.6,
            roughness: 0,
            metalness: 0.1,
            transmission: 0.9
        });
        const skylight = new THREE.Mesh(skylightGeometry, skylightMaterial);
        skylight.position.set(0, 5.01, 0);
        skylight.rotation.x = Math.PI / 2;
        room1.add(skylight);

        const skylightLight = new THREE.DirectionalLight(0xffffff, 0.5);
        skylightLight.position.set(0, 10, 0);
        skylightLight.target.position.set(0, 0, 0);
        skylightLight.castShadow = true;
        skylightLight.shadow.mapSize.width = 1024;
        skylightLight.shadow.mapSize.height = 1024;
        room1.add(skylightLight);
        room1.add(skylightLight.target);

        const walls1 = [
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial)
        ];
        walls1[0].position.set(0, 2.5, -7.5);
        walls1[1].position.set(0, 2.5, 7.5);
        walls1[1].rotation.y = Math.PI;
        walls1[2].position.set(-7.5, 2.5, 0);
        walls1[2].rotation.y = Math.PI / 2;
        walls1[3].position.set(7.5, 2.5, 0);
        walls1[3].rotation.y = -Math.PI / 2;
        walls1.forEach(wall => {
            wall.receiveShadow = true;
            room1.add(wall);
        });

        const windowFrame = new THREE.Mesh(new THREE.PlaneGeometry(4, 3), glassMaterial);
        windowFrame.position.set(0, 2.5, -7.4);
        room1.add(windowFrame);

        const windowBarsGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        for (let i = -3; i <= 3; i++) {
            const barV = new THREE.Mesh(windowBarsGeometry.clone(), glassMaterial);
            barV.scale.y = 3;
            barV.position.set(i * 0.6, 2.5, -7.4);
            room1.add(barV);
            const barH = new THREE.Mesh(windowBarsGeometry.clone(), glassMaterial);
            barH.scale.x = 4;
            barH.position.set(0, 2.5 + i * 0.5, -7.4);
            room1.add(barH);
        }

        room1.position.set(0, 0, 0);
        this.rooms.push(room1);

        const room2 = new THREE.Group();
        const floor2 = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), floorMaterial);
        floor2.rotation.x = -Math.PI / 2;
        floor2.receiveShadow = true;
        room2.add(floor2);

        const ceiling2 = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), ceilingMaterial);
        ceiling2.position.y = 4;
        ceiling2.rotation.x = Math.PI / 2;
        ceiling2.receiveShadow = true;
        room2.add(ceiling2);

        for (let i = -2; i <= 2; i++) {
            for (let j = -2; j <= 2; j++) {
                if (Math.abs(i) === 2 && Math.abs(j) === 2) continue;
                const panel = new THREE.Mesh(
                    new THREE.PlaneGeometry(panelSize, panelSize),
                    panelMaterial
                );
                panel.position.set(
                    i * (panelSize + panelSpacing),
                    4 - panelDepth,
                    j * (panelSize + panelSpacing)
                );
                panel.rotation.x = Math.PI / 2;
                panel.receiveShadow = true;
                room2.add(panel);

                const cofferLight = new THREE.SpotLight(0xffffff, 1.5, 5, Math.PI / 4, 0.5);
                cofferLight.position.set(
                    i * (panelSize + panelSpacing),
                    4 - panelDepth - 0.1,
                    j * (panelSize + panelSpacing)
                );
                cofferLight.target.position.set(
                    i * (panelSize + panelSpacing),
                    0,
                    j * (panelSize + panelSpacing)
                );
                cofferLight.castShadow = false;
                room2.add(cofferLight);
                room2.add(cofferLight.target);
            }
        }

        const walls2 = [
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial)
        ];
        walls2[0].position.set(0, 2, -6);
        walls2[1].position.set(0, 2, 6);
        walls2[1].rotation.y = Math.PI;
        walls2[2].position.set(-6, 2, 0);
        walls2[2].rotation.y = Math.PI / 2;
        walls2[3].position.set(6, 2, 0);
        walls2[3].rotation.y = -Math.PI / 2;
        walls2.forEach(wall => {
            wall.receiveShadow = true;
            room2.add(wall);
        });

        const door2 = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 3.5), glassMaterial);
        door2.position.set(-6, 1.75, 0);
        door2.rotation.y = Math.PI / 2;
        door2.userData = { nextRoom: 0 };
        room2.add(door2);

        room2.position.set(18, 0, 0);
        this.rooms.push(room2);

        this.rooms.forEach(room => this.scene.add(room));
    }

    generateNoiseCanvas(width, height) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext('2d');
        const imageData = context.createImageData(width, height);

        for (let i = 0; i < imageData.data.length; i += 4) {
            const noise = Math.random() * 0.1 + 0.9;
            imageData.data[i] = 136 * noise;
            imageData.data[i + 1] = 136 * noise;
            imageData.data[i + 2] = 136 * noise;
            imageData.data[i + 3] = 255;
        }

        context.putImageData(imageData, 0, 0);
        return canvas;
    }

    createAvatar() {
        this.avatarGroup = new THREE.Group();
        const avatarMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3
        });

        const clickablePlane = new THREE.Mesh(
            new THREE.PlaneGeometry(0.5, 0.5),
            new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.0 })
        );
        clickablePlane.position.set(2, 1.7, 2);
        this.avatarGroup.add(clickablePlane);

        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1, 32), avatarMaterial);
        body.position.set(2, 0.5, 2);
        this.avatarGroup.add(body);

        const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), avatarMaterial);
        head.position.set(2, 1.2, 2);
        this.avatarGroup.add(head);

        const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 32);
        const leftArm = new THREE.Mesh(armGeometry, avatarMaterial);
        leftArm.position.set(1.7, 0.7, 2);
        leftArm.rotation.z = Math.PI / 4;
        this.avatarGroup.add(leftArm);

        const rightArm = new THREE.Mesh(armGeometry, avatarMaterial);
        rightArm.position.set(2.3, 0.7, 2);
        rightArm.rotation.z = -Math.PI / 4;
        this.avatarGroup.add(rightArm);

        const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 32);
        const leftLeg = new THREE.Mesh(legGeometry, avatarMaterial);
        leftLeg.position.set(1.8, 0.25, 2);
        this.avatarGroup.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, avatarMaterial);
        rightLeg.position.set(2.2, 0.25, 2);
        this.avatarGroup.add(rightLeg);

        this.avatarGroup.userData = { isAvatar: true };
        this.scene.add(this.avatarGroup);

        this.updateAvatarPosition();
    }

    updateAvatarPosition() {
        if (this.isMobile) {
            const roomCenter = this.rooms[this.currentRoom].position.clone();
            this.avatarGroup.position.copy(roomCenter);
            this.avatarGroup.position.y = 0.5;
        } else {
            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize().multiplyScalar(2);
            this.avatarGroup.position.copy(this.camera.position).add(direction);
            this.avatarGroup.position.y = 0.5;
        }
    }

    async setupAudio() {
        try {
            const backgroundBuffer = await this.loadAudio('./assets/sweet.mp3');
            this.backgroundAudio.setBuffer(backgroundBuffer);
            this.backgroundAudio.setLoop(true);
            this.backgroundAudio.setVolume(0.2);
            this.backgroundAudio.play();

            const clickBuffer = await this.loadAudio('./assets/sweet.mp3');
            this.clickSound.setBuffer(clickBuffer);
            this.clickSound.setVolume(0.5);
        } catch (error) {
            console.error("Error loading audio:", error);
        }
    }

    loadAudio(url) {
        return new Promise((resolve, reject) => {
            const audioLoader = new THREE.AudioLoader();
            audioLoader.load(
                url,
                (audioBuffer) => resolve(audioBuffer),
                undefined,
                (err) => reject(err)
            );
        });
    }

    init() {
        console.log("🚀 Virtual Gallery loaded");
        this.setupEventListeners();
        this.loadImages(this.sessionId); // Ensure images load on init
        this.animate();
        window.addEventListener("resize", () => this.handleResize());
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        this.update();
        this.renderer.render(this.scene, this.camera);
        if (this.isMobile) this.controls.update();
        this.updateAvatarPosition();
    }

    setupEventListeners() {
        const tutorial = document.createElement("div");
        tutorial.id = "tutorialOverlay";
        tutorial.style.cssText = "position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:white; background:rgba(0,0,0,0.7); padding:20px; border-radius:5px; z-index:11; text-align:center;";
        if (this.isMobile) {
            tutorial.innerHTML = "Swipe to look around, pinch to zoom, tap artwork to focus, tap avatar for help.";
        } else {
            tutorial.innerHTML = "Click to enter the gallery. Use W, A, S, D to move, mouse to look, double-click art to focus, click avatar for help.";
        }
        document.body.appendChild(tutorial);

        this.renderer.domElement.addEventListener(this.isMobile ? "touchstart" : "click", (event) => this.onCanvasClick(event));
        if (!this.isMobile) {
            document.addEventListener("keydown", (event) => this.onKeyDown(event));
            document.addEventListener("keyup", (event) => this.onKeyUp(event));
            this.renderer.domElement.addEventListener("click", () => {
                if (!this.isLocked && !this.isFocused) {
                    this.controls.lock();
                    tutorial.style.display = "none";
                }
            });
            document.addEventListener("pointerlockchange", () => {
                this.isLocked = document.pointerLockElement === this.renderer.domElement;
                if (!this.isLocked) this.isFocused = false;
            });
            document.addEventListener("pointerlockerror", () => {
                console.error("Pointer Lock failed");
            });
        } else {
            tutorial.style.display = "none";
        }

        document.getElementById("uploadForm")?.addEventListener("submit", (e) => this.handleUploadSubmit(e));
        document.getElementById("screenshotForm")?.addEventListener("submit", (e) => this.handleScreenshotSubmit(e));
        document.getElementById("downloadBtn")?.addEventListener("click", () => this.handleDownload());
        document.getElementById("zoomSlider")?.addEventListener("input", () => this.handleZoom());
        document.getElementById("toggleControlsBtn")?.addEventListener("click", () => this.toggleControls());
        document.getElementById("prevPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom - 1));
        document.getElementById("nextPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom + 1));
        if (!this.isMobile) {
            document.getElementById("sensitivitySlider")?.addEventListener("input", () => {
                const sensitivitySlider = document.getElementById("sensitivitySlider");
                const sensitivityValue = document.getElementById("sensitivityValue");
                const sensitivity = parseFloat(sensitivitySlider.value);
                sensitivityValue.textContent = sensitivity.toFixed(3);
                this.controls.setSensitivity(sensitivity);
            });
        } else {
            const sensitivityGroup = document.querySelector(".slider-group:last-child");
            if (sensitivityGroup) sensitivityGroup.style.display = "none";
        }
    }

    toggleControls() {
        this.controlsVisible = !this.controlsVisible;
        const controlPanels = document.querySelectorAll(".control-panel");
        const toggleButton = document.getElementById("toggleControlsBtn");

        controlPanels.forEach(panel => {
            panel.classList.toggle("hidden-panel", !this.controlsVisible);
        });

        toggleButton.textContent = this.controlsVisible ? "Hide Controls" : "Show Controls";
        toggleButton.querySelector("i").className = this.controlsVisible ? "fas fa-eye" : "fas fa-eye-slash";
        console.log(this.controlsVisible ? "🖥️ Controls visible" : "🖥️ Controls hidden");
    }

    onKeyDown(event) {
        switch (event.key.toLowerCase()) {
            case "w": this.keys.w = true; break;
            case "a": this.keys.a = true; break;
            case "s": this.keys.s = true; break;
            case "d": this.keys.d = true; break;
            case "escape": this.controls.unlock(); break;
        }
    }

    onKeyUp(event) {
        switch (event.key.toLowerCase()) {
            case "w": this.keys.w = false; break;
            case "a": this.keys.a = false; break;
            case "s": this.keys.s = false; break;
            case "d": this.keys.d = false; break;
        }
    }

    update() {
        if (!this.isMobile && this.isLocked && !this.isMoving && !this.isFocused) {
            const movement = new THREE.Vector3();
            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            if (this.keys.w) movement.addScaledVector(direction, this.moveSpeed);
            if (this.keys.s) movement.addScaledVector(direction, -this.moveSpeed);
            if (this.keys.a) {
                const left = new THREE.Vector3().crossVectors(this.camera.up, direction).normalize();
                movement.addScaledVector(left, -this.moveSpeed);
            }
            if (this.keys.d) {
                const right = new THREE.Vector3().crossVectors(this.camera.up, direction).normalize();
                movement.addScaledVector(right, this.moveSpeed);
            }

            this.controls.getObject().position.add(movement);
            this.checkCollisions();
        }
    }

    checkCollisions() {
        if (!this.isMobile) {
            this.camera.position.y = 1.6;
            const roomBounds = this.rooms[this.currentRoom].position;
            const minX = roomBounds.x - 7;
            const maxX = roomBounds.x + 7;
            const minZ = roomBounds.z - 7;
            const maxZ = roomBounds.z + 7;

            this.camera.position.x = Math.max(minX, Math.min(maxX, this.camera.position.x));
            this.camera.position.z = Math.max(minZ, Math.min(maxZ, this.camera.position.z));
            this.controls.getObject().position.copy(this.camera.position);
        }
    }

    moveToRoom(roomIndex) {
        if (roomIndex < 0 || roomIndex >= this.rooms.length || this.isMoving) return;

        this.isMoving = true;
        const settings = this.roomCameraSettings[roomIndex];
        const targetPos = settings.position.clone();
        const targetLookAt = settings.lookAt.clone();
        const startPos = this.camera.position.clone();
        const startLookAt = this.isMobile ? this.controls.target.clone() : this.camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(5).add(this.camera.position);
        const duration = 1000;
        const startTime = performance.now();

        const animateMove = (time) => {
            const elapsed = time - startTime;
            const t = Math.min(elapsed / duration, 1);
            const easedT = 0.5 - 0.5 * Math.cos(Math.PI * t);
            this.camera.position.lerpVectors(startPos, targetPos, easedT);
            if (this.isMobile) {
                this.controls.target.lerpVectors(startLookAt, targetLookAt, easedT);
            } else {
                this.controls.getObject().position.copy(this.camera.position);
                this.camera.lookAt(targetLookAt);
            }
            this.checkCollisions();

            if (t < 1) {
                requestAnimationFrame(animateMove);
            } else {
                this.currentRoom = roomIndex;
                this.isMoving = false;
                this.isFocused = false;
                this.updateCameraState();
                if (!this.isMobile && this.isLocked) this.controls.lock();
            }
        };
        requestAnimationFrame(animateMove);
    }

    async loadImages(sessionId) {
        try {
            this.clearScene(); // Clear existing images before loading new ones
            const response = await fetch(`http://localhost:3000/api/screenshots/${sessionId}/`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            console.log("📸 Found images in session", sessionId + ":", data.screenshots);
            if (!data.screenshots?.length) {
                console.log("No screenshots found, using dummy data for testing");
                this.imagesToLoad = [
                    "https://via.placeholder.com/350x250",
                    "https://via.placeholder.com/350x250"
                ]; // Dummy data for testing
            } else {
                this.imagesToLoad = data.screenshots.map(img => `http://localhost:3000${img}`);
            }
            await this.displayImagesInGallery();
        } catch (error) {
            console.error("❌ Error fetching images:", error);
            this.imagesToLoad = [
                "https://via.placeholder.com/350x250",
                "https://via.placeholder.com/350x250"
            ]; // Fallback dummy data
            await this.displayImagesInGallery();
        }
    }

    async displayImagesInGallery() {
        if (!this.imagesToLoad || !this.imagesToLoad.length) {
            console.warn("No images to load");
            return;
        }

        const totalImages = this.imagesToLoad.length;
        let imageIndex = 0;

        const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.8 });
        const fallbackMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0 });

        for (let room of this.rooms) {
            const wallLength = room === this.rooms[0] ? 15 : 12;
            const planeWidth = 3.5;
            const planeHeight = 2.5;
            const spacing = 0.5;
            const imageOffset = 0.1;
            const backWallOffset = 0.3;
            const numImagesPerWall = Math.floor(wallLength / (planeWidth + spacing));

            const wallConfigs = [
                { basePos: new THREE.Vector3(0, 2, -wallLength / 2), rot: 0, dir: 'x' },
                { basePos: new THREE.Vector3(-wallLength / 2, 2, 0), rot: Math.PI / 2, dir: 'z' },
                { basePos: new THREE.Vector3(wallLength / 2, 2, 0), rot: -Math.PI / 2, dir: 'z' },
                { basePos: new THREE.Vector3(0, 2, wallLength / 2), rot: Math.PI, dir: 'x' }
            ];

            for (let wall of wallConfigs) {
                if (imageIndex >= totalImages) break;

                const wallPositions = [];
                for (let i = 0; i < numImagesPerWall && imageIndex < totalImages; i++) {
                    const offset = -wallLength / 2 + (i + 0.5) * (wallLength / numImagesPerWall);
                    const pos = wall.basePos.clone();
                    if (wall.dir === 'x') pos.x += offset;
                    else pos.z += offset;
                    wallPositions.push({ pos, rot: wall.rot });
                }

                for (let { pos, rot } of wallPositions) {
                    try {
                        const texture = await this.loadTexture(this.imagesToLoad[imageIndex]);
                        let material;
                        if (texture.image) {
                            material = new THREE.ShaderMaterial({
                                uniforms: {
                                    map: { value: texture },
                                    opacity: { value: 1.0 }
                                },
                                vertexShader: `
                                    varying vec2 vUv;
                                    void main() {
                                        vUv = uv;
                                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                    }
                                `,
                                fragmentShader: `
                                    uniform sampler2D map;
                                    uniform float opacity;
                                    varying vec2 vUv;
                                    void main() {
                                        vec4 color = texture2D(map, vUv);
                                        if (color.a < 0.1) discard;
                                        gl_FragColor = vec4(color.rgb, opacity);
                                    }
                                `,
                                transparent: true,
                                side: THREE.DoubleSide
                            });
                        } else {
                            material = fallbackMaterial;
                        }

                        const aspectRatio = texture.image ? texture.image.width / texture.image.height : 1;
                        const maxWidth = 3.5;
                        const planeWidth = Math.min(planeHeight * aspectRatio, maxWidth);

                        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.copy(pos).add(room.position);
                        const offsetToUse = (rot === Math.PI) ? backWallOffset : imageOffset;
                        if (rot === 0) mesh.position.z += offsetToUse;
                        if (rot === Math.PI) mesh.position.z -= offsetToUse;
                        if (Math.abs(rot) === Math.PI / 2) mesh.position.x += (rot > 0 ? offsetToUse : -offsetToUse);
                        mesh.rotation.y = rot;
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.userData = { filename: this.imagesToLoad[imageIndex] };
                        room.add(mesh);
                        this.images.push({ mesh, filename: this.imagesToLoad[imageIndex] });

                        const frameThickness = 0.1;
                        const frameGeometry = new THREE.BoxGeometry(planeWidth + 0.2, planeHeight + 0.2, frameThickness);
                        const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                        frame.position.copy(mesh.position);
                        frame.position.z -= Math.abs(rot) === Math.PI / 2 ? 0 : frameThickness / 2;
                        frame.position.x += Math.abs(rot) === Math.PI / 2 ? (rot > 0 ? -frameThickness / 2 : frameThickness / 2) : 0;
                        frame.rotation.y = rot;
                        frame.castShadow = true;
                        frame.receiveShadow = true;
                        room.add(frame);

                        const spotlight = new THREE.SpotLight(0xffffff, 2.0, 15, Math.PI / 6, 0.7);
                        const lightOffset = 1;
                        spotlight.position.set(
                            pos.x + (Math.abs(rot) === Math.PI / 2 ? (rot > 0 ? lightOffset : -lightOffset) : 0),
                            4.5,
                            pos.z + (Math.abs(rot) === Math.PI / 2 ? 0 : (rot === 0 ? -lightOffset : lightOffset))
                        ).add(room.position);
                        spotlight.target = mesh;
                        spotlight.castShadow = true;
                        spotlight.shadow.mapSize.width = 1024;
                        spotlight.shadow.mapSize.height = 1024;
                        room.add(spotlight);

                        imageIndex++;
                    } catch (error) {
                        console.error(`Error loading image ${this.imagesToLoad[imageIndex]}:`, error);
                        imageIndex++;
                    }
                }
            }
        }
        console.log("🎨 Images rendered:", this.images.length);
    }

    clearScene() {
        this.images.forEach(img => {
            if (img.mesh.parent) {
                img.mesh.parent.remove(img.mesh);
            }
            img.mesh.geometry.dispose();
            if (img.mesh.material.map) img.mesh.material.map.dispose();
            if (img.mesh.material.uniforms && img.mesh.material.uniforms.map.value) {
                img.mesh.material.uniforms.map.value.dispose();
            }
            img.mesh.material.dispose();
        });
        this.images = [];
        this.rooms.forEach(room => {
            const toRemove = room.children.filter(child => 
                child instanceof THREE.SpotLight || 
                (child.material?.color?.getHex() === 0x333333)
            );
            toRemove.forEach(child => room.remove(child));
        });
        console.log("🗑️ Scene cleared");
    }

    loadTexture(filename) {
        return new Promise((resolve, reject) => {
            this.textureLoader.load(
                filename,
                (texture) => {
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.generateMipmaps = true;
                    texture.anisotropy = this.renderer.capabilities.getMaxAnisotropy() || 1;
                    resolve(texture);
                },
                undefined,
                (err) => reject(err)
            );
        });
    }

    onCanvasClick(event) {
        const currentTime = new Date().getTime();
        const timeSinceLastClick = currentTime - this.lastClickTime;

        if (timeSinceLastClick < this.clickDelay) {
            this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            this.raycaster.setFromCamera(this.mouse, this.camera);
            const intersects = this.raycaster.intersectObjects([...this.images.map(img => img.mesh), ...this.scene.children.filter(obj => obj.userData.nextRoom !== undefined || (obj.parent && obj.parent.userData.isAvatar))]);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                if (this.isFocused) {
                    this.resetCamera();
                } else if (obj.userData.nextRoom !== undefined) {
                    this.moveToRoom(obj.userData.nextRoom);
                } else if (obj.parent && obj.parent.userData.isAvatar) {
                    this.showAvatarInstructions();
                } else if (obj.userData.filename) {
                    console.log(`Clicked image: ${obj.userData.filename}`);
                    if (!this.clickSound.isPlaying) this.clickSound.play();
                    this.focusImage(obj);
                }
            }
        }
        this.lastClickTime = currentTime;
    }

    focusImage(mesh) {
        this.updateCameraState();
        this.isFocused = true;

        if (this.isMobile) {
            const targetPos = mesh.position.clone();
            targetPos.y = 1.6;
            const distance = 2;
            const direction = new THREE.Vector3();
            direction.subVectors(this.camera.position, targetPos).normalize();
            targetPos.add(direction.multiplyScalar(-distance));

            const startPos = this.camera.position.clone();
            const startTarget = this.controls.target.clone();
            const duration = 500;
            const startTime = performance.now();

            const animateFocus = (time) => {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                this.camera.position.lerpVectors(startPos, targetPos, t);
                this.controls.target.lerpVectors(startTarget, mesh.position, t);
                this.controls.update();

                if (t < 1) requestAnimationFrame(animateFocus);
            };
            requestAnimationFrame(animateFocus);
        } else {
            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);

            const targetPos = mesh.position.clone().sub(direction.multiplyScalar(2));
            targetPos.y = 1.6;

            const roomBounds = this.rooms[this.currentRoom].position;
            const minX = roomBounds.x - 7 + 1;
            const maxX = roomBounds.x + 7 - 1;
            const minZ = roomBounds.z - 7 + 1;
            const maxZ = roomBounds.z + 7 - 1;

            targetPos.x = Math.max(minX, Math.min(maxX, targetPos.x));
            targetPos.z = Math.max(minZ, Math.min(maxZ, targetPos.z));

            const startPos = this.camera.position.clone();
            const duration = 500;
            const startTime = performance.now();

            const animateFocus = (time) => {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                this.camera.position.lerpVectors(startPos, targetPos, t);
                this.controls.getObject().position.copy(this.camera.position);
                this.camera.lookAt(mesh.position);
                this.checkCollisions();

                if (t < 1) requestAnimationFrame(animateFocus);
            };
            requestAnimationFrame(animateFocus);
        }
    }

    resetCamera() {
        if (!this.isFocused) return;

        const startPos = this.camera.position.clone();
        const targetPos = this.previousCameraState.position.clone();
        const duration = 500;
        const startTime = performance.now();

        if (this.isMobile) {
            const startTarget = this.controls.target.clone();
            const targetTarget = this.previousCameraState.target.clone();

            const animateReset = (time) => {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                const easedT = 0.5 - 0.5 * Math.cos(Math.PI * t);
                this.camera.position.lerpVectors(startPos, targetPos, easedT);
                this.controls.target.lerpVectors(startTarget, targetTarget, easedT);
                this.controls.update();

                if (t < 1) requestAnimationFrame(animateReset);
                else {
                    this.isFocused = false;
                }
            };
            requestAnimationFrame(animateReset);
        } else {
            const animateReset = (time) => {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                const easedT = 0.5 - 0.5 * Math.cos(Math.PI * t);
                this.camera.position.lerpVectors(startPos, targetPos, easedT);
                this.controls.getObject().position.copy(this.camera.position);
                this.checkCollisions();

                if (t < 1) requestAnimationFrame(animateReset);
                else {
                    this.isFocused = false;
                    if (!this.isMoving) this.controls.lock();
                }
            };
            requestAnimationFrame(animateReset);
        }
    }

    updateCameraState() {
        this.previousCameraState = {
            position: this.camera.position.clone(),
            rotation: this.camera.rotation.clone(),
            target: this.isMobile ? this.controls.target.clone() : this.camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(5).add(this.camera.position)
        };
    }

    handleDownload() {
        const imgData = this.renderer.domElement.toDataURL("image/png");
        const link = document.createElement("a");
        link.href = imgData;
        link.download = "gallery_view.png";
        link.click();
    }

    handleZoom() {
        const zoomSlider = document.getElementById("zoomSlider");
        const zoomValue = document.getElementById("zoomValue");
        const zoomLevel = parseFloat(zoomSlider.value);
        zoomValue.textContent = zoomLevel.toFixed(1);
        if (this.isMobile) {
            this.controls.minDistance = 1 / zoomLevel;
            this.controls.maxDistance = 10 / zoomLevel;
            this.controls.update();
        } else {
            this.moveSpeed = zoomLevel / 10;
            this.camera.fov = 75 / (zoomLevel * 0.5 + 0.5);
            this.camera.updateProjectionMatrix();
        }
    }

    async handleScreenshotSubmit(event) {
        event.preventDefault();
        const url = document.getElementById("url")?.value;
        if (!url) return;

        try {
            const response = await fetch("http://localhost:3000/api/capture", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url })
            });
            const result = await response.json();
            if (result.sessionId) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                await this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error capturing screenshot:", error);
        }
    }

    async handleUploadSubmit(event) {
        event.preventDefault();
        const fileInput = document.getElementById("images");
        if (!fileInput?.files?.length) return;

        const formData = new FormData();
        for (const file of fileInput.files) {
            formData.append("images", file);
        }

        try {
            const response = await fetch(`http://localhost:3000/api/upload${this.sessionId ? `/${this.sessionId}` : ''}`, {
                method: "POST",
                body: formData
            });
            const result = await response.json();
            if (result.success) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                await this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error uploading files:", error);
        }
    }

    handleResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    showAvatarInstructions() {
        const instructions = document.createElement("div");
        instructions.id = "avatarInstructions";
        instructions.style.cssText = "position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:white; background:rgba(0,0,0,0.7); padding:20px; border-radius:5px; z-index:11; text-align:center;";
        if (this.isMobile) {
            instructions.innerHTML = `
                <h3>Gallery Controls</h3>
                <p>Swipe to look around.</p>
                <p>Pinch to zoom in/out.</p>
                <p>Tap an artwork to focus, tap again to reset.</p>
                <p>Tap Previous/Next Room buttons to navigate.</p>
                <button id="closeInstructions" style="margin-top:10px; padding:5px 10px; background:#1e90ff; border:none; color:white; border-radius:5px; cursor:pointer;">Close</button>
            `;
        } else {
            instructions.innerHTML = `
                <h3>Gallery Controls</h3>
                <p>Click to lock pointer and start exploring.</p>
                <p>Use W, A, S, D to move.</p>
                <p>Mouse to look around.</p>
                <p>Double-click an artwork to focus, double-click again to reset.</p>
                <p>Click Previous/Next Room buttons to navigate.</p>
                <button id="closeInstructions" style="margin-top:10px; padding:5px 10px; background:#1e90ff; border:none; color:white; border-radius:5px; cursor:pointer;">Close</button>
            `;
        }
        document.body.appendChild(instructions);

        document.getElementById("closeInstructions").addEventListener("click", () => {
            document.body.removeChild(instructions);
        });
    }
}

const app = new ThreeJSApp();
app.init();


MODERN INTERIOR DESIGN
import * as THREE from "three";
import { PointerLockControls } from "PointerLockControls";
import { OrbitControls } from "OrbitControls";

class CustomPointerLockControls extends PointerLockControls {
    constructor(camera, domElement) {
        super(camera, domElement);
        this.sensitivity = 0.001;
    }

    getObject() {
        return this.camera;
    }

    lock() {
        super.lock();
        this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove.bind(this));
    }

    unlock() {
        super.unlock();
        this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove.bind(this));
    }

    onMouseMove(event) {
        if (this.isLocked === true) {
            const movementX = event.movementX * this.sensitivity;
            const movementY = event.movementY * this.sensitivity;

            const euler = new THREE.Euler(0, 0, 0, "YXZ");
            euler.setFromQuaternion(this.camera.quaternion);

            euler.y -= movementX;
            euler.x -= movementY;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));

            this.camera.quaternion.setFromEuler(euler);
        }
    }

    setSensitivity(value) {
        this.sensitivity = value;
    }
}

class ThreeJSApp {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        this.roomCameraSettings = [
            { position: new THREE.Vector3(0, 1.6, 5), lookAt: new THREE.Vector3(0, 1.6, 0) },
            { position: new THREE.Vector3(18, 1.6, 5), lookAt: new THREE.Vector3(18, 1.6, 0) }
        ];
        const initialSettings = this.roomCameraSettings[0];
        this.camera.position.copy(initialSettings.position);
        this.camera.lookAt(initialSettings.lookAt);

        this.renderer = new THREE.WebGLRenderer({ alpha: false, antialias: true, preserveDrawingBuffer: true });
        this.renderer.setClearColor(0x000000, 1);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);

        this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || ('ontouchstart' in window);
        
        if (this.isMobile) {
            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.controls.target.copy(initialSettings.lookAt);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;
            this.controls.minDistance = 1;
            this.controls.maxDistance = 10;
            this.controls.enablePan = true;
            this.controls.enableZoom = true;
        } else {
            this.controls = new CustomPointerLockControls(this.camera, this.renderer.domElement);
            this.controls.getObject().position.copy(initialSettings.position);
        }

        this.images = [];
        this.sessionId = localStorage.getItem('sessionId');
        this.textureLoader = new THREE.TextureLoader();

        this.audioListener = new THREE.AudioListener();
        this.camera.add(this.audioListener);
        this.backgroundAudio = new THREE.Audio(this.audioListener);
        this.clickSound = new THREE.Audio(this.audioListener);

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.selectedMesh = null;

        this.rooms = [];
        this.currentRoom = 0;
        this.isMoving = false;
        this.isFocused = false;
        this.isLocked = false;

        this.previousCameraState = {
            position: this.camera.position.clone(),
            rotation: this.camera.rotation.clone(),
            target: initialSettings.lookAt.clone()
        };

        this.lastClickTime = 0;
        this.clickDelay = 300;
        this.moveSpeed = 0.1;
        this.keys = { w: false, a: false, s: false, d: false };

        this.addLighting();
        this.createGallery();
        this.setupAudio();
        this.setupEventListeners();
        this.createAvatar();
    }

    addLighting() {
        const ambientLight = new THREE.AmbientLight(0xfff5e1, 0.6);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xfff5e1, 0.5);
        directionalLight.position.set(0, 15, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.bias = -0.0001;
        this.scene.add(directionalLight);
    }

    createGallery() {
        const concreteColor = 0x888888;
        const concreteRoughness = 0.7;
        const concreteMetalness = 0.1;

        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0xaaaaaa,
            roughness: 0.4,
            metalness: concreteMetalness,
            map: new THREE.Texture(this.generateNoiseCanvas(256, 256)),
            normalMap: new THREE.Texture(this.generateNoiseCanvas(256, 256)),
            normalScale: new THREE.Vector2(0.05, 0.05)
        });

        const ceilingMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.2,
            metalness: 0
        });

        const glassMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xaab8c2,
            transparent: true,
            opacity: 0.85,
            roughness: 0.1,
            metalness: 0.2,
            transmission: 0.9,
            thickness: 0.05,
            envMapIntensity: 1.5,
            clearcoat: 0.3,
            clearcoatRoughness: 0.1
        });

        const windowFrameMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.7,
            metalness: 0.2
        });

        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0xe5e5e5,
            roughness: 0.3
        });

        const accentWallMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.5,
            metalness: 0.1
        });

        const modernFurnitureMaterial = new THREE.MeshStandardMaterial({
            color: 0x3c2f2f,
            roughness: 0.6,
            metalness: 0
        });

        const metalMaterial = new THREE.MeshStandardMaterial({
            color: 0xaaaaaa,
            roughness: 0.3,
            metalness: 0.8
        });

        // Room 1: Main Gallery Space
        const room1 = new THREE.Group();
        const floor1 = new THREE.Mesh(new THREE.PlaneGeometry(18, 18), floorMaterial);
        floor1.rotation.x = -Math.PI / 2;
        floor1.receiveShadow = true;
        room1.add(floor1);

        const ceiling1 = new THREE.Mesh(new THREE.PlaneGeometry(18, 18), ceilingMaterial);
        ceiling1.position.y = 6;
        ceiling1.rotation.x = Math.PI / 2;
        ceiling1.receiveShadow = true;
        room1.add(ceiling1);

        const ceilingLight = new THREE.RectAreaLight(0xfff5e1, 5, 16, 16);
        ceilingLight.position.set(0, 5.9, 0);
        ceilingLight.rotation.x = Math.PI;
        room1.add(ceilingLight);

        const walls1 = [
            new THREE.Mesh(new THREE.PlaneGeometry(18, 6), accentWallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(18, 6), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(18, 6), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(18, 6), wallMaterial)
        ];
        walls1[0].position.set(0, 3, -9);
        walls1[1].position.set(0, 3, 9);
        walls1[1].rotation.y = Math.PI;
        walls1[2].position.set(-9, 3, 0);
        walls1[2].rotation.y = Math.PI / 2;
        walls1[3].position.set(9, 3, 0);
        walls1[3].rotation.y = -Math.PI / 2;
        walls1.forEach(wall => {
            wall.receiveShadow = true;
            room1.add(wall);
        });

        const windowWidth = 10;
        const windowHeight = 5.8;
        const windowFrameThickness = 0.05;
        const windowGlass = new THREE.Mesh(new THREE.PlaneGeometry(windowWidth, windowHeight), glassMaterial);
        windowGlass.position.set(0, 3, -8.9);
        room1.add(windowGlass);

        const frameGeometryTopBottom = new THREE.BoxGeometry(windowWidth + windowFrameThickness * 2, windowFrameThickness, windowFrameThickness);
        const frameGeometrySides = new THREE.BoxGeometry(windowFrameThickness, windowHeight, windowFrameThickness);
        const frameTop = new THREE.Mesh(frameGeometryTopBottom, windowFrameMaterial);
        frameTop.position.set(0, 3 + windowHeight / 2, -8.9);
        room1.add(frameTop);
        const frameBottom = new THREE.Mesh(frameGeometryTopBottom, windowFrameMaterial);
        frameBottom.position.set(0, 3 - windowHeight / 2, -8.9);
        room1.add(frameBottom);
        const frameLeft = new THREE.Mesh(frameGeometrySides, windowFrameMaterial);
        frameLeft.position.set(-windowWidth / 2, 3, -8.9);
        room1.add(frameLeft);
        const frameRight = new THREE.Mesh(frameGeometrySides, windowFrameMaterial);
        frameRight.position.set(windowWidth / 2, 3, -8.9);
        room1.add(frameRight);

        const windowSpotLight = new THREE.SpotLight(0xfff5e1, 2.5, 10, Math.PI / 6, 0.8);
        windowSpotLight.position.set(0, 5.8, -8);
        windowSpotLight.target.position.set(0, 3, -8.9);
        windowSpotLight.castShadow = true;
        room1.add(windowSpotLight);
        room1.add(windowSpotLight.target);

        // Modern Furniture: Sleek Sofa
        const sofaSeat = new THREE.Mesh(new THREE.BoxGeometry(3, 0.4, 1.2), modernFurnitureMaterial);
        sofaSeat.position.set(0, 0.2, 4);
        sofaSeat.castShadow = true;
        sofaSeat.receiveShadow = true;
        room1.add(sofaSeat);

        const sofaBack = new THREE.Mesh(new THREE.BoxGeometry(3, 0.8, 0.2), modernFurnitureMaterial);
        sofaBack.position.set(0, 0.6, 4.5);
        sofaBack.castShadow = true;
        sofaBack.receiveShadow = true;
        room1.add(sofaBack);

        const sofaLegs = [];
        for (let i = 0; i < 4; i++) {
            const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.4, 16), metalMaterial);
            leg.position.set(
                (i % 2 === 0 ? -1.4 : 1.4),
                0.2,
                (i < 2 ? 3.5 : 4.5)
            );
            leg.castShadow = true;
            leg.receiveShadow = true;
            room1.add(leg);
            sofaLegs.push(leg);
        }

        // Modern Coffee Table
        const tableTop = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 1), modernFurnitureMaterial);
        tableTop.position.set(0, 0.5, 2);
        tableTop.castShadow = true;
        tableTop.receiveShadow = true;
        room1.add(tableTop);

        const tableLegs = [];
        for (let i = 0; i < 4; i++) {
            const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5, 16), metalMaterial);
            leg.position.set(
                (i % 2 === 0 ? -0.9 : 0.9),
                0.25,
                (i < 2 ? 1.5 : 2.5)
            );
            leg.castShadow = true;
            leg.receiveShadow = true;
            room1.add(leg);
            tableLegs.push(leg);
        }

        room1.position.set(0, 0, 0);
        this.rooms.push(room1);

        // Room 2: Secondary Space
        const room2 = new THREE.Group();
        const floor2 = new THREE.Mesh(new THREE.PlaneGeometry(14, 14), floorMaterial);
        floor2.rotation.x = -Math.PI / 2;
        floor2.receiveShadow = true;
        room2.add(floor2);

        const ceiling2 = new THREE.Mesh(new THREE.PlaneGeometry(14, 14), ceilingMaterial);
        ceiling2.position.y = 5;
        ceiling2.rotation.x = Math.PI / 2;
        ceiling2.receiveShadow = true;
        room2.add(ceiling2);

        const ceilingLight2 = new THREE.RectAreaLight(0xfff5e1, 4, 12, 12);
        ceilingLight2.position.set(0, 4.9, 0);
        ceilingLight2.rotation.x = Math.PI;
        room2.add(ceilingLight2);

        const walls2 = [
            new THREE.Mesh(new THREE.PlaneGeometry(14, 5), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(14, 5), accentWallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(14, 5), wallMaterial),
            new THREE.Mesh(new THREE.PlaneGeometry(14, 5), wallMaterial)
        ];
        walls2[0].position.set(0, 2.5, -7);
        walls2[1].position.set(0, 2.5, 7);
        walls2[1].rotation.y = Math.PI;
        walls2[2].position.set(-7, 2.5, 0);
        walls2[2].rotation.y = Math.PI / 2;
        walls2[3].position.set(7, 2.5, 0);
        walls2[3].rotation.y = -Math.PI / 2;
        walls2.forEach(wall => {
            wall.receiveShadow = true;
            room2.add(wall);
        });

        const door2 = new THREE.Mesh(new THREE.PlaneGeometry(3, 4.5), glassMaterial);
        door2.position.set(-6.9, 2.25, 0);
        door2.rotation.y = Math.PI / 2;
        door2.userData = { nextRoom: 0 };
        room2.add(door2);

        // Modern Chair
        const chairSeat = new THREE.Mesh(new THREE.BoxGeometry(1, 0.2, 1), modernFurnitureMaterial);
        chairSeat.position.set(0, 0.5, 0);
        chairSeat.castShadow = true;
        chairSeat.receiveShadow = true;
        room2.add(chairSeat);

        const chairBack = new THREE.Mesh(new THREE.BoxGeometry(1, 0.8, 0.1), modernFurnitureMaterial);
        chairBack.position.set(0, 0.9, 0.45);
        chairBack.castShadow = true;
        chairBack.receiveShadow = true;
        room2.add(chairBack);

        const chairLegs = [];
        for (let i = 0; i < 4; i++) {
            const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5, 16), metalMaterial);
            leg.position.set(
                (i % 2 === 0 ? -0.45 : 0.45),
                0.25,
                (i < 2 ? -0.45 : 0.45)
            );
            leg.castShadow = true;
            leg.receiveShadow = true;
            room2.add(leg);
            chairLegs.push(leg);
        }

        room2.position.set(18, 0, 0);
        this.rooms.push(room2);

        this.rooms.forEach(room => this.scene.add(room));
    }

    generateNoiseCanvas(width, height) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext('2d');
        const imageData = context.createImageData(width, height);

        for (let i = 0; i < imageData.data.length; i += 4) {
            const noise = Math.random() * 0.1 + 0.9;
            imageData.data[i] = 136 * noise;
            imageData.data[i + 1] = 136 * noise;
            imageData.data[i + 2] = 136 * noise;
            imageData.data[i + 3] = 255;
        }

        context.putImageData(imageData, 0, 0);
        return canvas;
    }

    createAvatar() {
        this.avatarGroup = new THREE.Group();
        const avatarMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3
        });

        const clickablePlane = new THREE.Mesh(
            new THREE.PlaneGeometry(0.5, 0.5),
            new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.0 })
        );
        clickablePlane.position.set(2, 1.7, 2);
        this.avatarGroup.add(clickablePlane);

        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1, 32), avatarMaterial);
        body.position.set(2, 0.5, 2);
        this.avatarGroup.add(body);

        const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), avatarMaterial);
        head.position.set(2, 1.2, 2);
        this.avatarGroup.add(head);

        const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 32);
        const leftArm = new THREE.Mesh(armGeometry, avatarMaterial);
        leftArm.position.set(1.7, 0.7, 2);
        leftArm.rotation.z = Math.PI / 4;
        this.avatarGroup.add(leftArm);

        const rightArm = new THREE.Mesh(armGeometry, avatarMaterial);
        rightArm.position.set(2.3, 0.7, 2);
        rightArm.rotation.z = -Math.PI / 4;
        this.avatarGroup.add(rightArm);

        const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 32);
        const leftLeg = new THREE.Mesh(legGeometry, avatarMaterial);
        leftLeg.position.set(1.8, 0.25, 2);
        this.avatarGroup.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, avatarMaterial);
        rightLeg.position.set(2.2, 0.25, 2);
        this.avatarGroup.add(rightLeg);

        this.avatarGroup.userData = { isAvatar: true };
        this.scene.add(this.avatarGroup);

        this.updateAvatarPosition();
    }

    updateAvatarPosition() {
        if (this.isMobile) {
            const roomCenter = this.rooms[this.currentRoom].position.clone();
            this.avatarGroup.position.copy(roomCenter);
            this.avatarGroup.position.y = 0.5;
        } else {
            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize().multiplyScalar(2);
            this.avatarGroup.position.copy(this.camera.position).add(direction);
            this.avatarGroup.position.y = 0.5;
        }
    }

    async setupAudio() {
        try {
            const backgroundBuffer = await this.loadAudio('./assets/sweet.mp3');
            this.backgroundAudio.setBuffer(backgroundBuffer);
            this.backgroundAudio.setLoop(true);
            this.backgroundAudio.setVolume(0.2);
            this.backgroundAudio.play();

            const clickBuffer = await this.loadAudio('./assets/sweet.mp3');
            this.clickSound.setBuffer(clickBuffer);
            this.clickSound.setVolume(0.5);
        } catch (error) {
            console.error("Error loading audio:", error);
        }
    }

    loadAudio(url) {
        return new Promise((resolve, reject) => {
            const audioLoader = new THREE.AudioLoader();
            audioLoader.load(
                url,
                (audioBuffer) => resolve(audioBuffer),
                undefined,
                (err) => reject(err)
            );
        });
    }

    init() {
        console.log("🚀 Virtual Gallery loaded");
        this.setupEventListeners();
        if (this.sessionId) this.loadImages(this.sessionId);
        this.animate();
        window.addEventListener("resize", () => this.handleResize());
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        this.update();
        this.renderer.render(this.scene, this.camera);
        if (this.isMobile) this.controls.update();
        this.updateAvatarPosition();
    }

    setupEventListeners() {
        const tutorial = document.createElement("div");
        tutorial.id = "tutorialOverlay";
        tutorial.style.cssText = "position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:white; background:rgba(0,0,0,0.7); padding:20px; border-radius:5px; z-index:11; text-align:center;";
        if (this.isMobile) {
            tutorial.innerHTML = "Swipe to look around, pinch to zoom, tap artwork to focus, tap avatar for help.";
        } else {
            tutorial.innerHTML = "Click to enter the gallery. Use W, A, S, D to move, mouse to look, double-click art to focus, click avatar for help.";
        }
        document.body.appendChild(tutorial);

        this.renderer.domElement.addEventListener(this.isMobile ? "touchstart" : "click", (event) => this.onCanvasClick(event));
        if (!this.isMobile) {
            document.addEventListener("keydown", (event) => this.onKeyDown(event));
            document.addEventListener("keyup", (event) => this.onKeyUp(event));
            this.renderer.domElement.addEventListener("click", () => {
                if (!this.isLocked && !this.isFocused) {
                    this.controls.lock();
                    tutorial.style.display = "none";
                }
            });
            document.addEventListener("pointerlockchange", () => {
                this.isLocked = document.pointerLockElement === this.renderer.domElement;
                if (!this.isLocked) this.isFocused = false;
            });
            document.addEventListener("pointerlockerror", () => {
                console.error("Pointer Lock failed");
            });
        } else {
            tutorial.style.display = "none";
        }

        document.getElementById("uploadForm")?.addEventListener("submit", (e) => this.handleUploadSubmit(e));
        document.getElementById("screenshotForm")?.addEventListener("submit", (e) => this.handleScreenshotSubmit(e));
        document.getElementById("downloadBtn")?.addEventListener("click", () => this.handleDownload());
        document.getElementById("zoomSlider")?.addEventListener("input", () => this.handleZoom());
        document.getElementById("toggleControlsBtn")?.addEventListener("click", () => this.toggleControls());
        document.getElementById("prevPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom - 1));
        document.getElementById("nextPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom + 1));
        if (!this.isMobile) {
            document.getElementById("sensitivitySlider")?.addEventListener("input", () => {
                const sensitivitySlider = document.getElementById("sensitivitySlider");
                const sensitivityValue = document.getElementById("sensitivityValue");
                const sensitivity = parseFloat(sensitivitySlider.value);
                sensitivityValue.textContent = sensitivity.toFixed(3);
                this.controls.setSensitivity(sensitivity);
            });
        } else {
            const sensitivityGroup = document.querySelector(".slider-group:last-child");
            if (sensitivityGroup) sensitivityGroup.style.display = "none";
        }
    }

    toggleControls() {
        this.controlsVisible = !this.controlsVisible;
        const controlPanels = document.querySelectorAll(".control-panel");
        const toggleButton = document.getElementById("toggleControlsBtn");

        controlPanels.forEach(panel => {
            panel.classList.toggle("hidden-panel", !this.controlsVisible);
        });

        toggleButton.textContent = this.controlsVisible ? "Hide Controls" : "Show Controls";
        toggleButton.querySelector("i").className = this.controlsVisible ? "fas fa-eye" : "fas fa-eye-slash";
        console.log(this.controlsVisible ? "🖥️ Controls visible" : "🖥️ Controls hidden");
    }

    onKeyDown(event) {
        switch (event.key.toLowerCase()) {
            case "w": this.keys.w = true; break;
            case "a": this.keys.a = true; break;
            case "s": this.keys.s = true; break;
            case "d": this.keys.d = true; break;
            case "escape": this.controls.unlock(); break;
        }
    }

    onKeyUp(event) {
        switch (event.key.toLowerCase()) {
            case "w": this.keys.w = false; break;
            case "a": this.keys.a = false; break;
            case "s": this.keys.s = false; break;
            case "d": this.keys.d = false; break;
        }
    }

    update() {
        if (!this.isMobile && this.isLocked && !this.isMoving && !this.isFocused) {
            const movement = new THREE.Vector3();
            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            if (this.keys.w) movement.addScaledVector(direction, this.moveSpeed);
            if (this.keys.s) movement.addScaledVector(direction, -this.moveSpeed);
            if (this.keys.a) {
                const left = new THREE.Vector3().crossVectors(this.camera.up, direction).normalize();
                movement.addScaledVector(left, -this.moveSpeed);
            }
            if (this.keys.d) {
                const right = new THREE.Vector3().crossVectors(this.camera.up, direction).normalize();
                movement.addScaledVector(right, this.moveSpeed);
            }

            this.controls.getObject().position.add(movement);
            this.checkCollisions();
        }
    }

    checkCollisions() {
        if (!this.isMobile) {
            this.camera.position.y = 1.6;
            const roomBounds = this.rooms[this.currentRoom].position;
            const minX = roomBounds.x - 8;
            const maxX = roomBounds.x + 8;
            const minZ = roomBounds.z - 8;
            const maxZ = roomBounds.z + 8;

            this.camera.position.x = Math.max(minX, Math.min(maxX, this.camera.position.x));
            this.camera.position.z = Math.max(minZ, Math.min(maxZ, this.camera.position.z));
            this.controls.getObject().position.copy(this.camera.position);
        }
    }

    moveToRoom(roomIndex) {
        if (roomIndex < 0 || roomIndex >= this.rooms.length || this.isMoving) return;

        this.isMoving = true;
        const settings = this.roomCameraSettings[roomIndex];
        const targetPos = settings.position.clone();
        const targetLookAt = settings.lookAt.clone();
        const startPos = this.camera.position.clone();
        const startLookAt = this.isMobile ? this.controls.target.clone() : this.camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(5).add(this.camera.position);
        const duration = 1000;
        const startTime = performance.now();

        const animateMove = (time) => {
            const elapsed = time - startTime;
            const t = Math.min(elapsed / duration, 1);
            const easedT = 0.5 - 0.5 * Math.cos(Math.PI * t);
            this.camera.position.lerpVectors(startPos, targetPos, easedT);
            if (this.isMobile) {
                this.controls.target.lerpVectors(startLookAt, targetLookAt, easedT);
            } else {
                this.controls.getObject().position.copy(this.camera.position);
                this.camera.lookAt(targetLookAt);
            }
            this.checkCollisions();

            if (t < 1) {
                requestAnimationFrame(animateMove);
            } else {
                this.currentRoom = roomIndex;
                this.isMoving = false;
                this.isFocused = false;
                this.updateCameraState();
                if (!this.isMobile && this.isLocked) this.controls.lock();
            }
        };
        requestAnimationFrame(animateMove);
    }

    async loadImages(sessionId) {
        try {
            const response = await fetch(`http://localhost:3000/api/screenshots/${sessionId}/`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            console.log("📸 Found images in session", sessionId + ":", data.screenshots);
            if (!data.screenshots?.length) {
                console.log("No screenshots found");
                return;
            }
            this.imagesToLoad = data.screenshots.map(img => `http://localhost:3000${img}`);
            this.displayImagesInGallery();
        } catch (error) {
            console.error("❌ Error fetching images:", error);
        }
    }

    async displayImagesInGallery() {
        if (!this.imagesToLoad) return;

        this.clearScene();
        const totalImages = this.imagesToLoad.length;
        let imageIndex = 0;

        const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.7, metalness: 0.2 });
        const fallbackMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0 });

        for (let room of this.rooms) {
            const wallLength = room === this.rooms[0] ? 18 : 14;
            const displayWidth = 3;
            const displayHeight = 2;
            const displayDepth = 0.2;
            const spacing = 1.5;
            const numDisplaysPerWall = Math.floor(wallLength / (displayWidth + spacing));
            const windowWidth = room === this.rooms[0] ? 10 : 0;
            const windowXMin = -windowWidth / 2;
            const windowXMax = windowWidth / 2;

            const wallConfigs = [
                { basePos: new THREE.Vector3(0, 2, -wallLength / 2 + 0.3), rot: 0, dir: 'x' },
                { basePos: new THREE.Vector3(-wallLength / 2 + 0.3, 2, 0), rot: Math.PI / 2, dir: 'z' },
                { basePos: new THREE.Vector3(wallLength / 2 - 0.3, 2, 0), rot: -Math.PI / 2, dir: 'z' },
                { basePos: new THREE.Vector3(0, 2, wallLength / 2 - 0.3), rot: Math.PI, dir: 'x' }
            ];

            for (let wall of wallConfigs) {
                if (imageIndex >= totalImages) break;

                const wallPositions = [];
                const isWindowWall = (room === this.rooms[0] && wall.rot === 0);
                const availableWidth = wallLength - (isWindowWall ? windowWidth + spacing * 2 : 0);
                const numDisplaysAdjusted = isWindowWall ? Math.floor(availableWidth / (displayWidth + spacing)) : numDisplaysPerWall;

                for (let i = 0; i < numDisplaysPerWall && imageIndex < totalImages; i++) {
                    let offset;
                    if (isWindowWall) {
                        const displaysPerSide = Math.floor(numDisplaysAdjusted / 2);
                        const sideWidth = (wallLength - windowWidth) / 2;
                        if (i < displaysPerSide) {
                            offset = -wallLength / 2 + (i + 0.5) * (sideWidth / displaysPerSide) + spacing;
                        } else {
                            const rightIndex = i - displaysPerSide;
                            offset = windowXMax + spacing + (rightIndex + 0.5) * (sideWidth / displaysPerSide);
                        }
                    } else {
                        offset = -wallLength / 2 + (i + 0.5) * (wallLength / numDisplaysPerWall);
                    }

                    const pos = wall.basePos.clone();
                    if (wall.dir === 'x') pos.x += offset;
                    else pos.z += offset;

                    if (isWindowWall && pos.x > windowXMin - displayWidth / 2 - spacing && pos.x < windowXMax + displayWidth / 2 + spacing) {
                        continue;
                    }

                    wallPositions.push({ pos, rot: wall.rot });
                }

                for (let { pos, rot } of wallPositions) {
                    const texture = await this.loadTexture(this.imagesToLoad[imageIndex]);
                    let material;
                    if (texture.image) {
                        material = new THREE.ShaderMaterial({
                            uniforms: {
                                map: { value: texture },
                                opacity: { value: 1.0 }
                            },
                            vertexShader: `
                                varying vec2 vUv;
                                varying vec3 vNormal;
                                void main() {
                                    vUv = uv;
                                    vNormal = normalMatrix * normal;
                                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                }
                            `,
                            fragmentShader: `
                                uniform sampler2D map;
                                uniform float opacity;
                                varying vec2 vUv;
                                varying vec3 vNormal;
                                void main() {
                                    vec4 color = texture2D(map, vUv);
                                    if (color.a < 0.1) discard;
                                    vec2 adjustedUv = gl_FrontFacing ? vUv : vec2(1.0 - vUv.x, vUv.y);
                                    color = texture2D(map, adjustedUv);
                                    gl_FragColor = vec4(color.rgb, opacity);
                                }
                            `,
                            transparent: true,
                            side: THREE.DoubleSide
                        });
                    } else {
                        material = fallbackMaterial;
                    }

                    const aspectRatio = texture.image ? texture.image.width / texture.image.height : 1;
                    const maxWidth = 3;
                    const adjustedWidth = Math.min(displayHeight * aspectRatio, maxWidth);

                    const displayGeometry = new THREE.BoxGeometry(adjustedWidth, displayHeight, displayDepth);
                    const displayMesh = new THREE.Mesh(displayGeometry, material);
                    displayMesh.position.copy(pos).add(room.position);
                    displayMesh.rotation.y = rot;
                    displayMesh.castShadow = true;
                    displayMesh.receiveShadow = true;
                    displayMesh.userData = { filename: this.imagesToLoad[imageIndex] };
                    room.add(displayMesh);
                    this.images.push({ mesh: displayMesh, filename: this.imagesToLoad[imageIndex] });

                    const frameThickness = 0.1;
                    const frameShape = new THREE.Shape();
                    frameShape.moveTo(-adjustedWidth / 2 - frameThickness, -displayHeight / 2 - frameThickness);
                    frameShape.lineTo(adjustedWidth / 2 + frameThickness, -displayHeight / 2 - frameThickness);
                    frameShape.lineTo(adjustedWidth / 2 + frameThickness, displayHeight / 2 + frameThickness);
                    frameShape.lineTo(-adjustedWidth / 2 - frameThickness, displayHeight / 2 + frameThickness);
                    frameShape.lineTo(-adjustedWidth / 2 - frameThickness, -displayHeight / 2 - frameThickness);

                    const hole = new THREE.Path();
                    hole.moveTo(-adjustedWidth / 2, -displayHeight / 2);
                    hole.lineTo(adjustedWidth / 2, -displayHeight / 2);
                    hole.lineTo(adjustedWidth / 2, displayHeight / 2);
                    hole.lineTo(-adjustedWidth / 2, displayHeight / 2);
                    hole.lineTo(-adjustedWidth / 2, -displayHeight / 2);
                    frameShape.holes.push(hole);

                    const extrudeSettings = { depth: frameThickness, bevelEnabled: false };
                    const frameGeometry = new THREE.ExtrudeGeometry(frameShape, extrudeSettings);
                    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                    frame.position.copy(displayMesh.position);
                    frame.position.z += (rot === 0 ? -displayDepth / 2 : (rot === Math.PI ? displayDepth / 2 : 0));
                    frame.position.x += (rot === Math.PI / 2 ? -displayDepth / 2 : (rot === -Math.PI / 2 ? displayDepth / 2 : 0));
                    frame.rotation.y = rot;
                    frame.castShadow = true;
                    frame.receiveShadow = true;
                    room.add(frame);

                    const spotlight = new THREE.SpotLight(0xfff5e1, 2.5, 15, Math.PI / 8, 0.7);
                    const lightOffset = 1.5;
                    spotlight.position.set(
                        pos.x + (Math.abs(rot) === Math.PI / 2 ? (rot > 0 ? lightOffset : -lightOffset) : 0),
                        room === this.rooms[0] ? 5.5 : 4.5,
                        pos.z + (Math.abs(rot) === Math.PI / 2 ? 0 : (rot === 0 ? -lightOffset : lightOffset))
                    ).add(room.position);
                    spotlight.target = displayMesh;
                    spotlight.castShadow = true;
                    spotlight.shadow.mapSize.width = 1024;
                    spotlight.shadow.mapSize.height = 1024;
                    spotlight.shadow.bias = -0.0001;
                    room.add(spotlight);

                    imageIndex++;
                }
            }
        }
    }

    clearScene() {
        this.images.forEach(img => {
            img.mesh.parent.remove(img.mesh);
            img.mesh.geometry.dispose();
            if (img.mesh.material.map) img.mesh.material.map.dispose();
            img.mesh.material.dispose();
        });
        this.images = [];
        this.rooms.forEach(room => {
            const toRemove = room.children.filter(child => 
                child instanceof THREE.SpotLight || 
                (child.material?.color?.getHex() === 0x1a1a1a && !(child.geometry instanceof THREE.PlaneGeometry))
            );
            toRemove.forEach(child => room.remove(child));
        });
    }

    loadTexture(filename) {
        return new Promise((resolve, reject) => {
            this.textureLoader.load(
                filename,
                (texture) => {
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.generateMipmaps = true;
                    texture.anisotropy = this.renderer.capabilities.getMaxAnisotropy() || 1;
                    resolve(texture);
                },
                undefined,
                (err) => reject(err)
            );
        });
    }

    onCanvasClick(event) {
        const currentTime = new Date().getTime();
        const timeSinceLastClick = currentTime - this.lastClickTime;

        if (timeSinceLastClick < this.clickDelay) {
            this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            this.raycaster.setFromCamera(this.mouse, this.camera);
            const intersects = this.raycaster.intersectObjects([...this.images.map(img => img.mesh), ...this.scene.children.filter(obj => obj.userData.nextRoom !== undefined || (obj.parent && obj.parent.userData.isAvatar))]);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                if (this.isFocused) {
                    this.resetCamera();
                } else if (obj.userData.nextRoom !== undefined) {
                    this.moveToRoom(obj.userData.nextRoom);
                } else if (obj.parent && obj.parent.userData.isAvatar) {
                    this.showAvatarInstructions();
                } else if (obj.userData.filename) {
                    console.log(`Clicked image: ${obj.userData.filename}`);
                    if (!this.clickSound.isPlaying) this.clickSound.play();
                    this.focusImage(obj);
                }
            }
        }
        this.lastClickTime = currentTime;
    }

    focusImage(mesh) {
        this.updateCameraState();
        this.isFocused = true;

        if (this.isMobile) {
            const targetPos = mesh.position.clone();
            targetPos.y = 1.6;
            const distance = 2;
            const direction = new THREE.Vector3();
            direction.subVectors(this.camera.position, targetPos).normalize();
            targetPos.add(direction.multiplyScalar(-distance));

            const startPos = this.camera.position.clone();
            const startTarget = this.controls.target.clone();
            const duration = 500;
            const startTime = performance.now();

            const animateFocus = (time) => {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                this.camera.position.lerpVectors(startPos, targetPos, t);
                this.controls.target.lerpVectors(startTarget, mesh.position, t);
                this.controls.update();

                if (t < 1) requestAnimationFrame(animateFocus);
            };
            requestAnimationFrame(animateFocus);
        } else {
            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);

            const targetPos = mesh.position.clone().sub(direction.multiplyScalar(2));
            targetPos.y = 1.6;

            const roomBounds = this.rooms[this.currentRoom].position;
            const minX = roomBounds.x - 8 + 1;
            const maxX = roomBounds.x + 8 - 1;
            const minZ = roomBounds.z - 8 + 1;
            const maxZ = roomBounds.z + 8 - 1;

            targetPos.x = Math.max(minX, Math.min(maxX, targetPos.x));
            targetPos.z = Math.max(minZ, Math.min(maxZ, targetPos.z));

            const startPos = this.camera.position.clone();
            const duration = 500;
            const startTime = performance.now();

            const animateFocus = (time) => {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                this.camera.position.lerpVectors(startPos, targetPos, t);
                this.controls.getObject().position.copy(this.camera.position);
                this.camera.lookAt(mesh.position);
                this.checkCollisions();

                if (t < 1) requestAnimationFrame(animateFocus);
            };
            requestAnimationFrame(animateFocus);
        }
    }

    resetCamera() {
        if (!this.isFocused) return;

        const startPos = this.camera.position.clone();
        const targetPos = this.previousCameraState.position.clone();
        const duration = 500;
        const startTime = performance.now();

        if (this.isMobile) {
            const startTarget = this.controls.target.clone();
            const targetTarget = this.previousCameraState.target.clone();

            const animateReset = (time) => {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                const easedT = 0.5 - 0.5 * Math.cos(Math.PI * t);
                this.camera.position.lerpVectors(startPos, targetPos, easedT);
                this.controls.target.lerpVectors(startTarget, targetTarget, easedT);
                this.controls.update();

                if (t < 1) requestAnimationFrame(animateReset);
                else {
                    this.isFocused = false;
                }
            };
            requestAnimationFrame(animateReset);
        } else {
            const animateReset = (time) => {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                const easedT = 0.5 - 0.5 * Math.cos(Math.PI * t);
                this.camera.position.lerpVectors(startPos, targetPos, easedT);
                this.controls.getObject().position.copy(this.camera.position);
                this.checkCollisions();

                if (t < 1) requestAnimationFrame(animateReset);
                else {
                    this.isFocused = false;
                    if (!this.isMoving) this.controls.lock();
                }
            };
            requestAnimationFrame(animateReset);
        }
    }

    updateCameraState() {
        this.previousCameraState = {
            position: this.camera.position.clone(),
            rotation: this.camera.rotation.clone(),
            target: this.isMobile ? this.controls.target.clone() : this.camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(5).add(this.camera.position)
        };
    }

    handleDownload() {
        const imgData = this.renderer.domElement.toDataURL("image/png");
        const link = document.createElement("a");
        link.href = imgData;
        link.download = "gallery_view.png";
        link.click();
    }

    handleZoom() {
        const zoomSlider = document.getElementById("zoomSlider");
        const zoomValue = document.getElementById("zoomValue");
        const zoomLevel = parseFloat(zoomSlider.value);
        zoomValue.textContent = zoomLevel.toFixed(1);
        if (this.isMobile) {
            this.controls.minDistance = 1 / zoomLevel;
            this.controls.maxDistance = 10 / zoomLevel;
            this.controls.update();
        } else {
            this.moveSpeed = zoomLevel / 10;
            this.camera.fov = 75 / (zoomLevel * 0.5 + 0.5);
            this.camera.updateProjectionMatrix();
        }
    }

    async handleScreenshotSubmit(event) {
        event.preventDefault();
        const url = document.getElementById("url")?.value;
        if (!url) return;

        try {
            const response = await fetch("http://localhost:3000/api/capture", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url })
            });
            const result = await response.json();
            if (result.sessionId) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error capturing screenshot:", error);
        }
    }

    async handleUploadSubmit(event) {
        event.preventDefault();
        const fileInput = document.getElementById("images");
        if (!fileInput?.files?.length) return;

        const formData = new FormData();
        for (const file of fileInput.files) {
            formData.append("images", file);
        }

        try {
            const response = await fetch(`http://localhost:3000/api/upload${this.sessionId ? `/${this.sessionId}` : ''}`, {
                method: "POST",
                body: formData
            });
            const result = await response.json();
            if (result.success) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error uploading files:", error);
        }
    }

    handleResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    showAvatarInstructions() {
        const instructions = document.createElement("div");
        instructions.id = "avatarInstructions";
        instructions.style.cssText = "position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:white; background:rgba(0,0,0,0.7); padding:20px; border-radius:5px; z-index:11; text-align:center;";
        if (this.isMobile) {
            instructions.innerHTML = `
                <h3>Gallery Controls</h3>
                <p>Swipe to look around.</p>
                <p>Pinch to zoom in/out.</p>
                <p>Tap an artwork to focus, tap again to reset.</p>
                <p>Tap Previous/Next Room buttons to navigate.</p>
                <button id="closeInstructions" style="margin-top:10px; padding:5px 10px; background:#1e90ff; border:none; color:white; border-radius:5px; cursor:pointer;">Close</button>
            `;
        } else {
            instructions.innerHTML = `
                <h3>Gallery Controls</h3>
                <p>Click to lock pointer and start exploring.</p>
                <p>Use W, A, S, D to move.</p>
                <p>Mouse to look around.</p>
                <p>Double-click an artwork to focus, double-click again to reset.</p>
                <p>Click Previous/Next Room buttons to navigate.</p>
                <button id="closeInstructions" style="margin-top:10px; padding:5px 10px; background:#1e90ff; border:none; color:white; border-radius:5px; cursor:pointer;">Close</button>
            `;
        }
        document.body.appendChild(instructions);

        document.getElementById("closeInstructions").addEventListener("click", () => {
            document.body.removeChild(instructions);
        });
    }
}

const app = new ThreeJSApp();
app.init();




#MODERN DESIGN FURNISHING WITH lED
import * as THREE from "three";
import { PointerLockControls } from "PointerLockControls";
import { OrbitControls } from "OrbitControls";

class CustomPointerLockControls extends PointerLockControls {
    constructor(camera, domElement) {
        super(camera, domElement);
        this.sensitivity = 0.001;
    }

    getObject() {
        return this.camera;
    }

    lock() {
        super.lock();
        this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove.bind(this));
    }

    unlock() {
        super.unlock();
        this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove.bind(this));
    }

    onMouseMove(event) {
        if (this.isLocked === true) {
            const movementX = event.movementX * this.sensitivity;
            const movementY = event.movementY * this.sensitivity;

            const euler = new THREE.Euler(0, 0, 0, "YXZ");
            euler.setFromQuaternion(this.camera.quaternion);

            euler.y -= movementX;
            euler.x -= movementY;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));

            this.camera.quaternion.setFromEuler(euler);
        }
    }

    setSensitivity(value) {
        this.sensitivity = value;
    }
}

class ThreeJSApp {
    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        this.roomCameraSettings = [
            { position: new THREE.Vector3(0, 1.6, 5), lookAt: new THREE.Vector3(0, 1.6, 0) },
            { position: new THREE.Vector3(18, 1.6, 5), lookAt: new THREE.Vector3(18, 1.6, 0) }
        ];
        const initialSettings = this.roomCameraSettings[0];
        this.camera.position.copy(initialSettings.position);
        this.camera.lookAt(initialSettings.lookAt);

        this.renderer = new THREE.WebGLRenderer({ alpha: false, antialias: true, preserveDrawingBuffer: true });
        this.renderer.setClearColor(0x000000, 1);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);

        this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || ('ontouchstart' in window);
        
        if (this.isMobile) {
            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.controls.target.copy(initialSettings.lookAt);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;
            this.controls.minDistance = 1;
            this.controls.maxDistance = 10;
            this.controls.enablePan = true;
            this.controls.enableZoom = true;
        } else {
            this.controls = new CustomPointerLockControls(this.camera, this.renderer.domElement);
            this.controls.getObject().position.copy(initialSettings.position);
        }

        this.images = [];
        this.sessionId = localStorage.getItem('sessionId');
        this.textureLoader = new THREE.TextureLoader();

        this.audioListener = new THREE.AudioListener();
        this.camera.add(this.audioListener);
        this.backgroundAudio = new THREE.Audio(this.audioListener);
        this.clickSound = new THREE.Audio(this.audioListener);

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.selectedMesh = null;

        this.rooms = [];
        this.currentRoom = 0;
        this.isMoving = false;
        this.isFocused = false;
        this.isLocked = false;

        this.previousCameraState = {
            position: this.camera.position.clone(),
            rotation: this.camera.rotation.clone(),
            target: initialSettings.lookAt.clone()
        };

        this.lastClickTime = 0;
        this.clickDelay = 300;
        this.moveSpeed = 0.1;
        this.keys = { w: false, a: false, s: false, d: false };

        this.time = 0;

        // Interactive art properties
        this.lightWall = null;
        this.soundSculpture = null;
        this.interactionCooldown = 0;

        this.addLighting();
        this.createGallery();
        this.setupAudio();
        this.setupEventListeners();
        this.createAvatar();
    }

    addLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        this.scene.add(directionalLight);
    }

    createGallery() {
        const concreteColor = 0x888888;
        const concreteRoughness = 0.7;
        const concreteMetalness = 0.1;

        // Floor Materials
        const floorMaterial1 = new THREE.MeshStandardMaterial({
            color: concreteColor,
            roughness: 0.2,
            metalness: concreteMetalness
        });
        const noiseTexture = new THREE.Texture(this.generateNoiseCanvas(256, 256));
        noiseTexture.needsUpdate = true;
        noiseTexture.wrapS = noiseTexture.wrapT = THREE.RepeatWrapping;
        noiseTexture.repeat.set(4, 4);
        floorMaterial1.map = noiseTexture;
        floorMaterial1.normalMap = noiseTexture;
        floorMaterial1.normalScale.set(0.05, 0.05);

        const woodTexture = new THREE.TextureLoader().load('https://www.directwoodflooring.co.uk/media/catalog/product/cache/43942d99e4560257de5108a0f0547660/h/e/herringbone-naturaloaklvtflooring-1_5.jpg');
        woodTexture.wrapS = woodTexture.wrapT = THREE.RepeatWrapping;
        woodTexture.repeat.set(6, 6);
        const floorMaterial2 = new THREE.MeshStandardMaterial({
            color: 0x8b5a2b,
            roughness: 0.8,
            metalness: 0,
            map: woodTexture,
            normalMap: woodTexture,
            normalScale: new THREE.Vector2(0.2, 0.2)
        });

        // Wall Materials
        const waveTexture = new THREE.TextureLoader().load('https://i.pinimg.com/736x/bb/82/af/bb82af6b027c173c5b0c21cb7064401b.jpg');
        waveTexture.wrapS = waveTexture.wrapT = THREE.RepeatWrapping;
        waveTexture.repeat.set(2, 1);
        const wallMaterial1 = new THREE.MeshStandardMaterial({
            color: 0xf5f5f5,
            roughness: 0.4,
            metalness: 0,
            normalMap: waveTexture,
            normalScale: new THREE.Vector2(0.1, 0.1)
        });

        const brickTexture = new THREE.TextureLoader().load('https://cdn.architextures.org/textures/24/10/st-andrews-multi-herringbone-traditional-brick-and-stone-3x58nh.jpg?s=400&q=60');
        brickTexture.wrapS = brickTexture.wrapT = THREE.RepeatWrapping;
        brickTexture.repeat.set(4, 2);
        const brickNormal = new THREE.TextureLoader().load('https://www.textures.com/system/gallery/photos/Brick/115032-Bare/ps133263/133263_header.jpg');
        brickNormal.wrapS = brickNormal.wrapT = THREE.RepeatWrapping;
        brickNormal.repeat.set(4, 2);
        const wallMaterial2 = new THREE.MeshStandardMaterial({
            color: 0x8c2f2f,
            roughness: 0.9,
            metalness: 0,
            map: brickTexture,
            normalMap: brickNormal,
            normalScale: new THREE.Vector2(0.3, 0.3)
        });

        const ceilingMaterial = new THREE.MeshStandardMaterial({
            color: 0xaaaaaa,
            roughness: 0.4,
            metalness: concreteMetalness,
            map: noiseTexture
        });
        const glassMaterial = new THREE.MeshPhysicalMaterial({ 
            color: 0xaaaaaa, 
            transparent: true, 
            opacity: 0.3, 
            roughness: 0, 
            metalness: 0.1, 
            transmission: 0.9 
        });
        const metalMaterial = new THREE.MeshStandardMaterial({
            color: 0xaaaaaa,
            roughness: 0.3,
            metalness: 0.8
        });
        const woodMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b5a2b,
            roughness: 0.7,
            metalness: 0
        });
        const ledMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const acrylicMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.8,
            roughness: 0.1,
            metalness: 0.2,
            transmission: 0.9
        });
        const leatherMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a2f1a,
            roughness: 0.7,
            metalness: 0
        });

        // Room 1: Main Gallery Space
        const room1 = new THREE.Group();
        const floor1 = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), floorMaterial1);
        floor1.rotation.x = -Math.PI / 2;
        floor1.receiveShadow = true;
        room1.add(floor1);

        // Embedded LED Strips for Room 1
        const ledStripGeometry = new THREE.BoxGeometry(15, 0.02, 0.1);
        for (let i = -6; i <= 6; i += 3) {
            const stripX = new THREE.Mesh(ledStripGeometry, ledMaterial);
            stripX.position.set(0, 0.01, i);
            stripX.rotation.x = -Math.PI / 2;
            room1.add(stripX);

            const stripZ = new THREE.Mesh(ledStripGeometry, ledMaterial);
            stripZ.position.set(i, 0.01, 0);
            stripZ.rotation.x = -Math.PI / 2;
            stripZ.rotation.z = Math.PI / 2;
            room1.add(stripZ);

            const ledLight = new THREE.PointLight(0xffffff, 0.5, 2);
            ledLight.position.set(i, 0.05, i);
            room1.add(ledLight);
        }

        // Ceiling 1: Suspended Geometric Panels
        const hexGeometry = new THREE.CircleGeometry(1, 6);
        for (let i = -2; i <= 2; i++) {
            for (let j = -2; j <= 2; j++) {
                if (Math.abs(i) === 2 && Math.abs(j) === 2) continue;
                const panel = new THREE.Mesh(hexGeometry, ceilingMaterial);
                const heightOffset = Math.random() * 0.5 + 4.5;
                panel.position.set(i * 2.5, heightOffset, j * 2.5);
                panel.rotation.x = Math.PI / 2;
                panel.receiveShadow = true;
                room1.add(panel);

                const led = new THREE.Mesh(new THREE.CircleGeometry(0.3, 6), ledMaterial);
                led.position.set(i * 2.5, heightOffset - 0.05, j * 2.5);
                led.rotation.x = Math.PI / 2;
                room1.add(led);

                const panelLight = new THREE.PointLight(0xffffff, 1, 5);
                panelLight.position.set(i * 2.5, heightOffset - 0.1, j * 2.5);
                room1.add(panelLight);
            }
        }

        // Walls 1: Textured Plaster with Wave Pattern
        const walls1 = [
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial1),
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial1),
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial1),
            new THREE.Mesh(new THREE.PlaneGeometry(15, 5), wallMaterial1)
        ];
        walls1[0].position.set(0, 2.5, -7.5);
        walls1[1].position.set(0, 2.5, 7.5);
        walls1[1].rotation.y = Math.PI;
        walls1[2].position.set(-7.5, 2.5, 0);
        walls1[2].rotation.y = Math.PI / 2;
        walls1[3].position.set(7.5, 2.5, 0);
        walls1[3].rotation.y = -Math.PI / 2;
        walls1.forEach(wall => {
            wall.receiveShadow = true;
            room1.add(wall);
        });

        // Window 1: Curved Floor-to-Ceiling Glass Wall
        const curvePoints = [];
        for (let i = 0; i <= 20; i++) {
            const angle = (i / 20) * Math.PI;
            const x = Math.cos(angle) * 2 - 7.5;
            const z = Math.sin(angle) * 2 - 7.5;
            curvePoints.push(new THREE.Vector3(x, 0, z));
        }
        const curve = new THREE.CatmullRomCurve3(curvePoints);
        const glassGeometry = new THREE.ExtrudeGeometry(
            new THREE.Shape([new THREE.Vector2(-7.5, 0), new THREE.Vector2(7.5, 0), new THREE.Vector2(7.5, 5), new THREE.Vector2(-7.5, 5)]),
            { depth: 0.1, extrudePath: curve }
        );
        const curvedWindow = new THREE.Mesh(glassGeometry, glassMaterial);
        curvedWindow.position.set(0, 0, 0);
        room1.add(curvedWindow);

        const metalStripGeometry = new THREE.BoxGeometry(0.05, 5, 0.05);
        for (let i = -6; i <= 6; i += 2) {
            const strip = new THREE.Mesh(metalStripGeometry, metalMaterial);
            strip.position.set(i, 2.5, -7.4);
            strip.castShadow = true;
            room1.add(strip);
        }

        // Furniture 1: Minimalist Acrylic Bench
        const benchSeat = new THREE.Mesh(new THREE.BoxGeometry(4, 0.3, 1), acrylicMaterial);
        benchSeat.position.set(0, 0.15, 3);
        benchSeat.castShadow = true;
        benchSeat.receiveShadow = true;
        room1.add(benchSeat);

        const benchFrameGeometry = new THREE.BoxGeometry(4.1, 0.05, 0.05);
        const benchFrame1 = new THREE.Mesh(benchFrameGeometry, metalMaterial);
        benchFrame1.position.set(0, 0.3, 3);
        benchFrame1.castShadow = true;
        room1.add(benchFrame1);

        const benchFrame2 = new THREE.Mesh(benchFrameGeometry, metalMaterial);
        benchFrame2.position.set(0, 0, 3);
        benchFrame2.castShadow = true;
        room1.add(benchFrame2);

        for (let i = 0; i < 4; i++) {
            const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.3, 16), metalMaterial);
            leg.position.set(
                (i % 2 === 0 ? -1.9 : 1.9),
                0.15,
                (i < 2 ? 2.5 : 3.5)
            );
            leg.castShadow = true;
            leg.receiveShadow = true;
            room1.add(leg);
        }

        // Installation 1: Kinetic Light Wall
        this.lightWall = new THREE.Group();
        this.lightWall.userData = { isInteractive: true, type: 'lightWall' };
        const rodGeometry = new THREE.CylinderGeometry(0.05, 0.05, 4, 16);
        for (let i = -6; i <= 6; i += 1) {
            const rod = new THREE.Mesh(rodGeometry, new THREE.MeshBasicMaterial({ color: 0xffffff }));
            rod.position.set(i, 2.5, 7.49);
            rod.userData = { baseColor: 0xffffff, intensity: 1 };
            this.lightWall.add(rod);
        }
        room1.add(this.lightWall);

        room1.position.set(0, 0, 0);
        this.rooms.push(room1);

        // Room 2: Secondary Space
        const room2 = new THREE.Group();
        const floor2 = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), floorMaterial2);
        floor2.rotation.x = -Math.PI / 2;
        floor2.receiveShadow = true;
        room2.add(floor2);

        // Ceiling 2: Exposed Industrial Beams with Skylights
        const beamGeometry = new THREE.BoxGeometry(12, 0.5, 0.5);
        for (let i = -1; i <= 1; i += 2) {
            const beam = new THREE.Mesh(beamGeometry, ceilingMaterial);
            beam.position.set(0, 4.25, i * 3);
            beam.receiveShadow = true;
            room2.add(beam);
        }
        const crossBeam = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 12), ceilingMaterial);
        crossBeam.position.set(0, 4.25, 0);
        crossBeam.rotation.y = Math.PI / 2;
        room2.add(crossBeam);

        const skylightGeometry = new THREE.CircleGeometry(0.5, 32);
        const skylightMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x87ceeb,
            transparent: true,
            opacity: 0.6,
            roughness: 0,
            metalness: 0.1,
            transmission: 0.9
        });
        for (let i = -1; i <= 1; i += 2) {
            const skylight = new THREE.Mesh(skylightGeometry, skylightMaterial);
            skylight.position.set(i * 3, 4.5, 0);
            skylight.rotation.x = Math.PI / 2;
            room2.add(skylight);

            const skylightLight = new THREE.PointLight(0xffffff, 0.8, 5);
            skylightLight.position.set(i * 3, 4.4, 0);
            room2.add(skylightLight);
        }

        // Walls 2: Exposed Brick with Weathered Finish
        const walls2 = [
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial2),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial2),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial2),
            new THREE.Mesh(new THREE.PlaneGeometry(12, 4), wallMaterial2)
        ];
        walls2[0].position.set(0, 2, -6);
        walls2[1].position.set(0, 2, 6);
        walls2[1].rotation.y = Math.PI;
        walls2[2].position.set(-6, 2, 0);
        walls2[2].rotation.y = Math.PI / 2;
        walls2[3].position.set(6, 2, 0);
        walls2[3].rotation.y = -Math.PI / 2;
        walls2.forEach(wall => {
            wall.receiveShadow = true;
            room2.add(wall);
        });

        // Window 2: Vertical Slatted Window
        const slatWindow = new THREE.Mesh(new THREE.PlaneGeometry(2, 3.5), glassMaterial);
        slatWindow.position.set(6, 1.75, 0);
        slatWindow.rotation.y = -Math.PI / 2;
        room2.add(slatWindow);

        const slatGeometry = new THREE.BoxGeometry(2, 0.1, 0.05);
        for (let i = 0; i < 6; i++) {
            const slat = new THREE.Mesh(slatGeometry, woodMaterial);
            slat.position.set(6, 0.5 + i * 0.6, 0);
            slat.rotation.y = -Math.PI / 2;
            slat.rotation.z = Math.PI / 4;
            slat.castShadow = true;
            room2.add(slat);
        }

        const door2 = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 3.5), glassMaterial);
        door2.position.set(-6, 1.75, 0);
        door2.rotation.y = Math.PI / 2;
        door2.userData = { nextRoom: 0 };
        room2.add(door2);

        // Furniture 2: Vintage Leather Armchair
        const chairSeat = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.4, 1.2), leatherMaterial);
        chairSeat.position.set(0, 0.2, 0);
        chairSeat.castShadow = true;
        chairSeat.receiveShadow = true;
        room2.add(chairSeat);

        const chairBack = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1, 0.3), leatherMaterial);
        chairBack.position.set(0, 0.6, -0.45);
        chairBack.castShadow = true;
        chairBack.receiveShadow = true;
        room2.add(chairBack);

        const chairArmsGeometry = new THREE.BoxGeometry(0.2, 0.6, 1.2);
        const leftArm = new THREE.Mesh(chairArmsGeometry, leatherMaterial);
        leftArm.position.set(-0.7, 0.5, 0);
        leftArm.castShadow = true;
        room2.add(leftArm);

        const rightArm = new THREE.Mesh(chairArmsGeometry, leatherMaterial);
        rightArm.position.set(0.7, 0.5, 0);
        rightArm.castShadow = true;
        room2.add(rightArm);

        for (let i = 0; i < 4; i++) {
            const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.4, 16), metalMaterial);
            leg.position.set(
                (i % 2 === 0 ? -0.55 : 0.55),
                0.2,
                (i < 2 ? -0.55 : 0.55)
            );
            leg.rotation.x = i < 2 ? Math.PI / 12 : -Math.PI / 12;
            leg.castShadow = true;
            leg.receiveShadow = true;
            room2.add(leg);
        }

        // Installation 2: Sound-Responsive Sculpture
        this.soundSculpture = new THREE.Group();
        this.soundSculpture.userData = { isInteractive: true, type: 'soundSculpture' };
        const sphereGeometry = new THREE.SphereGeometry(0.2, 32, 32);
        const spherePositions = [
            { pos: new THREE.Vector3(-4, 1, -2), sound: 'note1.mp3' },
            { pos: new THREE.Vector3(-4.3, 1.5, -2), sound: 'note2.mp3' },
            { pos: new THREE.Vector3(-3.7, 1.5, -2), sound: 'note3.mp3' }
        ];
        this.soundSculpture.spheres = [];
        spherePositions.forEach(({ pos, sound }) => {
            const sphere = new THREE.Mesh(sphereGeometry, metalMaterial);
            sphere.position.copy(pos);
            sphere.castShadow = true;
            sphere.userData = { basePos: pos.clone(), soundFile: sound, audio: new THREE.Audio(this.audioListener) };
            this.soundSculpture.add(sphere);
            this.soundSculpture.spheres.push(sphere);

            this.loadAudio(`path/to/${sound}`).then(buffer => {
                sphere.userData.audio.setBuffer(buffer);
                sphere.userData.audio.setVolume(0.5);
            }).catch(err => console.error(`Error loading ${sound}:`, err));
        });
        room2.add(this.soundSculpture);

        room2.position.set(18, 0, 0);
        this.rooms.push(room2);

        this.rooms.forEach(room => this.scene.add(room));
    }

    generateNoiseCanvas(width, height) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext('2d');
        const imageData = context.createImageData(width, height);

        for (let i = 0; i < imageData.data.length; i += 4) {
            const noise = Math.random() * 0.1 + 0.9;
            imageData.data[i] = 136 * noise;
            imageData.data[i + 1] = 136 * noise;
            imageData.data[i + 2] = 136 * noise;
            imageData.data[i + 3] = 255;
        }

        context.putImageData(imageData, 0, 0);
        return canvas;
    }

    createAvatar() {
        this.avatarGroup = new THREE.Group();
        const avatarMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3
        });

        const clickablePlane = new THREE.Mesh(
            new THREE.PlaneGeometry(0.5, 0.5),
            new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.0 })
        );
        clickablePlane.position.set(2, 1.7, 2);
        this.avatarGroup.add(clickablePlane);

        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1, 32), avatarMaterial);
        body.position.set(2, 0.5, 2);
        this.avatarGroup.add(body);

        const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), avatarMaterial);
        head.position.set(2, 1.2, 2);
        this.avatarGroup.add(head);

        const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 32);
        const leftArm = new THREE.Mesh(armGeometry, avatarMaterial);
        leftArm.position.set(1.7, 0.7, 2);
        leftArm.rotation.z = Math.PI / 4;
        this.avatarGroup.add(leftArm);

        const rightArm = new THREE.Mesh(armGeometry, avatarMaterial);
        rightArm.position.set(2.3, 0.7, 2);
        rightArm.rotation.z = -Math.PI / 4;
        this.avatarGroup.add(rightArm);

        const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 32);
        const leftLeg = new THREE.Mesh(legGeometry, avatarMaterial);
        leftLeg.position.set(1.8, 0.25, 2);
        this.avatarGroup.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, avatarMaterial);
        rightLeg.position.set(2.2, 0.25, 2);
        this.avatarGroup.add(rightLeg);

        this.avatarGroup.userData = { isAvatar: true };
        this.scene.add(this.avatarGroup);

        this.updateAvatarPosition();
    }

    updateAvatarPosition() {
        if (this.isMobile) {
            const roomCenter = this.rooms[this.currentRoom].position.clone();
            this.avatarGroup.position.copy(roomCenter);
            this.avatarGroup.position.y = 0.5;
        } else {
            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize().multiplyScalar(2);
            this.avatarGroup.position.copy(this.camera.position).add(direction);
            this.avatarGroup.position.y = 0.5;
        }
    }

    async setupAudio() {
        try {
            const backgroundBuffer = await this.loadAudio('sweet.mp3');
            this.backgroundAudio.setBuffer(backgroundBuffer);
            this.backgroundAudio.setLoop(true);
            this.backgroundAudio.setVolume(0.2);
            this.backgroundAudio.play();

            const clickBuffer = await this.loadAudio('sweet.mp3');
            this.clickSound.setBuffer(clickBuffer);
            this.clickSound.setVolume(0.5);
        } catch (error) {
            console.error("Error loading audio:", error);
        }
    }

    loadAudio(url) {
        return new Promise((resolve, reject) => {
            const audioLoader = new THREE.AudioLoader();
            audioLoader.load(
                url,
                (audioBuffer) => resolve(audioBuffer),
                undefined,
                (err) => reject(err)
            );
        });
    }

    init() {
        console.log("🚀 Virtual Gallery loaded");
        this.setupEventListeners();
        if (this.sessionId) this.loadImages(this.sessionId);
        this.animate();
        window.addEventListener("resize", () => this.handleResize());
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        this.time += 0.016; // Approx 60 FPS delta time
        this.update();
        this.updateImageEffects();
        this.renderer.render(this.scene, this.camera);
        if (this.isMobile) this.controls.update();
        this.updateAvatarPosition();
    }

    updateImageEffects() {
        this.images.forEach((img, index) => {
            if (img.mesh.material.uniforms) {
                img.mesh.material.uniforms.time.value = this.time + index;
                const spotlight = img.mesh.parent.children.find(child => child instanceof THREE.SpotLight && child.target === img.mesh);
                if (spotlight) {
                    spotlight.intensity = 2.0 + Math.sin(this.time * 2 + index) * 0.2;
                }
            }
        });
    }

    setupEventListeners() {
        const tutorial = document.createElement("div");
        tutorial.id = "tutorialOverlay";
        tutorial.style.cssText = "position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:white; background:rgba(0,0,0,0.7); padding:20px; border-radius:5px; z-index:11; text-align:center;";
        if (this.isMobile) {
            tutorial.innerHTML = "Swipe to look around, pinch to zoom, tap artwork to focus, tap avatar for help.";
        } else {
            tutorial.innerHTML = "Click to enter the gallery. Use W, A, S, D to move, mouse to look, double-click art to focus, click avatar for help.";
        }
        document.body.appendChild(tutorial);

        this.renderer.domElement.addEventListener(this.isMobile ? "touchstart" : "click", (event) => this.onCanvasClick(event));
        if (!this.isMobile) {
            document.addEventListener("keydown", (event) => this.onKeyDown(event));
            document.addEventListener("keyup", (event) => this.onKeyUp(event));
            this.renderer.domElement.addEventListener("click", () => {
                if (!this.isLocked && !this.isFocused) {
                    this.controls.lock();
                    tutorial.style.display = "none";
                }
            });
            document.addEventListener("pointerlockchange", () => {
                this.isLocked = document.pointerLockElement === this.renderer.domElement;
                if (!this.isLocked) this.isFocused = false;
            });
            document.addEventListener("pointerlockerror", () => {
                console.error("Pointer Lock failed");
            });
        } else {
            tutorial.style.display = "none";
        }

        document.getElementById("uploadForm")?.addEventListener("submit", (e) => this.handleUploadSubmit(e));
        document.getElementById("screenshotForm")?.addEventListener("submit", (e) => this.handleScreenshotSubmit(e));
        document.getElementById("downloadBtn")?.addEventListener("click", () => this.handleDownload());
        document.getElementById("zoomSlider")?.addEventListener("input", () => this.handleZoom());
        document.getElementById("toggleControlsBtn")?.addEventListener("click", () => this.toggleControls());
        document.getElementById("prevPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom - 1));
        document.getElementById("nextPage")?.addEventListener("click", () => this.moveToRoom(this.currentRoom + 1));
        if (!this.isMobile) {
            document.getElementById("sensitivitySlider")?.addEventListener("input", () => {
                const sensitivitySlider = document.getElementById("sensitivitySlider");
                const sensitivityValue = document.getElementById("sensitivityValue");
                const sensitivity = parseFloat(sensitivitySlider.value);
                sensitivityValue.textContent = sensitivity.toFixed(3);
                this.controls.setSensitivity(sensitivity);
            });
        } else {
            const sensitivityGroup = document.querySelector(".slider-group:last-child");
            if (sensitivityGroup) sensitivityGroup.style.display = "none";
        }
    }

    toggleControls() {
        this.controlsVisible = !this.controlsVisible;
        const controlPanels = document.querySelectorAll(".control-panel");
        const toggleButton = document.getElementById("toggleControlsBtn");

        controlPanels.forEach(panel => {
            panel.classList.toggle("hidden-panel", !this.controlsVisible);
        });

        toggleButton.textContent = this.controlsVisible ? "Hide Controls" : "Show Controls";
        toggleButton.querySelector("i") && (toggleButton.querySelector("i").className = this.controlsVisible ? "fas fa-eye" : "fas fa-eye-slash");
        console.log(this.controlsVisible ? "🖥️ Controls visible" : "🖥️ Controls hidden");
    }

    onKeyDown(event) {
        switch (event.key.toLowerCase()) {
            case "w": this.keys.w = true; break;
            case "a": this.keys.a = true; break;
            case "s": this.keys.s = true; break;
            case "d": this.keys.d = true; break;
            case "escape": this.controls.unlock(); break;
        }
    }

    onKeyUp(event) {
        switch (event.key.toLowerCase()) {
            case "w": this.keys.w = false; break;
            case "a": this.keys.a = false; break;
            case "s": this.keys.s = false; break;
            case "d": this.keys.d = false; break;
        }
    }

    update() {
        if (!this.isMobile && this.isLocked && !this.isMoving && !this.isFocused) {
            const movement = new THREE.Vector3();
            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            if (this.keys.w) movement.addScaledVector(direction, this.moveSpeed);
            if (this.keys.s) movement.addScaledVector(direction, -this.moveSpeed);
            if (this.keys.a) {
                const left = new THREE.Vector3().crossVectors(this.camera.up, direction).normalize();
                movement.addScaledVector(left, -this.moveSpeed);
            }
            if (this.keys.d) {
                const right = new THREE.Vector3().crossVectors(this.camera.up, direction).normalize();
                movement.addScaledVector(right, this.moveSpeed);
            }

            this.controls.getObject().position.add(movement);
            this.checkCollisions();
        }

        // Kinetic Light Wall (Room 1)
        if (this.lightWall && this.currentRoom === 0) {
            const cameraPos = this.camera.position;
            this.lightWall.children.forEach(rod => {
                const dist = cameraPos.distanceTo(rod.position);
                const intensity = Math.max(0.5, Math.min(1.5, 5 / dist));
                const hue = (dist / 10 + this.time) % 1;
                rod.material.color.setHSL(hue, 0.8, intensity * 0.5);
                rod.userData.intensity = intensity;
            });
        }

        // Sound-Responsive Sculpture (Room 2)
        if (this.soundSculpture && this.currentRoom === 1) {
            const cameraPos = this.camera.position;
            this.soundSculpture.spheres.forEach(sphere => {
                const dist = cameraPos.distanceTo(sphere.position);
                if (dist < 3 && !sphere.userData.audio.isPlaying) {
                    sphere.userData.audio.play();
                    sphere.position.y = sphere.userData.basePos.y + Math.sin(this.time * 5) * 0.1;
                } else if (dist >= 3) {
                    sphere.position.lerp(sphere.userData.basePos, 0.1);
                }
            });
        }

        if (this.interactionCooldown > 0) this.interactionCooldown -= 0.016;
    }

    checkCollisions() {
        if (!this.isMobile) {
            this.camera.position.y = 1.6;
            const roomBounds = this.rooms[this.currentRoom].position;
            const minX = roomBounds.x - 7;
            const maxX = roomBounds.x + 7;
            const minZ = roomBounds.z - 7;
            const maxZ = roomBounds.z + 7;

            this.camera.position.x = Math.max(minX, Math.min(maxX, this.camera.position.x));
            this.camera.position.z = Math.max(minZ, Math.min(maxZ, this.camera.position.z));
            this.controls.getObject().position.copy(this.camera.position);
        }
    }

    moveToRoom(roomIndex) {
        if (roomIndex < 0 || roomIndex >= this.rooms.length || this.isMoving) return;

        this.isMoving = true;
        const settings = this.roomCameraSettings[roomIndex];
        const targetPos = settings.position.clone();
        const targetLookAt = settings.lookAt.clone();
        const startPos = this.camera.position.clone();
        const startLookAt = this.isMobile ? this.controls.target.clone() : this.camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(5).add(this.camera.position);
        const duration = 1000;
        const startTime = performance.now();

        const animateMove = (time) => {
            const elapsed = time - startTime;
            const t = Math.min(elapsed / duration, 1);
            const easedT = 0.5 - 0.5 * Math.cos(Math.PI * t);
            this.camera.position.lerpVectors(startPos, targetPos, easedT);
            if (this.isMobile) {
                this.controls.target.lerpVectors(startLookAt, targetLookAt, easedT);
            } else {
                this.controls.getObject().position.copy(this.camera.position);
                this.camera.lookAt(targetLookAt);
            }
            this.checkCollisions();

            if (t < 1) {
                requestAnimationFrame(animateMove);
            } else {
                this.currentRoom = roomIndex;
                this.isMoving = false;
                this.isFocused = false;
                this.updateCameraState();
                if (!this.isMobile && this.isLocked) this.controls.lock();
                this.displayImagesInGallery();
            }
        };
        requestAnimationFrame(animateMove);
    }

    async loadImages(sessionId) {
        try {
            const response = await fetch(`http://localhost:3000/api/screenshots/${sessionId}/`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            console.log("📸 Found images in session", sessionId + ":", data.screenshots);
            if (!data.screenshots?.length) {
                console.log("No screenshots found");
                this.imagesToLoad = [
                    "https://via.placeholder.com/350x250",
                    "https://via.placeholder.com/350x250"
                ];
            } else {
                this.imagesToLoad = data.screenshots.map(img => `http://localhost:3000${img}`);
            }
            this.displayImagesInGallery();
        } catch (error) {
            console.error("❌ Error fetching images:", error);
            this.imagesToLoad = [
                "https://via.placeholder.com/350x250",
                "https://via.placeholder.com/350x250"
            ];
            this.displayImagesInGallery();
        }
    }

    async displayImagesInGallery() {
        if (!this.imagesToLoad) return;

        this.clearScene();
        const totalImages = this.imagesToLoad.length;
        let imageIndex = this.currentRoom * 12;

        const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.8 });
        const fallbackMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0 });

        const room = this.rooms[this.currentRoom];
        const wallLength = room === this.rooms[0] ? 15 : 12;
        const displayWidth = 3.5;
        const displayHeight = 2.5;
        const displayDepth = 0.2;
        const spacing = 1.0;
        const imageOffset = 0.1;
        const backWallOffset = 0.3;
        const numImagesPerWall = Math.floor(wallLength / (displayWidth + spacing));
        const maxImagesInRoom = Math.min(12, numImagesPerWall * 4);

        const wallConfigs = [
            { basePos: new THREE.Vector3(0, 2, -wallLength / 2 + backWallOffset), rot: 0, dir: 'x' },
            { basePos: new THREE.Vector3(-wallLength / 2 + backWallOffset, 2, 0), rot: Math.PI / 2, dir: 'z' },
            { basePos: new THREE.Vector3(wallLength / 2 - backWallOffset, 2, 0), rot: -Math.PI / 2, dir: 'z' },
            { basePos: new THREE.Vector3(0, 2, wallLength / 2 - backWallOffset), rot: Math.PI, dir: 'x' }
        ];

        for (let wall of wallConfigs) {
            if (imageIndex >= totalImages || this.images.length >= maxImagesInRoom) break;

            const wallPositions = [];
            for (let i = 0; i < numImagesPerWall && imageIndex < totalImages && this.images.length < maxImagesInRoom; i++) {
                const offset = -wallLength / 2 + (i + 0.5) * (wallLength / numImagesPerWall);
                const pos = wall.basePos.clone();
                if (wall.dir === 'x') pos.x += offset;
                else pos.z += offset;
                wallPositions.push({ pos, rot: wall.rot });
            }

            for (let { pos, rot } of wallPositions) {
                try {
                    const texture = await this.loadTexture(this.imagesToLoad[imageIndex]);
                    let material;
                    if (texture.image) {
                        material = new THREE.ShaderMaterial({
                            uniforms: {
                                map: { value: texture },
                                opacity: { value: 1.0 },
                                time: { value: 0.0 }
                            },
                            vertexShader: `
                                varying vec2 vUv;
                                varying vec3 vNormal;
                                void main() {
                                    vUv = uv;
                                    vNormal = normalMatrix * normal;
                                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                }
                            `,
                            fragmentShader: `
                                uniform sampler2D map;
                                uniform float opacity;
                                uniform float time;
                                varying vec2 vUv;
                                varying vec3 vNormal;
                                void main() {
                                    vec4 color = texture2D(map, vUv);
                                    if (color.a < 0.5) discard;
                                    gl_FragColor = vec4(color.rgb, color.a * opacity);
                                }
                            `,
                            transparent: true,
                            side: THREE.DoubleSide
                        });
                    } else {
                        material = fallbackMaterial;
                    }

                    const aspectRatio = texture.image ? texture.image.width / texture.image.height : 1;
                    const maxWidth = 3.5;
                    const adjustedWidth = Math.min(displayHeight * aspectRatio, maxWidth);

                    const geometry = new THREE.BoxGeometry(adjustedWidth, displayHeight, displayDepth);
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(pos).add(room.position);
                    mesh.rotation.y = rot;
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData = { filename: this.imagesToLoad[imageIndex] };
                    room.add(mesh);
                    this.images.push({ mesh, filename: this.imagesToLoad[imageIndex] });

                    const frameThickness = 0.1;
                    const frameShape = new THREE.Shape();
                    frameShape.moveTo(-adjustedWidth / 2 - frameThickness, -displayHeight / 2 - frameThickness);
                    frameShape.lineTo(adjustedWidth / 2 + frameThickness, -displayHeight / 2 - frameThickness);
                    frameShape.lineTo(adjustedWidth / 2 + frameThickness, displayHeight / 2 + frameThickness);
                    frameShape.lineTo(-adjustedWidth / 2 - frameThickness, displayHeight / 2 + frameThickness);
                    frameShape.lineTo(-adjustedWidth / 2 - frameThickness, -displayHeight / 2 - frameThickness);

                    const hole = new THREE.Path();
                    hole.moveTo(-adjustedWidth / 2, -displayHeight / 2);
                    hole.lineTo(adjustedWidth / 2, -displayHeight / 2);
                    hole.lineTo(adjustedWidth / 2, displayHeight / 2);
                    hole.lineTo(-adjustedWidth / 2, displayHeight / 2);
                    hole.lineTo(-adjustedWidth / 2, -displayHeight / 2);
                    frameShape.holes.push(hole);

                    const extrudeSettings = { depth: frameThickness, bevelEnabled: false };
                    const frameGeometry = new THREE.ExtrudeGeometry(frameShape, extrudeSettings);
                    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                    frame.position.copy(mesh.position);
                    frame.position.z += (rot === 0 ? -displayDepth / 2 : (rot === Math.PI ? displayDepth / 2 : 0));
                    frame.position.x += (rot === Math.PI / 2 ? -displayDepth / 2 : (rot === -Math.PI / 2 ? displayDepth / 2 : 0));
                    frame.rotation.y = rot;
                    frame.castShadow = true;
                    frame.receiveShadow = true;
                    room.add(frame);

                    const spotlight = new THREE.SpotLight(0xffffff, 2.0, 15, Math.PI / 6, 0.7);
                    const lightOffset = 1;
                    spotlight.position.set(
                        pos.x + (Math.abs(rot) === Math.PI / 2 ? (rot > 0 ? lightOffset : -lightOffset) : 0),
                        room === this.rooms[0] ? 4.5 : 3.5,
                        pos.z + (Math.abs(rot) === Math.PI / 2 ? 0 : (rot === 0 ? -lightOffset : lightOffset))
                    ).add(room.position);
                    spotlight.target = mesh;
                    spotlight.castShadow = true;
                    spotlight.shadow.mapSize.width = 1024;
                    spotlight.shadow.mapSize.height = 1024;
                    spotlight.shadow.bias = -0.0001;
                    room.add(spotlight);

                    imageIndex++;
                } catch (error) {
                    console.error(`Error loading image ${this.imagesToLoad[imageIndex]}:`, error);
                    imageIndex++;
                }
            }
        }
        console.log(`🎨 Images rendered in room ${this.currentRoom}:`, this.images.length);
    }

    clearScene() {
        this.images.forEach(img => {
            if (img.mesh.parent) {
                img.mesh.parent.remove(img.mesh);
            }
            img.mesh.geometry.dispose();
            if (img.mesh.material.map) img.mesh.material.map.dispose();
            img.mesh.material.dispose();
        });
        this.images = [];
        this.rooms.forEach(room => {
            const toRemove = room.children.filter(child => 
                child instanceof THREE.SpotLight || 
                (child.material?.color?.getHex() === 0x333333)
            );
            toRemove.forEach(child => {
                room.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
        });
        console.log("🗑️ Scene cleared");
    }

    loadTexture(filename) {
        return new Promise((resolve, reject) => {
            this.textureLoader.load(
                filename,
                (texture) => {
                    texture.minFilter = THREE.LinearMipmapLinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.generateMipmaps = true;
                    texture.anisotropy = Math.min(8, this.renderer.capabilities.getMaxAnisotropy() || 1);
                    texture.needsUpdate = true;
                    resolve(texture);
                },
                undefined,
                (err) => reject(err)
            );
        });
    }

    onCanvasClick(event) {
        const currentTime = new Date().getTime();
        const timeSinceLastClick = currentTime - this.lastClickTime;

        if (timeSinceLastClick < this.clickDelay) {
            this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            this.raycaster.setFromCamera(this.mouse, this.camera);
            const intersects = this.raycaster.intersectObjects([
                ...this.images.map(img => img.mesh),
                ...this.scene.children.filter(obj => 
                    obj.userData.nextRoom !== undefined || 
                    (obj.parent && obj.parent.userData.isAvatar) || 
                    obj.userData.isInteractive
                ).flatMap(obj => obj.children.length ? obj.children : [obj])
            ]);

            if (intersects.length > 0 && this.interactionCooldown <= 0) {
                const obj = intersects[0].object;
                if (this.isFocused) {
                    this.resetCamera();
                } else if (obj.userData.nextRoom !== undefined) {
                    this.moveToRoom(obj.userData.nextRoom);
                } else if (obj.parent && obj.parent.userData.isAvatar) {
                    this.showAvatarInstructions();
                } else if (obj.userData.filename) {
                    console.log(`Clicked image: ${obj.userData.filename}`);
                    if (!this.clickSound.isPlaying) this.clickSound.play();
                    this.focusImage(obj);
                } else if (obj.parent && obj.parent.userData.type === 'lightWall') {
                    obj.material.color.setHSL(Math.random(), 0.8, 1);
                    this.interactionCooldown = 0.5;
                } else if (obj.parent && obj.parent.userData.type === 'soundSculpture') {
                    if (!obj.userData.audio.isPlaying) {
                        obj.userData.audio.play();
                        obj.position.y += 0.2;
                        setTimeout(() => obj.position.lerp(obj.userData.basePos, 0.1), 100);
                    }
                    this.interactionCooldown = 0.5;
                }
            }
        }
        this.lastClickTime = currentTime;
    }

    focusImage(mesh) {
        this.updateCameraState();
        this.isFocused = true;

        if (this.isMobile) {
            const targetPos = mesh.position.clone();
            targetPos.y = 1.6;
            const distance = 2;
            const direction = new THREE.Vector3();
            direction.subVectors(this.camera.position, targetPos).normalize();
            targetPos.add(direction.multiplyScalar(-distance));

            const startPos = this.camera.position.clone();
            const startTarget = this.controls.target.clone();
            const duration = 500;
            const startTime = performance.now();

            const animateFocus = (time) => {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                this.camera.position.lerpVectors(startPos, targetPos, t);
                this.controls.target.lerpVectors(startTarget, mesh.position, t);
                this.controls.update();

                if (t < 1) requestAnimationFrame(animateFocus);
            };
            requestAnimationFrame(animateFocus);
        } else {
            const direction = new THREE.Vector3();
            this.camera.getWorldDirection(direction);

            const targetPos = mesh.position.clone().sub(direction.multiplyScalar(2));
            targetPos.y = 1.6;

            const roomBounds = this.rooms[this.currentRoom].position;
            const minX = roomBounds.x - 7 + 1;
            const maxX = roomBounds.x + 7 - 1;
            const minZ = roomBounds.z - 7 + 1;
            const maxZ = roomBounds.z + 7 - 1;

            targetPos.x = Math.max(minX, Math.min(maxX, targetPos.x));
            targetPos.z = Math.max(minZ, Math.min(maxZ, targetPos.z));

            const startPos = this.camera.position.clone();
            const duration = 500;
            const startTime = performance.now();

            const animateFocus = (time) => {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                this.camera.position.lerpVectors(startPos, targetPos, t);
                this.controls.getObject().position.copy(this.camera.position);
                this.camera.lookAt(mesh.position);
                this.checkCollisions();

                if (t < 1) requestAnimationFrame(animateFocus);
            };
            requestAnimationFrame(animateFocus);
        }
    }

    resetCamera() {
        if (!this.isFocused) return;

        const startPos = this.camera.position.clone();
        const targetPos = this.previousCameraState.position.clone();
        const duration = 500;
        const startTime = performance.now();

        if (this.isMobile) {
            const startTarget = this.controls.target.clone();
            const targetTarget = this.previousCameraState.target.clone();

            const animateReset = (time) => {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                const easedT = 0.5 - 0.5 * Math.cos(Math.PI * t);
                this.camera.position.lerpVectors(startPos, targetPos, easedT);
                this.controls.target.lerpVectors(startTarget, targetTarget, easedT);
                this.controls.update();

                if (t < 1) requestAnimationFrame(animateReset);
                else this.isFocused = false;
            };
            requestAnimationFrame(animateReset);
        } else {
            const animateReset = (time) => {
                const elapsed = time - startTime;
                const t = Math.min(elapsed / duration, 1);
                const easedT = 0.5 - 0.5 * Math.cos(Math.PI * t);
                this.camera.position.lerpVectors(startPos, targetPos, easedT);
                this.controls.getObject().position.copy(this.camera.position);
                this.checkCollisions();

                if (t < 1) requestAnimationFrame(animateReset);
                else {
                    this.isFocused = false;
                    if (!this.isMoving) this.controls.lock();
                }
            };
            requestAnimationFrame(animateReset);
        }
    }

    updateCameraState() {
        this.previousCameraState = {
            position: this.camera.position.clone(),
            rotation: this.camera.rotation.clone(),
            target: this.isMobile ? this.controls.target.clone() : this.camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(5).add(this.camera.position)
        };
    }

    handleDownload() {
        const imgData = this.renderer.domElement.toDataURL("image/png");
        const link = document.createElement("a");
        link.href = imgData;
        link.download = "gallery_view.png";
        link.click();
    }

    handleZoom() {
        const zoomSlider = document.getElementById("zoomSlider");
        const zoomValue = document.getElementById("zoomValue");
        const zoomLevel = parseFloat(zoomSlider.value);
        zoomValue.textContent = zoomLevel.toFixed(1);
        if (this.isMobile) {
            this.controls.minDistance = 1 / zoomLevel;
            this.controls.maxDistance = 10 / zoomLevel;
            this.controls.update();
        } else {
            this.moveSpeed = zoomLevel / 10;
            this.camera.fov = 75 / (zoomLevel * 0.5 + 0.5);
            this.camera.updateProjectionMatrix();
        }
    }

    async handleScreenshotSubmit(event) {
        event.preventDefault();
        const url = document.getElementById("url")?.value;
        if (!url) return;

        try {
            const response = await fetch("http://localhost:3000/api/capture", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url })
            });
            const result = await response.json();
            if (result.sessionId) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                await this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error capturing screenshot:", error);
        }
    }

    async handleUploadSubmit(event) {
        event.preventDefault();
        const fileInput = document.getElementById("images");
        if (!fileInput?.files?.length) return;

        const formData = new FormData();
        for (const file of fileInput.files) {
            formData.append("images", file);
        }

        try {
            const response = await fetch(`http://localhost:3000/api/upload${this.sessionId ? `/${this.sessionId}` : ''}`, {
                method: "POST",
                body: formData
            });
            const result = await response.json();
            if (result.success) {
                this.sessionId = result.sessionId;
                localStorage.setItem('sessionId', this.sessionId);
                await this.loadImages(this.sessionId);
            }
        } catch (error) {
            console.error("Error uploading files:", error);
        }
    }

    handleResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    showAvatarInstructions() {
        const instructions = document.createElement("div");
        instructions.id = "avatarInstructions";
        instructions.style.cssText = "position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:white; background:rgba(0,0,0,0.7); padding:20px; border-radius:5px; z-index:11; text-align:center;";
        if (this.isMobile) {
            instructions.innerHTML = `
                <h3>Gallery Controls</h3>
                <p>Swipe to look around.</p>
                <p>Pinch to zoom in/out.</p>
                <p>Tap an artwork to focus, tap again to reset.</p>
                <p>Tap Previous/Next Room buttons to navigate.</p>
                <button id="closeInstructions" style="margin-top:10px; padding:5px 10px; background:#1e90ff; border:none; color:white; border-radius:5px; cursor:pointer;">Close</button>
            `;
        } else {
            instructions.innerHTML = `
                <h3>Gallery Controls</h3>
                <p>Click to lock pointer and start exploring.</p>
                <p>Use W, A, S, D to move.</p>
                <p>Mouse to look around.</p>
                <p>Double-click an artwork to focus, double-click again to reset.</p>
                <p>Click Previous/Next Room buttons to navigate.</p>
                <button id="closeInstructions" style="margin-top:10px; padding:5px 10px; background:#1e90ff; border:none; color:white; border-radius:5px; cursor:pointer;">Close</button>
            `;
        }
        document.body.appendChild(instructions);

        document.getElementById("closeInstructions").addEventListener("click", () => {
            document.body.removeChild(instructions);
        });
    }
}

const app = new ThreeJSApp();
app.init();